"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[8090],{2038(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"textbook/modules/simulation-to-real/labs/lab-10-02","title":"System Identification for Real Robots","description":"Objectives","source":"@site/docs/textbook/modules/10-simulation-to-real/labs/lab-10-02.md","sourceDirName":"textbook/modules/10-simulation-to-real/labs","slug":"/textbook/modules/simulation-to-real/labs/lab-10-02","permalink":"/Hackathon-3/docs/textbook/modules/simulation-to-real/labs/lab-10-02","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/10-simulation-to-real/labs/lab-10-02.md","tags":[],"version":"current","frontMatter":{"id":"lab-10-02","module_id":"10","title":"System Identification for Real Robots","difficulty":"intermediate","tier":"low_cost_hardware","duration_minutes":90},"sidebar":"tutorialSidebar","previous":{"title":"Domain Randomization Fundamentals","permalink":"/Hackathon-3/docs/textbook/modules/simulation-to-real/labs/lab-10-01"},"next":{"title":"Complete Sim-to-Real Transfer Pipeline","permalink":"/Hackathon-3/docs/textbook/modules/simulation-to-real/labs/lab-10-03"}}');var r=t(4848),s=t(8453);const a={id:"lab-10-02",module_id:"10",title:"System Identification for Real Robots",difficulty:"intermediate",tier:"low_cost_hardware",duration_minutes:90},o="Lab 10-02: System Identification for Real Robots",l={},d=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"Why System Identification?",id:"why-system-identification",level:3},{value:"Identification Approaches",id:"identification-approaches",level:3},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Set Up Robot Interface",id:"step-1-set-up-robot-interface",level:3},{value:"Step 2: Perform Step Response Experiment",id:"step-2-perform-step-response-experiment",level:3},{value:"Step 3: Identify Friction Parameters",id:"step-3-identify-friction-parameters",level:3},{value:"Step 4: Frequency Response Analysis",id:"step-4-frequency-response-analysis",level:3},{value:"Step 5: Validate Parameters in Simulation",id:"step-5-validate-parameters-in-simulation",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2},{value:"Common Errors",id:"common-errors",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Related Content",id:"related-content",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"lab-10-02-system-identification-for-real-robots",children:"Lab 10-02: System Identification for Real Robots"})}),"\n",(0,r.jsx)(n.h2,{id:"objectives",children:"Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this lab, you will be able to:"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Perform frequency response experiments on real robots"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Identify system parameters (inertia, friction, damping)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Fit dynamic models to experimental data"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Validate identified parameters in simulation"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Completed Lab 10-01 (Domain Randomization)"}),"\n",(0,r.jsx)(n.li,{children:"Understanding of dynamics (Module 05)"}),"\n",(0,r.jsx)(n.li,{children:"Access to TurtleBot 4 or similar platform"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"materials",children:"Materials"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Name"}),(0,r.jsx)(n.th,{children:"Tier"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"hardware"}),(0,r.jsx)(n.td,{children:"TurtleBot 4 Lite"}),(0,r.jsx)(n.td,{children:"required"}),(0,r.jsx)(n.td,{children:"Low-cost mobile robot platform"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"software"}),(0,r.jsx)(n.td,{children:"ROS2 Humble"}),(0,r.jsx)(n.td,{children:"required"}),(0,r.jsx)(n.td,{children:"Robot interface"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"software"}),(0,r.jsx)(n.td,{children:"Python 3.10+"}),(0,r.jsx)(n.td,{children:"required"}),(0,r.jsx)(n.td,{children:"Data analysis"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"software"}),(0,r.jsx)(n.td,{children:"SciPy, NumPy"}),(0,r.jsx)(n.td,{children:"required"}),(0,r.jsx)(n.td,{children:"Signal processing, optimization"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,r.jsx)(n.h3,{id:"why-system-identification",children:"Why System Identification?"}),"\n",(0,r.jsx)(n.p,{children:"To transfer from simulation to reality, we need accurate models:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inertial parameters"}),": Mass, moment of inertia"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Friction models"}),": Coulomb, viscous, Stribeck effects"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actuator dynamics"}),": Motor constants, gearbox ratios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor characteristics"}),": Noise, bias, calibration"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"identification-approaches",children:"Identification Approaches"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Frequency response"}),": Input swept-sine, measure output"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Step response"}),": Apply step input, fit transfer function"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trajectory tracking"}),": Execute rich trajectory, regress parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Least squares"}),": Minimize prediction error over data"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"instructions",children:"Instructions"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-set-up-robot-interface",children:"Step 1: Set Up Robot Interface"}),"\n",(0,r.jsx)(n.p,{children:"Connect to TurtleBot 4 via ROS2:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nrobot_interface.py\nInterface for TurtleBot 4 system identification.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom nav_msgs.msg import Odometry\nfrom sensor_msgs.msg import Imu\nimport numpy as np\nimport time\n\nclass TurtleBotInterface(Node):\n    \"\"\"ROS2 interface for TurtleBot 4.\"\"\"\n\n    def __init__(self):\n        super().__init__('turtlebot_interface')\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n\n        # Subscribers\n        self.odom_sub = self.create_subscription(\n            Odometry, '/odom', self.odom_callback, 10\n        )\n        self.imu_sub = self.create_subscription(\n            Imu, '/imu', self.imu_callback, 10\n        )\n\n        # Data storage\n        self.odom_data = []\n        self.imu_data = []\n        self.cmd_data = []\n\n        # Current state\n        self.current_odom = None\n        self.current_imu = None\n\n        self.get_logger().info('TurtleBot interface initialized')\n\n    def odom_callback(self, msg):\n        \"\"\"Store odometry data.\"\"\"\n        self.current_odom = msg\n        self.odom_data.append({\n            'time': time.time(),\n            'x': msg.pose.pose.position.x,\n            'y': msg.pose.pose.position.y,\n            'vx': msg.twist.twist.linear.x,\n            'vy': msg.twist.twist.linear.y,\n            'omega': msg.twist.twist.angular.z\n        })\n\n    def imu_callback(self, msg):\n        \"\"\"Store IMU data.\"\"\"\n        self.current_imu = msg\n        self.imu_data.append({\n            'time': time.time(),\n            'ax': msg.linear_acceleration.x,\n            'ay': msg.linear_acceleration.y,\n            'omega_z': msg.angular_velocity.z\n        })\n\n    def send_velocity_command(self, linear_x, angular_z):\n        \"\"\"\n        Send velocity command to robot.\n\n        Args:\n            linear_x: Forward velocity (m/s)\n            angular_z: Angular velocity (rad/s)\n        \"\"\"\n        cmd = Twist()\n        cmd.linear.x = float(linear_x)\n        cmd.angular.z = float(angular_z)\n\n        self.cmd_vel_pub.publish(cmd)\n        self.cmd_data.append({\n            'time': time.time(),\n            'linear_x': linear_x,\n            'angular_z': angular_z\n        })\n\n    def stop(self):\n        \"\"\"Send stop command.\"\"\"\n        self.send_velocity_command(0.0, 0.0)\n\n    def get_data_arrays(self):\n        \"\"\"\n        Convert collected data to numpy arrays.\n\n        Returns:\n            odom_array, imu_array, cmd_array\n        \"\"\"\n        if not self.odom_data:\n            return None, None, None\n\n        odom_times = np.array([d['time'] for d in self.odom_data])\n        odom_vx = np.array([d['vx'] for d in self.odom_data])\n        odom_omega = np.array([d['omega'] for d in self.odom_data])\n\n        cmd_times = np.array([d['time'] for d in self.cmd_data])\n        cmd_vx = np.array([d['linear_x'] for d in self.cmd_data])\n        cmd_omega = np.array([d['angular_z'] for d in self.cmd_data])\n\n        return {\n            'odom': {'time': odom_times, 'vx': odom_vx, 'omega': odom_omega},\n            'cmd': {'time': cmd_times, 'vx': cmd_vx, 'omega': cmd_omega}\n        }\n\n# Initialize interface\nrclpy.init()\nrobot = TurtleBotInterface()\n\nprint(\"TurtleBot interface ready\")\nprint(\"To use: robot.send_velocity_command(linear, angular)\")\n"})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Expected"}),": ROS2 connection established, odometry and IMU data streaming."]})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-perform-step-response-experiment",children:"Step 2: Perform Step Response Experiment"}),"\n",(0,r.jsx)(n.p,{children:"Execute step input and record response:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nstep_response_experiment.py\nMeasure robot step response for identification.\n"""\n\nimport rclpy\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom robot_interface import TurtleBotInterface\nimport time\n\ndef run_step_response_experiment(robot, cmd_value=0.2, duration=5.0):\n    """\n    Run step response experiment.\n\n    Args:\n        robot: TurtleBotInterface instance\n        cmd_value: Step command magnitude (m/s)\n        duration: Experiment duration (s)\n\n    Returns:\n        data: Collected data dictionary\n    """\n    print(f"Running step response experiment: {cmd_value} m/s for {duration}s")\n\n    # Clear previous data\n    robot.odom_data = []\n    robot.cmd_data = []\n\n    # Wait for steady state\n    robot.stop()\n    time.sleep(2.0)\n\n    # Apply step input\n    start_time = time.time()\n    robot.send_velocity_command(cmd_value, 0.0)\n\n    # Collect data\n```python\n```python\n    while time.time() - start_time < duration:\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"        rclpy.spin_once(robot, timeout_sec=0.01)\n        time.sleep(0.01)\n\n    # Stop robot\n    robot.stop()\n    time.sleep(1.0)\n\n    # Get data\n    data = robot.get_data_arrays()\n\n    print(f\"Collected {len(data['odom']['time'])} odometry samples\")\n\n    return data\n\ndef analyze_step_response(data, cmd_value):\n    \"\"\"\n    Analyze step response to identify first-order system.\n\n    Model: G(s) = K / (\u03c4s + 1)\n\n    Args:\n        data: Experimental data\n        cmd_value: Step input magnitude\n\n    Returns:\n        params: Identified parameters {K, tau}\n    \"\"\"\n    odom_time = data['odom']['time']\n    odom_vx = data['odom']['vx']\n\n    # Normalize time\n    t = odom_time - odom_time[0]\n\n    # Find steady-state value\n    v_ss = np.mean(odom_vx[-100:])  # Average last 100 samples\n\n    # Compute gain\n    K = v_ss / cmd_value\n\n    # Find time constant (time to reach 63.2% of steady state)\n    target_velocity = 0.632 * v_ss\n    idx_63 = np.where(odom_vx >= target_velocity)[0]\n\n```python\n```python\n    if len(idx_63) > 0:\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"        tau = t[idx_63[0]]\n    else:\n        tau = 0.5  # Default if not reached\n\n    params = {\n        'K': K,\n        'tau': tau,\n        'v_ss': v_ss\n    }\n\n    print(f\"\\nIdentified Parameters:\")\n    print(f\"  Gain K: {K:.3f}\")\n    print(f\"  Time constant \u03c4: {tau:.3f} s\")\n    print(f\"  Steady-state velocity: {v_ss:.3f} m/s\")\n\n    return params\n\ndef plot_step_response(data, params, cmd_value):\n    \"\"\"Plot experimental and fitted step response.\"\"\"\n    odom_time = data['odom']['time']\n    odom_vx = data['odom']['vx']\n\n    t = odom_time - odom_time[0]\n\n    # First-order model prediction\n    K = params['K']\n    tau = params['tau']\n    v_model = K * cmd_value * (1 - np.exp(-t / tau))\n\n    plt.figure(figsize=(10, 6))\n    plt.plot(t, odom_vx, 'b-', label='Measured', linewidth=2)\n    plt.plot(t, v_model, 'r--', label=f'Model (K={K:.2f}, \u03c4={tau:.2f}s)', linewidth=2)\n    plt.axhline(params['v_ss'], color='g', linestyle=':', label='Steady State')\n    plt.axhline(0.632 * params['v_ss'], color='orange', linestyle=':', label='63.2%')\n\n    plt.xlabel('Time (s)', fontsize=12)\n    plt.ylabel('Linear Velocity (m/s)', fontsize=12)\n    plt.title('Step Response: Experimental vs Model', fontsize=14)\n    plt.legend(fontsize=10)\n    plt.grid(True, alpha=0.3)\n    plt.tight_layout()\n    plt.savefig('step_response.png', dpi=150)\n    print(\"\\nPlot saved as step_response.png\")\n\n# Run experiment\nprint(\"Starting step response experiment...\")\nprint(\"Make sure robot has clear space in front!\")\ninput(\"Press Enter to start...\")\n\ndata = run_step_response_experiment(robot, cmd_value=0.2, duration=5.0)\nparams = analyze_step_response(data, cmd_value=0.2)\nplot_step_response(data, params, cmd_value=0.2)\n"})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Expected"}),": Step response data collected, first-order model fitted with gain and time constant."]})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-identify-friction-parameters",children:"Step 3: Identify Friction Parameters"}),"\n",(0,r.jsx)(n.p,{children:"Use constant velocity tests to estimate friction:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nfriction_identification.py\nIdentify friction parameters from velocity experiments.\n"""\n\nimport numpy as np\nfrom scipy.optimize import least_squares\nimport matplotlib.pyplot as plt\n\ndef run_constant_velocity_tests(robot, velocities, duration=3.0):\n    """\n    Run multiple constant velocity tests.\n\n    Args:\n        robot: TurtleBotInterface\n        velocities: List of test velocities\n        duration: Time at each velocity\n\n    Returns:\n        results: List of {cmd, measured_velocity, measured_torque}\n    """\n    results = []\n\n    for v_cmd in velocities:\n        print(f"Testing velocity: {v_cmd:.3f} m/s")\n\n        # Clear data\n        robot.odom_data = []\n        robot.imu_data = []\n\n        # Wait for steady state\n        robot.stop()\n        time.sleep(2.0)\n\n        # Apply command\n        start_time = time.time()\n        robot.send_velocity_command(v_cmd, 0.0)\n\n        # Collect data\n```python\n```python\n        while time.time() - start_time < duration:\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"            rclpy.spin_once(robot, timeout_sec=0.01)\n            time.sleep(0.01)\n\n        robot.stop()\n\n        # Get data\n        data = robot.get_data_arrays()\n\n        if data['odom'] is not None:\n            # Get steady-state velocity (average last half)\n            n = len(data['odom']['vx'])\n            v_measured = np.mean(data['odom']['vx'][n//2:])\n\n            results.append({\n                'v_cmd': v_cmd,\n                'v_measured': v_measured\n            })\n\n        time.sleep(1.0)\n\n    return results\n\ndef fit_friction_model(results):\n    \"\"\"\n    Fit friction model: F_friction = F_c*sign(v) + b*v\n\n    Args:\n        results: Experimental data\n\n    Returns:\n        params: {F_c, b} Coulomb and viscous friction\n    \"\"\"\n    # Extract data\n    v_cmd = np.array([r['v_cmd'] for r in results])\n    v_measured = np.array([r['v_measured'] for r in results])\n\n    # Assume force proportional to command error at steady state\n    # F_applied = k_motor * v_cmd\n    # At steady state: F_applied = F_friction\n    # F_friction = F_c*sign(v) + b*v\n\n    # Simplified: fit linear model to positive velocities\n```python\n```python\n    positive_mask = v_cmd > 0\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'    v_pos = v_measured[positive_mask]\n    cmd_pos = v_cmd[positive_mask]\n\n    # Assume motor constant k\n    k_motor = 1.0  # Normalize\n\n    # Friction force = k * (cmd - measured)\n    F_friction = k_motor * (cmd_pos - v_pos)\n\n    # Fit: F = F_c + b*v\n    A = np.column_stack([np.ones_like(v_pos), v_pos])\n    params_fit = np.linalg.lstsq(A, F_friction, rcond=None)[0]\n\n    F_c = params_fit[0]\n    b = params_fit[1]\n\n    print(f"\\nFriction Model:")\n    print(f"  Coulomb friction F_c: {F_c:.4f}")\n    print(f"  Viscous damping b: {b:.4f}")\n\n    return {\'F_c\': F_c, \'b\': b, \'k_motor\': k_motor}\n\n# Run friction identification\nvelocities = np.linspace(0.05, 0.5, 8)\nprint(f"Testing {len(velocities)} velocities...")\n\nresults = run_constant_velocity_tests(robot, velocities, duration=3.0)\nfriction_params = fit_friction_model(results)\n'})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Expected"}),": Friction parameters identified from constant velocity tests."]})}),"\n",(0,r.jsx)(n.h3,{id:"step-4-frequency-response-analysis",children:"Step 4: Frequency Response Analysis"}),"\n",(0,r.jsx)(n.p,{children:"Perform swept-sine input for frequency response:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nfrequency_response.py\nIdentify frequency response using chirp signal.\n"""\n\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\n\ndef generate_chirp_signal(duration, f_min, f_max, amplitude, dt=0.01):\n    """\n    Generate chirp (swept-sine) signal.\n\n    Args:\n        duration: Signal duration (s)\n        f_min, f_max: Frequency range (Hz)\n        amplitude: Signal amplitude\n        dt: Time step\n\n    Returns:\n        t, signal: Time and signal arrays\n    """\n    t = np.arange(0, duration, dt)\n    chirp = amplitude * signal.chirp(t, f_min, duration, f_max, method=\'linear\')\n    return t, chirp\n\ndef run_chirp_experiment(robot, amplitude=0.1, duration=20.0, f_min=0.1, f_max=5.0):\n    """\n    Run chirp excitation experiment.\n\n    Args:\n        robot: TurtleBotInterface\n        amplitude: Chirp amplitude (m/s)\n        duration: Experiment duration\n        f_min, f_max: Frequency range\n\n    Returns:\n        input_signal, output_signal, time\n    """\n    print(f"Running chirp experiment: {f_min}-{f_max} Hz, {duration}s")\n\n    # Generate chirp\n    t_chirp, chirp_signal = generate_chirp_signal(duration, f_min, f_max, amplitude)\n\n    # Clear data\n    robot.odom_data = []\n\n    # Execute chirp\n    start_time = time.time()\n    for i, cmd in enumerate(chirp_signal):\n```python\n```python\n        if i % 10 == 0:  # Every 100ms\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'            robot.send_velocity_command(cmd, 0.0)\n            rclpy.spin_once(robot, timeout_sec=0.001)\n        time.sleep(0.01)\n\n    robot.stop()\n\n    # Get data\n    data = robot.get_data_arrays()\n\n    return chirp_signal, data\n\ndef compute_frequency_response(input_signal, output_signal, dt=0.01):\n    """\n    Compute frequency response from chirp data.\n\n    Returns:\n        frequencies, magnitude, phase\n    """\n    # Ensure same length\n    n = min(len(input_signal), len(output_signal))\n    u = input_signal[:n]\n    y = output_signal[:n]\n\n    # Compute FFT\n    U = np.fft.fft(u)\n    Y = np.fft.fft(y)\n\n    # Frequency response H = Y / U\n    H = Y / (U + 1e-10)\n\n    # Frequencies\n    freqs = np.fft.fftfreq(n, dt)\n\n    # Keep positive frequencies\n```python\n```python\n    positive_freqs = freqs > 0\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"    freqs = freqs[positive_freqs]\n    H = H[positive_freqs]\n\n    # Magnitude and phase\n    magnitude = np.abs(H)\n    phase = np.angle(H)\n\n    return freqs, magnitude, phase\n\ndef plot_bode(freqs, magnitude, phase):\n    \"\"\"Plot Bode diagram.\"\"\"\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))\n\n    # Magnitude plot\n    ax1.semilogx(freqs, 20 * np.log10(magnitude), 'b-', linewidth=2)\n    ax1.set_ylabel('Magnitude (dB)', fontsize=12)\n    ax1.set_title('Frequency Response (Bode Plot)', fontsize=14)\n    ax1.grid(True, which='both', alpha=0.3)\n\n    # Phase plot\n    ax2.semilogx(freqs, np.rad2deg(phase), 'r-', linewidth=2)\n    ax2.set_xlabel('Frequency (Hz)', fontsize=12)\n    ax2.set_ylabel('Phase (degrees)', fontsize=12)\n    ax2.grid(True, which='both', alpha=0.3)\n\n    plt.tight_layout()\n    plt.savefig('bode_plot.png', dpi=150)\n    print(\"\\nBode plot saved as bode_plot.png\")\n\n# Run frequency response\nchirp_input, data = run_chirp_experiment(robot, amplitude=0.1, duration=20.0)\n\nif data['odom'] is not None:\n    output = data['odom']['vx']\n    freqs, mag, phase = compute_frequency_response(chirp_input, output)\n    plot_bode(freqs, mag, phase)\n"})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Expected"}),": Frequency response computed, Bode plot showing magnitude and phase vs frequency."]})}),"\n",(0,r.jsx)(n.h3,{id:"step-5-validate-parameters-in-simulation",children:"Step 5: Validate Parameters in Simulation"}),"\n",(0,r.jsx)(n.p,{children:"Update simulation with identified parameters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nvalidate_parameters.py\nValidate identified parameters in MuJoCo simulation.\n\"\"\"\n\nimport mujoco\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef create_validated_model(params):\n    \"\"\"\n    Create MuJoCo model with identified parameters.\n\n    Args:\n        params: Dictionary of identified parameters\n\n    Returns:\n        model: MuJoCo model\n    \"\"\"\n    # Load base model\n    model = mujoco.MjModel.from_xml_path(\"turtlebot_base.xml\")\n\n    # Update parameters\n    if 'mass' in params:\n        model.body_mass[1] = params['mass']  # Assuming body 1 is robot base\n\n    if 'damping' in params:\n        model.dof_damping[:] = params['damping']\n\n    if 'friction' in params:\n        model.geom_friction[0, 0] = params['friction']\n\n    return model\n\ndef compare_real_vs_sim(real_data, sim_data):\n    \"\"\"\n    Compare real robot data with simulation.\n\n    Args:\n        real_data: Data from real robot\n        sim_data: Data from simulation\n\n    Returns:\n        error_metrics: RMSE, max error\n    \"\"\"\n    # Interpolate to same time base\n    t_real = real_data['time']\n    v_real = real_data['velocity']\n\n    t_sim = sim_data['time']\n    v_sim = sim_data['velocity']\n\n    # Resample sim to real time\n    v_sim_interp = np.interp(t_real, t_sim, v_sim)\n\n    # Compute errors\n    error = v_real - v_sim_interp\n    rmse = np.sqrt(np.mean(error**2))\n    max_error = np.max(np.abs(error))\n\n    print(f\"\\nValidation Metrics:\")\n    print(f\"  RMSE: {rmse:.4f} m/s\")\n    print(f\"  Max error: {max_error:.4f} m/s\")\n    print(f\"  Mean error: {np.mean(error):.4f} m/s\")\n\n    # Plot comparison\n    plt.figure(figsize=(10, 6))\n    plt.plot(t_real, v_real, 'b-', label='Real Robot', linewidth=2)\n    plt.plot(t_real, v_sim_interp, 'r--', label='Simulation', linewidth=2)\n    plt.fill_between(t_real, v_real - rmse, v_real + rmse, alpha=0.2, label=f'\xb1RMSE ({rmse:.3f})')\n\n    plt.xlabel('Time (s)', fontsize=12)\n    plt.ylabel('Velocity (m/s)', fontsize=12)\n    plt.title('Real vs Simulation Validation', fontsize=14)\n    plt.legend(fontsize=10)\n    plt.grid(True, alpha=0.3)\n    plt.tight_layout()\n    plt.savefig('validation.png', dpi=150)\n\n    return {'rmse': rmse, 'max_error': max_error}\n\nprint(\"\\nSystem identification and validation complete!\")\nprint(\"Parameters identified and validated in simulation\")\n"})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Expected"}),": Simulation updated with identified parameters, validation error computed."]})}),"\n",(0,r.jsx)(n.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,r.jsx)(n.p,{children:"After completing this lab, you should have:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Code artifacts"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"robot_interface.py"}),": ROS2 interface for TurtleBot"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"step_response_experiment.py"}),": Step response identification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"friction_identification.py"}),": Friction parameter estimation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"frequency_response.py"}),": Bode plot analysis"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"validate_parameters.py"}),": Sim-to-real validation"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Understanding"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"System identification methods"}),"\n",(0,r.jsx)(n.li,{children:"Parameter estimation from experimental data"}),"\n",(0,r.jsx)(n.li,{children:"Model validation approaches"}),"\n",(0,r.jsx)(n.li,{children:"Sources of sim-to-real gap"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Experimental results"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Identified parameters for real robot"}),"\n",(0,r.jsx)(n.li,{children:"Validated model with <10% RMSE"}),"\n",(0,r.jsx)(n.li,{children:"Bode plots showing frequency response"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"rubric",children:"Rubric"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Criterion"}),(0,r.jsx)(n.th,{children:"Points"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Step Response"}),(0,r.jsx)(n.td,{children:"20"}),(0,r.jsx)(n.td,{children:"Correct first-order model fit"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Friction ID"}),(0,r.jsx)(n.td,{children:"20"}),(0,r.jsx)(n.td,{children:"Coulomb and viscous parameters"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Frequency Response"}),(0,r.jsx)(n.td,{children:"20"}),(0,r.jsx)(n.td,{children:"Bode plot from chirp data"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Validation"}),(0,r.jsx)(n.td,{children:"25"}),(0,r.jsx)(n.td,{children:"Sim matches real within 10%"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Analysis"}),(0,r.jsx)(n.td,{children:"15"}),(0,r.jsx)(n.td,{children:"Parameter interpretation"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Total"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"100"})}),(0,r.jsx)(n.td,{})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"common-errors",children:"Common Errors"}),"\n",(0,r.jsxs)("troubleshooting",{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Error"}),": Robot doesn't respond to commands\n",(0,r.jsx)(n.strong,{children:"Solution"}),": Check ROS2 topic names, verify robot is in correct mode."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Error"}),": Noisy velocity measurements\n",(0,r.jsx)(n.strong,{children:"Solution"}),": Low-pass filter odometry, increase averaging window."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Error"}),": Parameters don't transfer to simulation\n",(0,r.jsx)(n.strong,{children:"Solution"}),": Check units, verify parameter mapping is correct."]})]}),"\n",(0,r.jsx)(n.h2,{id:"extensions",children:"Extensions"}),"\n",(0,r.jsx)(n.p,{children:"For advanced students:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-axis identification"}),": Identify lateral and rotational dynamics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nonlinear friction"}),": Fit Stribeck friction model"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Adaptive identification"}),": Online parameter estimation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Grey-box modeling"}),": Combine physics and data-driven models"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-content",children:"Related Content"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Theory"}),": Module 10 theory.md, Section 10.2 (System ID)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Previous Lab"}),": Lab 10-01 (Domain Randomization)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Next Lab"}),": Lab 10-03 (Sim-to-Real Transfer)"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);