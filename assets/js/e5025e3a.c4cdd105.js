"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[6037],{7164(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"textbook/modules/rigid-body-dynamics/labs/lab-02-03","title":"Torque-Motion Relationship","description":"Objectives","source":"@site/docs/textbook/modules/02-rigid-body-dynamics/labs/lab-02-03.md","sourceDirName":"textbook/modules/02-rigid-body-dynamics/labs","slug":"/textbook/modules/rigid-body-dynamics/labs/lab-02-03","permalink":"/Hackathon-3/docs/textbook/modules/rigid-body-dynamics/labs/lab-02-03","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/02-rigid-body-dynamics/labs/lab-02-03.md","tags":[],"version":"current","frontMatter":{"id":"lab-02-03","module_id":"02","title":"Torque-Motion Relationship","difficulty":"intermediate","tier":"simulation","duration_minutes":75,"submission_format":"notebook","auto_gradable":true},"sidebar":"tutorialSidebar","previous":{"title":"Simulating Free Fall and Impact","permalink":"/Hackathon-3/docs/textbook/modules/rigid-body-dynamics/labs/lab-02-02"},"next":{"title":"Rigid Body Dynamics","permalink":"/Hackathon-3/docs/textbook/modules/rigid-body-dynamics/rigid-body-dynamics"}}');var s=t(4848),a=t(8453);const o={id:"lab-02-03",module_id:"02",title:"Torque-Motion Relationship",difficulty:"intermediate",tier:"simulation",duration_minutes:75,submission_format:"notebook",auto_gradable:!0},r="Lab 02-03: Torque-Motion Relationship",l={},d=[{value:"Objectives",id:"objectives",level:2},{value:"Materials",id:"materials",level:2},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Single-Axis Rotation Under Constant Torque",id:"step-1-single-axis-rotation-under-constant-torque",level:3},{value:"Step 2: Pendulum Dynamics",id:"step-2-pendulum-dynamics",level:3},{value:"Step 3: Coupled Rotation - Spinning Top",id:"step-3-coupled-rotation---spinning-top",level:3},{value:"Step 4: Rotational Inertia Tensor",id:"step-4-rotational-inertia-tensor",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"lab-02-03-torque-motion-relationship",children:"Lab 02-03: Torque-Motion Relationship"})}),"\n",(0,s.jsx)(n.h2,{id:"objectives",children:"Objectives"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understand the relationship \u03c4 = I\u03b1 for rotational motion"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Measure moment of inertia through simulation"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Analyze gyroscopic effects"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Study coupled rotational and translational dynamics"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"materials",children:"Materials"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Version"}),(0,s.jsx)(n.th,{children:"Tier"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"software"}),(0,s.jsx)(n.td,{children:"Python"}),(0,s.jsx)(n.td,{children:"3.10+"}),(0,s.jsx)(n.td,{children:"required"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"software"}),(0,s.jsx)(n.td,{children:"MuJoCo"}),(0,s.jsx)(n.td,{children:"3.0+"}),(0,s.jsx)(n.td,{children:"required"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"software"}),(0,s.jsx)(n.td,{children:"NumPy"}),(0,s.jsx)(n.td,{children:"1.24+"}),(0,s.jsx)(n.td,{children:"required"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"software"}),(0,s.jsx)(n.td,{children:"Matplotlib"}),(0,s.jsx)(n.td,{children:"3.5+"}),(0,s.jsx)(n.td,{children:"required"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"instructions",children:"Instructions"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-single-axis-rotation-under-constant-torque",children:"Step 1: Single-Axis Rotation Under Constant Torque"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import mujoco\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a rotating bar model\nbar_xml = """\n<mujoco>\n  <option gravity="0 0 0" timestep="0.001"/>\n\n  <worldbody>\n    <light diffuse="1 1 1" pos="0 0 3"/>\n\n    <body name="bar" pos="0 0 1">\n      <joint type="free"/>\n      <geom type="box" size="0.5 0.05 0.05" mass="2.0" rgba="0.8 0.3 0.2 1"/>\n    </body>\n  </worldbody>\n</mujoco>\n"""\n\nmodel = mujoco.MjModel.from_xml_string(bar_xml)\ndata = mujoco.MjData(model)\n\n# Calculate theoretical moment of inertia\n# For a rectangular bar rotating about its center (z-axis):\n# I_zz = (1/12) * m * (l_x\xb2 + l_y\xb2)\nmass = model.body_mass[1]\nlx, ly = 1.0, 0.1  # Full length and width (2 * half-size)\nI_theoretical = (1/12) * mass * (lx**2 + ly**2)\nprint(f"Theoretical I_zz: {I_theoretical:.6f} kg\u22c5m\xb2")\n\n# Apply constant torque and measure angular acceleration\nmujoco.mj_resetData(model, data)\n\ntorque_values = [0.5, 1.0, 2.0, 4.0]\nresults = {}\n\nfor tau in torque_values:\n    mujoco.mj_resetData(model, data)\n\n    times = []\n    angular_velocities = []\n\n    for i in range(1000):\n        # Apply torque about z-axis (index 5 in 6D wrench)\n        data.xfrc_applied[1] = [0, 0, 0, 0, 0, tau]\n        mujoco.mj_step(model, data)\n\n        times.append(data.time)\n        angular_velocities.append(data.qvel[5])  # z angular velocity\n\n    # Measure angular acceleration (slope of angular velocity)\n    alpha_measured = np.polyfit(times, angular_velocities, 1)[0]\n    I_measured = tau / alpha_measured\n\n    results[tau] = {\n        \'times\': times,\n        \'omega\': angular_velocities,\n        \'alpha\': alpha_measured,\n        \'I\': I_measured\n    }\n\n    print(f"\u03c4 = {tau:.1f} Nm: \u03b1 = {alpha_measured:.3f} rad/s\xb2, I = {I_measured:.6f} kg\u22c5m\xb2")\n\n# Plot angular velocity vs time for different torques\nplt.figure(figsize=(10, 6))\nfor tau, data_dict in results.items():\n    plt.plot(data_dict[\'times\'], data_dict[\'omega\'], label=f\'\u03c4 = {tau} Nm\')\n\nplt.xlabel(\'Time (s)\')\nplt.ylabel(\'Angular Velocity (rad/s)\')\nplt.title(\'Angular Velocity Under Different Torques\')\nplt.legend()\nplt.grid(True)\nplt.savefig(\'torque_response.png\', dpi=150)\nplt.show()\n\n# Average measured inertia\navg_I = np.mean([r[\'I\'] for r in results.values()])\nprint(f"\\nAverage measured I: {avg_I:.6f} kg\u22c5m\xb2")\nprint(f"Error from theoretical: {abs(avg_I - I_theoretical)/I_theoretical * 100:.2f}%")\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Verification"}),": Measured I should be close to theoretical value (~0.168 kg\u22c5m\xb2).\n",(0,s.jsx)(n.strong,{children:"Understanding"}),": \u03b1 = \u03c4/I, so doubling torque doubles angular acceleration."]})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-pendulum-dynamics",children:"Step 2: Pendulum Dynamics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Create a simple pendulum\npendulum_xml = """\n<mujoco>\n  <option gravity="0 0 -9.81" timestep="0.001"/>\n\n  <worldbody>\n    <light diffuse="1 1 1" pos="0 0 3"/>\n\n    <body name="pivot" pos="0 0 2">\n      <joint name="hinge" type="hinge" axis="0 1 0" limited="false"/>\n      <geom type="sphere" size="0.05" mass="0.1"/>\n\n      <body name="pendulum" pos="0 0 -0.5">\n        <geom type="capsule" size="0.02" fromto="0 0 0.5 0 0 -0.5" mass="1.0"/>\n      </body>\n    </body>\n  </worldbody>\n</mujoco>\n"""\n\nmodel_p = mujoco.MjModel.from_xml_string(pendulum_xml)\ndata_p = mujoco.MjData(model_p)\n\n# Set initial angle\ninitial_angle = np.radians(30)  # 30 degrees\nmujoco.mj_resetData(model_p, data_p)\ndata_p.qpos[0] = initial_angle\n\n# Simulate and record motion\ntimes = []\nangles = []\nangular_velocities = []\n\nfor _ in range(5000):  # 5 seconds\n    mujoco.mj_step(model_p, data_p)\n    times.append(data_p.time)\n    angles.append(data_p.qpos[0])\n    angular_velocities.append(data_p.qvel[0])\n\n# Theoretical period for small oscillations\n# T = 2\u03c0\u221a(L/g) for simple pendulum\nL = 1.0  # pendulum length\ng = 9.81\nT_theoretical = 2 * np.pi * np.sqrt(L / g)\n\n# Measure period from simulation\nfrom scipy.signal import find_peaks\npeaks, _ = find_peaks(angles, height=0)\n```python\n```python\nif len(peaks) > 1:\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"    periods = np.diff([times[p] for p in peaks])\n    T_measured = np.mean(periods)\nelse:\n    T_measured = 0\n\nprint(f\"Theoretical period: {T_theoretical:.4f} s\")\nprint(f\"Measured period: {T_measured:.4f} s\")\nprint(f\"Error: {abs(T_measured - T_theoretical) / T_theoretical * 100:.2f}%\")\n\n# Phase space plot\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\n\naxes[0].plot(times, np.degrees(angles))\naxes[0].set_xlabel('Time (s)')\naxes[0].set_ylabel('Angle (degrees)')\naxes[0].set_title('Pendulum Motion')\naxes[0].grid(True)\n\naxes[1].plot(np.degrees(angles), angular_velocities)\naxes[1].set_xlabel('Angle (degrees)')\naxes[1].set_ylabel('Angular Velocity (rad/s)')\naxes[1].set_title('Phase Space')\naxes[1].grid(True)\n\nplt.tight_layout()\nplt.savefig('pendulum_dynamics.png', dpi=150)\nplt.show()\n"})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Expected"}),": Period should be approximately 2.0 seconds for L=1m.\n",(0,s.jsx)(n.strong,{children:"Analysis"}),": Phase space should show elliptical trajectories for undamped motion."]})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-coupled-rotation---spinning-top",children:"Step 3: Coupled Rotation - Spinning Top"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Create a spinning top (gyroscope)\ntop_xml = """\n<mujoco>\n  <option gravity="0 0 -9.81" timestep="0.0005"/>\n\n  <worldbody>\n    <light diffuse="1 1 1" pos="0 0 3"/>\n    <geom type="plane" size="2 2 0.1"/>\n\n    <body name="top" pos="0 0 0.5">\n      <joint type="free"/>\n      <geom type="cylinder" size="0.1 0.02" mass="0.5" pos="0 0 0"/>\n      <geom type="cylinder" size="0.01 0.3" mass="0.1" pos="0 0 0.15"/>\n    </body>\n  </worldbody>\n</mujoco>\n"""\n\nmodel_t = mujoco.MjModel.from_xml_string(top_xml)\ndata_t = mujoco.MjData(model_t)\n\n# Initialize with tilt and spin\nmujoco.mj_resetData(model_t, data_t)\n\n# Tilt the top (modify quaternion for ~10 degree tilt)\ntilt_angle = np.radians(10)\ndata_t.qpos[3:7] = [np.cos(tilt_angle/2), np.sin(tilt_angle/2), 0, 0]\n\n# Give it spin about its axis\nspin_rate = 50.0  # rad/s\ndata_t.qvel[5] = spin_rate  # Spin about z-axis (before tilt)\n\n# Record motion\ntimes = []\nx_coords = []\ny_coords = []\nspin_rates = []\n\nfor i in range(10000):  # 5 seconds\n    mujoco.mj_step(model_t, data_t)\n\n```python\n```python\n    if i % 10 == 0:\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"        times.append(data_t.time)\n        x_coords.append(data_t.qpos[0])\n        y_coords.append(data_t.qpos[1])\n        spin_rates.append(np.linalg.norm(data_t.qvel[3:6]))\n\n# Plot precession (top view of center of mass trajectory)\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\n\naxes[0].plot(x_coords, y_coords)\naxes[0].set_xlabel('X Position (m)')\naxes[0].set_ylabel('Y Position (m)')\naxes[0].set_title('Top View - Precession Pattern')\naxes[0].axis('equal')\naxes[0].grid(True)\n\naxes[1].plot(times, spin_rates)\naxes[1].set_xlabel('Time (s)')\naxes[1].set_ylabel('Spin Rate (rad/s)')\naxes[1].set_title('Spin Rate Over Time')\naxes[1].grid(True)\n\nplt.tight_layout()\nplt.savefig('spinning_top.png', dpi=150)\nplt.show()\n\nprint(f\"Initial spin rate: {spin_rate:.1f} rad/s\")\nprint(f\"Final spin rate: {spin_rates[-1]:.1f} rad/s\")\n"})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Observation"}),": The top should exhibit precession - circular motion of its axis.\n",(0,s.jsx)(n.strong,{children:"Analysis"}),": Precession rate depends on spin rate, mass distribution, and tilt."]})}),"\n",(0,s.jsx)(n.h3,{id:"step-4-rotational-inertia-tensor",children:"Step 4: Rotational Inertia Tensor"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Compare rotation about different axes\nshapes_xml = """\n<mujoco>\n  <option gravity="0 0 0" timestep="0.001"/>\n\n  <worldbody>\n    <light diffuse="1 1 1" pos="0 0 5"/>\n\n    <body name="long_bar" pos="-2 0 1">\n      <joint type="free"/>\n      <geom type="box" size="0.5 0.05 0.05" mass="1.0" rgba="1 0 0 1"/>\n    </body>\n\n    <body name="disc" pos="0 0 1">\n      <joint type="free"/>\n      <geom type="cylinder" size="0.2 0.02" mass="1.0" rgba="0 1 0 1"/>\n    </body>\n\n    <body name="cube" pos="2 0 1">\n      <joint type="free"/>\n      <geom type="box" size="0.15 0.15 0.15" mass="1.0" rgba="0 0 1 1"/>\n    </body>\n  </worldbody>\n</mujoco>\n"""\n\nmodel_s = mujoco.MjModel.from_xml_string(shapes_xml)\ndata_s = mujoco.MjData(model_s)\n\ndef measure_inertia_by_axis(body_idx, axis, torque_mag=1.0):\n    """Measure moment of inertia about specified axis."""\n    mujoco.mj_resetData(model_s, data_s)\n\n    # Construct torque vector\n    torque = [0, 0, 0, 0, 0, 0]\n    torque[3 + axis] = torque_mag  # axis: 0=x, 1=y, 2=z\n\n    times = []\n    angular_vels = []\n\n    for i in range(500):\n        data_s.xfrc_applied[body_idx] = torque\n        mujoco.mj_step(model_s, data_s)\n\n        times.append(data_s.time)\n        # Get angular velocity for this body\n        qvel_start = (body_idx - 1) * 6 + 3  # Skip linear velocities\n        angular_vels.append(data_s.qvel[qvel_start + axis])\n\n    alpha = np.polyfit(times, angular_vels, 1)[0]\n    return torque_mag / alpha\n\n# Measure inertia for each shape about each axis\nshapes = [\'Long Bar\', \'Disc\', \'Cube\']\nbody_indices = [1, 2, 3]\naxes = [\'X\', \'Y\', \'Z\']\n\nprint("Measured Moments of Inertia (kg\u22c5m\xb2):")\nprint("-" * 50)\nprint(f"{\'Shape\':<12} {\'I_x\':>10} {\'I_y\':>10} {\'I_z\':>10}")\nprint("-" * 50)\n\nfor name, body_idx in zip(shapes, body_indices):\n    inertias = [measure_inertia_by_axis(body_idx, ax) for ax in range(3)]\n    print(f"{name:<12} {inertias[0]:>10.6f} {inertias[1]:>10.6f} {inertias[2]:>10.6f}")\n'})}),"\n",(0,s.jsxs)("checkpoint",{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Analysis"}),":"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Long bar: I_x \u2248 I_y << I_z (easy to spin about long axis)"}),"\n",(0,s.jsx)(n.li,{children:"Disc: I_x \u2248 I_y > I_z (like a frisbee)"}),"\n",(0,s.jsx)(n.li,{children:"Cube: I_x \u2248 I_y \u2248 I_z (symmetric)"}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Verified \u03c4 = I\u03b1 relationship"}),"\n",(0,s.jsx)(n.li,{children:"Measured pendulum period matching theory"}),"\n",(0,s.jsx)(n.li,{children:"Observed gyroscopic precession"}),"\n",(0,s.jsx)(n.li,{children:"Compared inertia tensors for different shapes"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"rubric",children:"Rubric"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Criterion"}),(0,s.jsx)(n.th,{children:"Points"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Torque-Acceleration"}),(0,s.jsx)(n.td,{children:"25"}),(0,s.jsx)(n.td,{children:"Correct measurement and analysis"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Pendulum Dynamics"}),(0,s.jsx)(n.td,{children:"25"}),(0,s.jsx)(n.td,{children:"Period measurement and phase space"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Gyroscopic Effects"}),(0,s.jsx)(n.td,{children:"25"}),(0,s.jsx)(n.td,{children:"Precession observation and analysis"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Inertia Tensor"}),(0,s.jsx)(n.td,{children:"15"}),(0,s.jsx)(n.td,{children:"Comparison across shapes and axes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Documentation"}),(0,s.jsx)(n.td,{children:"10"}),(0,s.jsx)(n.td,{children:"Clear explanations"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Total: 100 points"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>r});var i=t(6540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);