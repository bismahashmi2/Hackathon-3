"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[275],{3551(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"textbook/modules/manipulation/labs/lab-07-01","title":"Basic Grasping in Simulation","description":"Objectives","source":"@site/docs/textbook/modules/07-manipulation/labs/lab-07-01.md","sourceDirName":"textbook/modules/07-manipulation/labs","slug":"/textbook/modules/manipulation/labs/lab-07-01","permalink":"/Hackathon-3/docs/textbook/modules/manipulation/labs/lab-07-01","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/07-manipulation/labs/lab-07-01.md","tags":[],"version":"current","frontMatter":{"id":"lab-07-01","module_id":"07","title":"Basic Grasping in Simulation","difficulty":"guided","tier":"simulation","duration_minutes":75},"sidebar":"tutorialSidebar","previous":{"title":"Ethics in Robotic Manipulation","permalink":"/Hackathon-3/docs/textbook/modules/manipulation/ethics"},"next":{"title":"Force Control and Compliance","permalink":"/Hackathon-3/docs/textbook/modules/manipulation/labs/lab-07-02"}}');var i=t(4848),s=t(8453);const o={id:"lab-07-01",module_id:"07",title:"Basic Grasping in Simulation",difficulty:"guided",tier:"simulation",duration_minutes:75},a="Lab 07-01: Basic Grasping in Simulation",c={},l=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"Grasp Planning Pipeline",id:"grasp-planning-pipeline",level:3},{value:"Parallel Jaw Grasping",id:"parallel-jaw-grasping",level:3},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Set Up the Simulation Environment",id:"step-1-set-up-the-simulation-environment",level:3},{value:"Step 2: Define Grasp Poses",id:"step-2-define-grasp-poses",level:3},{value:"Step 3: Implement Gripper Control",id:"step-3-implement-gripper-control",level:3},{value:"Step 4: Execute Pick Sequence",id:"step-4-execute-pick-sequence",level:3},{value:"Step 5: Grasp Quality Evaluation",id:"step-5-grasp-quality-evaluation",level:3},{value:"Step 6: Multiple Grasp Attempts",id:"step-6-multiple-grasp-attempts",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2},{value:"Common Errors",id:"common-errors",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Related Content",id:"related-content",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"lab-07-01-basic-grasping-in-simulation",children:"Lab 07-01: Basic Grasping in Simulation"})}),"\n",(0,i.jsx)(n.h2,{id:"objectives",children:"Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this lab, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement a simple grasp planner for known object poses"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Execute pre-grasp approach and grasp motions"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use MuJoCo contact simulation for grip verification"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Evaluate grasp success through object lifting"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Completed Module 06 (Motion Planning)"}),"\n",(0,i.jsx)(n.li,{children:"Understanding of rigid body transformations"}),"\n",(0,i.jsx)(n.li,{children:"Familiarity with MuJoCo actuators and contacts"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"materials",children:"Materials"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"Tier"}),(0,i.jsx)(n.th,{children:"Notes"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"software"}),(0,i.jsx)(n.td,{children:"MuJoCo 3.0+"}),(0,i.jsx)(n.td,{children:"required"}),(0,i.jsx)(n.td,{children:"Physics simulation with contacts"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"software"}),(0,i.jsx)(n.td,{children:"Python 3.10+"}),(0,i.jsx)(n.td,{children:"required"}),(0,i.jsx)(n.td,{children:"Programming environment"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"software"}),(0,i.jsx)(n.td,{children:"NumPy"}),(0,i.jsx)(n.td,{children:"required"}),(0,i.jsx)(n.td,{children:"Linear algebra"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"simulation"}),(0,i.jsx)(n.td,{children:"gripper-table.xml"}),(0,i.jsx)(n.td,{children:"required"}),(0,i.jsx)(n.td,{children:"Parallel jaw gripper with table"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,i.jsx)(n.h3,{id:"grasp-planning-pipeline",children:"Grasp Planning Pipeline"}),"\n",(0,i.jsx)(n.p,{children:"Basic grasping involves:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Object localization"}),": Know where the object is"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Grasp synthesis"}),": Generate candidate grasp poses"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Approach planning"}),": Move gripper to pre-grasp position"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Grasp execution"}),": Close gripper on object"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lift verification"}),": Confirm successful grasp"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"parallel-jaw-grasping",children:"Parallel Jaw Grasping"}),"\n",(0,i.jsx)(n.p,{children:"For parallel jaw grippers, a grasp is defined by:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Approach direction (z-axis of gripper frame)"}),"\n",(0,i.jsx)(n.li,{children:"Grasp center point on object"}),"\n",(0,i.jsx)(n.li,{children:"Gripper opening width"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"instructions",children:"Instructions"}),"\n",(0,i.jsx)(n.h3,{id:"step-1-set-up-the-simulation-environment",children:"Step 1: Set Up the Simulation Environment"}),"\n",(0,i.jsx)(n.p,{children:"Load the gripper and table scene:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import mujoco\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load model with gripper and objects\nmodel = mujoco.MjModel.from_xml_path("textbook/assets/robot-models/mujoco/gripper-table.xml")\ndata = mujoco.MjData(model)\n\n# Explore the model\nprint("Bodies:", [mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_BODY, i)\n                  for i in range(model.nbody)])\nprint("Actuators:", [mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_ACTUATOR, i)\n                     for i in range(model.nu)])\n\n# Get gripper and object IDs\ngripper_body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, "gripper_base")\nobject_body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, "target_object")\n\n# Reset and step to initialize\nmujoco.mj_resetData(model, data)\nmujoco.mj_forward(model, data)\n\nprint(f"Gripper position: {data.xpos[gripper_body_id]}")\nprint(f"Object position: {data.xpos[object_body_id]}")\n'})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": Model loads with gripper, object, and table bodies identified."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-2-define-grasp-poses",children:"Step 2: Define Grasp Poses"}),"\n",(0,i.jsx)(n.p,{children:"Create a simple grasp pose generator:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def generate_top_grasp(object_pos, object_size, gripper_height=0.1):\n    """\n    Generate a top-down grasp pose for a box object.\n\n    Args:\n        object_pos: [x, y, z] object center position\n        object_size: [sx, sy, sz] object half-sizes\n        gripper_height: Height above object for pre-grasp\n\n    Returns:\n        pre_grasp_pose: [x, y, z, qw, qx, qy, qz] pre-grasp position/orientation\n        grasp_pose: Final grasp position/orientation\n        gripper_width: Required gripper opening\n    """\n    # Grasp from top, gripper pointing down\n    # Quaternion for gripper pointing -Z: rotate 180\xb0 around X\n    quat_down = [0, 1, 0, 0]  # [qw, qx, qy, qz]\n\n    # Pre-grasp: above the object\n    pre_grasp_pos = np.array([\n        object_pos[0],\n        object_pos[1],\n        object_pos[2] + object_size[2] + gripper_height\n    ])\n\n    # Grasp position: fingers at object center height\n    grasp_pos = np.array([\n        object_pos[0],\n        object_pos[1],\n        object_pos[2] + object_size[2] + 0.02  # Small offset above\n    ])\n\n    # Gripper width: slightly wider than object\n    gripper_width = 2 * object_size[0] + 0.01  # Grasp along X dimension\n\n    pre_grasp_pose = np.concatenate([pre_grasp_pos, quat_down])\n    grasp_pose = np.concatenate([grasp_pos, quat_down])\n\n    return pre_grasp_pose, grasp_pose, gripper_width\n\n# Get object properties\nobject_pos = data.xpos[object_body_id].copy()\nobject_geom_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_GEOM, "target_object_geom")\nobject_size = model.geom_size[object_geom_id].copy()\n\nprint(f"Object position: {object_pos}")\nprint(f"Object size (half-extents): {object_size}")\n\n# Generate grasp poses\npre_grasp, grasp, width = generate_top_grasp(object_pos, object_size)\nprint(f"\\nPre-grasp pose: {pre_grasp[:3]}")\nprint(f"Grasp pose: {grasp[:3]}")\nprint(f"Required gripper width: {width:.4f} m")\n'})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": Grasp poses generated above the object with appropriate gripper width."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-3-implement-gripper-control",children:"Step 3: Implement Gripper Control"}),"\n",(0,i.jsx)(n.p,{children:"Create functions to control gripper position and fingers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class GripperController:\n    """Controller for a parallel jaw gripper on a Cartesian arm."""\n\n    def __init__(self, model, data):\n        self.model = model\n        self.data = data\n\n        # Find actuator indices\n        self.arm_actuator_ids = []\n        self.finger_actuator_ids = []\n\n        for i in range(model.nu):\n            name = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_ACTUATOR, i)\n            if \'finger\' in name.lower() or \'grip\' in name.lower():\n                self.finger_actuator_ids.append(i)\n            else:\n                self.arm_actuator_ids.append(i)\n\n        print(f"Arm actuators: {len(self.arm_actuator_ids)}")\n        print(f"Finger actuators: {len(self.finger_actuator_ids)}")\n\n        # Control gains\n        self.kp_pos = 500\n        self.kd_pos = 50\n        self.kp_grip = 100\n\n    def set_gripper_width(self, target_width, force_limit=20):\n        """\n        Set gripper opening width.\n\n        Args:\n            target_width: Desired finger separation (meters)\n            force_limit: Maximum grip force (N)\n        """\n        # Assuming finger actuators control position directly\n        finger_pos = target_width / 2  # Each finger moves half the distance\n\n        for act_id in self.finger_actuator_ids:\n            self.data.ctrl[act_id] = finger_pos\n\n    def close_gripper(self, force=20):\n        """Close gripper with specified force."""\n        for act_id in self.finger_actuator_ids:\n            self.data.ctrl[act_id] = -force  # Negative for closing\n\n    def open_gripper(self, width=0.1):\n        """Open gripper to specified width."""\n        finger_pos = width / 2\n        for act_id in self.finger_actuator_ids:\n            self.data.ctrl[act_id] = finger_pos\n\n    def move_to_pose(self, target_pos, n_steps=500):\n        """\n        Move gripper to target position using simple P control.\n\n        This is simplified - assumes Cartesian position control is available.\n        In practice, would use IK + joint control.\n        """\n        gripper_body_id = mujoco.mj_name2id(\n            self.model, mujoco.mjtObj.mjOBJ_BODY, "gripper_base"\n        )\n\n        for _ in range(n_steps):\n            # Get current position\n            current_pos = self.data.xpos[gripper_body_id].copy()\n\n            # Position error\n            error = target_pos[:3] - current_pos\n\n            # Simple proportional control on arm actuators\n            # This is highly simplified - real systems use IK\n            for i, act_id in enumerate(self.arm_actuator_ids[:3]):\n                self.data.ctrl[act_id] = self.kp_pos * error[i]\n\n            mujoco.mj_step(self.model, self.data)\n\n            # Check convergence\n```python\n```python\n            if np.linalg.norm(error) < 0.005:\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                return True\n\n        return False\n\n# Create controller\ncontroller = GripperController(model, data)\n"})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": GripperController created with arm and finger actuators identified."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-4-execute-pick-sequence",children:"Step 4: Execute Pick Sequence"}),"\n",(0,i.jsx)(n.p,{children:"Implement the full pick operation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def execute_pick(controller, pre_grasp, grasp, lift_height=0.15):\n    """\n    Execute a pick operation.\n\n    Args:\n        controller: GripperController instance\n        pre_grasp: Pre-grasp pose [x, y, z, qw, qx, qy, qz]\n        grasp: Grasp pose\n        lift_height: Height to lift after grasping\n\n    Returns:\n        success: True if object was lifted\n    """\n    print("Step 1: Open gripper...")\n    controller.open_gripper(width=0.1)\n    for _ in range(100):\n        mujoco.mj_step(controller.model, controller.data)\n\n    print("Step 2: Move to pre-grasp...")\n    success = controller.move_to_pose(pre_grasp, n_steps=500)\n    if not success:\n        print("  Failed to reach pre-grasp")\n        return False\n\n    print("Step 3: Move to grasp pose...")\n    success = controller.move_to_pose(grasp, n_steps=300)\n    if not success:\n        print("  Failed to reach grasp pose")\n        return False\n\n    print("Step 4: Close gripper...")\n    controller.close_gripper(force=30)\n    for _ in range(200):\n        mujoco.mj_step(controller.model, controller.data)\n\n    print("Step 5: Lift object...")\n    lift_pose = grasp.copy()\n    lift_pose[2] += lift_height\n    success = controller.move_to_pose(lift_pose, n_steps=500)\n\n    # Check if object is still grasped (object height increased)\n    object_body_id = mujoco.mj_name2id(\n        controller.model, mujoco.mjtObj.mjOBJ_BODY, "target_object"\n    )\n    object_z = controller.data.xpos[object_body_id][2]\n    initial_z = grasp[2] - 0.05  # Approximate table height\n\n```python\n```python\n    lifted = object_z > initial_z + 0.05\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'\n    if lifted:\n        print(f"  Object lifted to z={object_z:.3f}m")\n    else:\n        print(f"  Object dropped (z={object_z:.3f}m)")\n\n    return lifted\n\n# Reset simulation\nmujoco.mj_resetData(model, data)\nmujoco.mj_forward(model, data)\n\n# Regenerate grasp for current object pose\nobject_pos = data.xpos[object_body_id].copy()\npre_grasp, grasp, width = generate_top_grasp(object_pos, object_size)\n\n# Execute pick\nsuccess = execute_pick(controller, pre_grasp, grasp)\nprint(f"\\nPick operation {\'succeeded\' if success else \'failed\'}")\n'})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": Pick sequence executes, object should be lifted if grasp is successful."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-5-grasp-quality-evaluation",children:"Step 5: Grasp Quality Evaluation"}),"\n",(0,i.jsx)(n.p,{children:"Implement grasp quality metrics:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def evaluate_grasp_quality(model, data, object_body_id):\n    """\n    Evaluate the quality of current grasp.\n\n    Returns:\n        Dictionary of grasp quality metrics\n    """\n    metrics = {}\n\n    # Count contact points with object\n    n_contacts = 0\n    total_force = 0\n    contact_points = []\n\n    for i in range(data.ncon):\n        contact = data.contact[i]\n        geom1 = contact.geom1\n        geom2 = contact.geom2\n\n        # Check if one of the geoms is the object\n        body1 = model.geom_bodyid[geom1]\n        body2 = model.geom_bodyid[geom2]\n\n```python\n```python\n        if body1 == object_body_id or body2 == object_body_id:\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"            n_contacts += 1\n            contact_points.append(contact.pos.copy())\n\n            # Get contact force\n            force = np.zeros(6)\n            mujoco.mj_contactForce(model, data, i, force)\n            total_force += np.linalg.norm(force[:3])\n\n    metrics['n_contacts'] = n_contacts\n    metrics['total_force'] = total_force\n    metrics['contact_points'] = contact_points\n\n    # Grasp stability: check if contacts span the object\n```python\n```python\n    if len(contact_points) >= 2:\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"        points = np.array(contact_points)\n        span = np.max(points, axis=0) - np.min(points, axis=0)\n        metrics['contact_span'] = np.linalg.norm(span)\n    else:\n        metrics['contact_span'] = 0\n\n    # Simple quality score\n```python\n```python\n    if n_contacts >= 2 and total_force > 5:\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"        metrics['quality_score'] = min(1.0, total_force / 50) * min(1.0, n_contacts / 4)\n    else:\n        metrics['quality_score'] = 0\n\n    return metrics\n\n# Evaluate current grasp\nmetrics = evaluate_grasp_quality(model, data, object_body_id)\nprint(\"\\nGrasp Quality Metrics:\")\nprint(f\"  Contact points: {metrics['n_contacts']}\")\nprint(f\"  Total force: {metrics['total_force']:.2f} N\")\nprint(f\"  Contact span: {metrics['contact_span']:.4f} m\")\nprint(f\"  Quality score: {metrics['quality_score']:.2f}\")\n"})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": Grasp metrics computed showing contact information and quality score."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-6-multiple-grasp-attempts",children:"Step 6: Multiple Grasp Attempts"}),"\n",(0,i.jsx)(n.p,{children:"Test grasp robustness with different approaches:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def generate_side_grasp(object_pos, object_size, approach_axis=\'x\'):\n    """Generate a side grasp approaching from specified axis."""\n```python\n```python\n    if approach_axis == \'x\':\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"        # Approach from +X direction\n        quat = [0.707, 0, 0.707, 0]  # Rotate 90\xb0 around Y\n        offset = np.array([object_size[0] + 0.1, 0, 0])\n        grasp_dim = object_size[1]  # Grasp along Y\n    elif approach_axis == 'y':\n        # Approach from +Y direction\n        quat = [0.707, 0.707, 0, 0]  # Rotate 90\xb0 around X\n        offset = np.array([0, object_size[1] + 0.1, 0])\n        grasp_dim = object_size[0]  # Grasp along X\n    else:\n        return generate_top_grasp(object_pos, object_size)\n\n    pre_grasp_pos = object_pos + offset\n    grasp_pos = object_pos + offset * 0.3  # Move closer\n\n    gripper_width = 2 * grasp_dim + 0.01\n\n    pre_grasp_pose = np.concatenate([pre_grasp_pos, quat])\n    grasp_pose = np.concatenate([grasp_pos, quat])\n\n    return pre_grasp_pose, grasp_pose, gripper_width\n\ndef test_multiple_grasps(model, data, object_body_id, n_trials=3):\n    \"\"\"Test multiple grasp approaches.\"\"\"\n    results = []\n\n    approaches = ['top', 'x', 'y']\n\n    for approach in approaches:\n        # Reset\n        mujoco.mj_resetData(model, data)\n        mujoco.mj_forward(model, data)\n\n        controller = GripperController(model, data)\n        object_pos = data.xpos[object_body_id].copy()\n\n        # Get object size\n        object_geom_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_GEOM, \"target_object_geom\")\n        object_size = model.geom_size[object_geom_id].copy()\n\n        # Generate grasp\n```python\n```python\n        if approach == 'top':\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"            pre_grasp, grasp, width = generate_top_grasp(object_pos, object_size)\n        else:\n            pre_grasp, grasp, width = generate_side_grasp(object_pos, object_size, approach)\n\n        print(f\"\\nTesting {approach} grasp...\")\n        success = execute_pick(controller, pre_grasp, grasp)\n        metrics = evaluate_grasp_quality(model, data, object_body_id)\n\n        results.append({\n            'approach': approach,\n            'success': success,\n            'quality': metrics['quality_score']\n        })\n\n    return results\n\n# This would run multiple tests - simplified for demonstration\nprint(\"\\nGrasp approach testing complete\")\n"})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": Framework for testing multiple grasp approaches defined."]})}),"\n",(0,i.jsx)(n.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"After completing this lab, you should have:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Code artifacts"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"grasp_planner.py"}),": Grasp pose generation functions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"gripper_controller.py"}),": Gripper motion and grip control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"grasp_evaluation.py"}),": Quality metrics computation"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Visual outputs"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Console output showing pick sequence progress"}),"\n",(0,i.jsx)(n.li,{children:"Grasp quality metrics"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Understanding"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Basic grasp planning pipeline"}),"\n",(0,i.jsx)(n.li,{children:"Contact-based grasp verification"}),"\n",(0,i.jsx)(n.li,{children:"Factors affecting grasp success"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"rubric",children:"Rubric"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Criterion"}),(0,i.jsx)(n.th,{children:"Points"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Grasp Pose Generation"}),(0,i.jsx)(n.td,{children:"20"}),(0,i.jsx)(n.td,{children:"Correct top-down grasp poses"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Gripper Control"}),(0,i.jsx)(n.td,{children:"25"}),(0,i.jsx)(n.td,{children:"Working position and grip control"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Pick Execution"}),(0,i.jsx)(n.td,{children:"25"}),(0,i.jsx)(n.td,{children:"Complete pick sequence that lifts object"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Quality Evaluation"}),(0,i.jsx)(n.td,{children:"20"}),(0,i.jsx)(n.td,{children:"Contact-based metrics computation"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Code Quality"}),(0,i.jsx)(n.td,{children:"10"}),(0,i.jsx)(n.td,{children:"Clean, documented, modular code"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Total"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"100"})}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"common-errors",children:"Common Errors"}),"\n",(0,i.jsxs)("troubleshooting",{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Error"}),": Object slips during lift\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Increase grip force, check object friction properties in XML."]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Error"}),": Gripper collides with table\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Adjust pre-grasp height, check IK solution validity."]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Error"}),": No contacts detected\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Verify geom collision groups, check contact margin settings."]})]}),"\n",(0,i.jsx)(n.h2,{id:"extensions",children:"Extensions"}),"\n",(0,i.jsx)(n.p,{children:"For advanced students:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Grasp Synthesis"}),": Generate multiple candidate grasps and rank them"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unknown Objects"}),": Add perception to estimate object pose"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Grasp Stability"}),": Implement form/force closure analysis"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reactive Grasping"}),": Adjust grasp based on contact feedback"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-content",children:"Related Content"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Theory"}),": Module 07 theory.md, Section 7.1 (Grasp Mechanics)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Next Lab"}),": Lab 07-02 (Force Control)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Application"}),": See Amazon Digit case study for warehouse picking"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);