"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[9909],{7969(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"textbook/modules/kinematics-fundamentals/labs/lab-03-01","title":"Forward Kinematics of a 2-DOF Arm","description":"Objectives","source":"@site/docs/textbook/modules/03-kinematics-fundamentals/labs/lab-03-01.md","sourceDirName":"textbook/modules/03-kinematics-fundamentals/labs","slug":"/textbook/modules/kinematics-fundamentals/labs/lab-03-01","permalink":"/Hackathon-3/docs/textbook/modules/kinematics-fundamentals/labs/lab-03-01","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/03-kinematics-fundamentals/labs/lab-03-01.md","tags":[],"version":"current","frontMatter":{"id":"lab-03-01","module_id":"03","title":"Forward Kinematics of a 2-DOF Arm","difficulty":"guided","tier":"simulation","duration_minutes":60,"submission_format":"notebook","auto_gradable":true},"sidebar":"tutorialSidebar","previous":{"title":"Ethics: Workspace Safety and Collision Avoidance","permalink":"/Hackathon-3/docs/textbook/modules/kinematics-fundamentals/ethics"},"next":{"title":"Inverse Kinematics Solver","permalink":"/Hackathon-3/docs/textbook/modules/kinematics-fundamentals/labs/lab-03-02"}}');var a=t(4848),s=t(8453);const o={id:"lab-03-01",module_id:"03",title:"Forward Kinematics of a 2-DOF Arm",difficulty:"guided",tier:"simulation",duration_minutes:60,submission_format:"notebook",auto_gradable:!0},r="Lab 03-01: Forward Kinematics of a 2-DOF Arm",l={},d=[{value:"Objectives",id:"objectives",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Define the 2-DOF Planar Arm",id:"step-1-define-the-2-dof-planar-arm",level:3},{value:"Step 2: Visualize the Arm Configuration",id:"step-2-visualize-the-arm-configuration",level:3},{value:"Step 3: Compute the Workspace",id:"step-3-compute-the-workspace",level:3},{value:"Step 4: Implement DH Convention",id:"step-4-implement-dh-convention",level:3},{value:"Step 5: Verify with MuJoCo Simulation",id:"step-5-verify-with-mujoco-simulation",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"lab-03-01-forward-kinematics-of-a-2-dof-arm",children:"Lab 03-01: Forward Kinematics of a 2-DOF Arm"})}),"\n",(0,a.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,a.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Implement forward kinematics using DH parameters"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Visualize the robot workspace"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Verify FK calculations against simulation"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Understand the relationship between joint angles and end-effector position"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"materials",children:"Materials"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Type"}),(0,a.jsx)(e.th,{children:"Name"}),(0,a.jsx)(e.th,{children:"Version"}),(0,a.jsx)(e.th,{children:"Tier"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"software"}),(0,a.jsx)(e.td,{children:"Python"}),(0,a.jsx)(e.td,{children:"3.10+"}),(0,a.jsx)(e.td,{children:"required"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"software"}),(0,a.jsx)(e.td,{children:"MuJoCo"}),(0,a.jsx)(e.td,{children:"3.0+"}),(0,a.jsx)(e.td,{children:"required"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"software"}),(0,a.jsx)(e.td,{children:"NumPy"}),(0,a.jsx)(e.td,{children:"1.24+"}),(0,a.jsx)(e.td,{children:"required"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"software"}),(0,a.jsx)(e.td,{children:"Matplotlib"}),(0,a.jsx)(e.td,{children:"3.5+"}),(0,a.jsx)(e.td,{children:"required"})]})]})]}),"\n",(0,a.jsx)(e.h2,{id:"background",children:"Background"}),"\n",(0,a.jsx)(e.p,{children:"Forward kinematics (FK) computes the end-effector position and orientation given joint angles. For a serial manipulator, this involves multiplying transformation matrices along the kinematic chain."}),"\n",(0,a.jsx)(e.h2,{id:"instructions",children:"Instructions"}),"\n",(0,a.jsx)(e.h3,{id:"step-1-define-the-2-dof-planar-arm",children:"Step 1: Define the 2-DOF Planar Arm"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nimport matplotlib.pyplot as plt\n\n# Link lengths\nL1 = 0.5  # First link length (m)\nL2 = 0.4  # Second link length (m)\n\ndef forward_kinematics_2dof(theta1, theta2, l1=L1, l2=L2):\n    """\n    Compute end-effector position for a 2-DOF planar arm.\n\n    Args:\n        theta1: First joint angle (radians)\n        theta2: Second joint angle (radians)\n        l1, l2: Link lengths\n\n    Returns:\n        (x, y): End-effector position\n        (x1, y1): First joint position (elbow)\n    """\n    # First joint (shoulder) is at origin\n    x0, y0 = 0, 0\n\n    # Elbow position\n    x1 = l1 * np.cos(theta1)\n    y1 = l1 * np.sin(theta1)\n\n    # End-effector position\n    x2 = x1 + l2 * np.cos(theta1 + theta2)\n    y2 = y1 + l2 * np.sin(theta1 + theta2)\n\n    return (x2, y2), (x1, y1)\n\n# Test with specific angles\ntheta1 = np.radians(45)  # 45 degrees\ntheta2 = np.radians(30)  # 30 degrees\n\nend_pos, elbow_pos = forward_kinematics_2dof(theta1, theta2)\nprint(f"Joint angles: \u03b81={np.degrees(theta1):.1f}\xb0, \u03b82={np.degrees(theta2):.1f}\xb0")\nprint(f"Elbow position: ({elbow_pos[0]:.3f}, {elbow_pos[1]:.3f})")\nprint(f"End-effector position: ({end_pos[0]:.3f}, {end_pos[1]:.3f})")\n'})}),"\n",(0,a.jsxs)("checkpoint",{children:[(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Verification"}),": For \u03b81=45\xb0, \u03b82=30\xb0:"]}),(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Elbow should be at approximately (0.354, 0.354)"}),"\n",(0,a.jsx)(e.li,{children:"End-effector should be at approximately (0.554, 0.700)"}),"\n"]})]}),"\n",(0,a.jsx)(e.h3,{id:"step-2-visualize-the-arm-configuration",children:"Step 2: Visualize the Arm Configuration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"def plot_arm(theta1, theta2, l1=L1, l2=L2, ax=None):\n    \"\"\"Plot the 2-DOF arm configuration.\"\"\"\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(8, 8))\n\n    end_pos, elbow_pos = forward_kinematics_2dof(theta1, theta2, l1, l2)\n\n    # Plot links\n    ax.plot([0, elbow_pos[0]], [0, elbow_pos[1]], 'b-', linewidth=3, label='Link 1')\n    ax.plot([elbow_pos[0], end_pos[0]], [elbow_pos[1], end_pos[1]], 'r-', linewidth=3, label='Link 2')\n\n    # Plot joints\n    ax.plot(0, 0, 'ko', markersize=10)  # Base\n    ax.plot(elbow_pos[0], elbow_pos[1], 'ko', markersize=8)  # Elbow\n    ax.plot(end_pos[0], end_pos[1], 'g^', markersize=12)  # End-effector\n\n    # Formatting\n    ax.set_xlim(-1, 1)\n    ax.set_ylim(-1, 1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.axhline(y=0, color='k', linewidth=0.5)\n    ax.axvline(x=0, color='k', linewidth=0.5)\n\n    return ax\n\n# Plot multiple configurations\nfig, axes = plt.subplots(2, 2, figsize=(12, 12))\n\nconfigs = [\n    (0, 0, \"Stretched out\"),\n    (np.pi/4, np.pi/4, \"Both 45\xb0\"),\n    (np.pi/2, -np.pi/2, \"Folded back\"),\n    (np.pi/3, np.pi/6, \"Reaching up\")\n]\n\nfor ax, (t1, t2, title) in zip(axes.flat, configs):\n    plot_arm(t1, t2, ax=ax)\n    ax.set_title(f\"{title}\\n\u03b81={np.degrees(t1):.0f}\xb0, \u03b82={np.degrees(t2):.0f}\xb0\")\n\nplt.tight_layout()\nplt.savefig('arm_configurations.png', dpi=150)\nplt.show()\n"})}),"\n",(0,a.jsx)("checkpoint",{children:(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Expected"}),": Four subplots showing different arm configurations."]})}),"\n",(0,a.jsx)(e.h3,{id:"step-3-compute-the-workspace",children:"Step 3: Compute the Workspace"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"def compute_workspace(l1=L1, l2=L2, resolution=100):\n    \"\"\"Compute reachable workspace by sweeping joint angles.\"\"\"\n    theta1_range = np.linspace(-np.pi, np.pi, resolution)\n    theta2_range = np.linspace(-np.pi, np.pi, resolution)\n\n    workspace_points = []\n\n    for t1 in theta1_range:\n        for t2 in theta2_range:\n            pos, _ = forward_kinematics_2dof(t1, t2, l1, l2)\n            workspace_points.append(pos)\n\n    return np.array(workspace_points)\n\n# Compute and plot workspace\nworkspace = compute_workspace()\n\nplt.figure(figsize=(10, 10))\nplt.scatter(workspace[:, 0], workspace[:, 1], s=1, alpha=0.3, c='blue')\n\n# Draw workspace boundaries\ntheta = np.linspace(0, 2*np.pi, 100)\nouter_circle = (L1 + L2) * np.array([np.cos(theta), np.sin(theta)])\ninner_circle = abs(L1 - L2) * np.array([np.cos(theta), np.sin(theta)])\n\nplt.plot(outer_circle[0], outer_circle[1], 'r-', linewidth=2, label=f'Outer: r={L1+L2}')\nplt.plot(inner_circle[0], inner_circle[1], 'g-', linewidth=2, label=f'Inner: r={abs(L1-L2)}')\n\nplt.xlabel('X (m)')\nplt.ylabel('Y (m)')\nplt.title('2-DOF Arm Workspace')\nplt.legend()\nplt.axis('equal')\nplt.grid(True, alpha=0.3)\nplt.savefig('workspace.png', dpi=150)\nplt.show()\n\nprint(f\"Workspace boundaries:\")\nprint(f\"  Maximum reach: {L1 + L2:.2f} m\")\nprint(f\"  Minimum reach: {abs(L1 - L2):.2f} m\")\n"})}),"\n",(0,a.jsxs)("checkpoint",{children:[(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Analysis"}),": The workspace should be an annular region (donut shape) with:"]}),(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Outer radius = L1 + L2 = 0.9 m"}),"\n",(0,a.jsx)(e.li,{children:"Inner radius = |L1 - L2| = 0.1 m"}),"\n"]})]}),"\n",(0,a.jsx)(e.h3,{id:"step-4-implement-dh-convention",children:"Step 4: Implement DH Convention"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def dh_matrix(theta, d, a, alpha):\n    """\n    Compute the Denavit-Hartenberg transformation matrix.\n\n    Args:\n        theta: Joint angle (rotation about z)\n        d: Link offset (translation along z)\n        a: Link length (translation along x)\n        alpha: Link twist (rotation about x)\n\n    Returns:\n        4x4 homogeneous transformation matrix\n    """\n    ct, st = np.cos(theta), np.sin(theta)\n    ca, sa = np.cos(alpha), np.sin(alpha)\n\n    return np.array([\n        [ct, -st*ca,  st*sa, a*ct],\n        [st,  ct*ca, -ct*sa, a*st],\n        [0,   sa,     ca,    d],\n        [0,   0,      0,     1]\n    ])\n\ndef forward_kinematics_dh(joint_angles, dh_params):\n    """\n    Compute FK using DH parameters.\n\n    Args:\n        joint_angles: List of joint angles\n        dh_params: List of (d, a, alpha) for each joint\n\n    Returns:\n        4x4 transformation matrix from base to end-effector\n    """\n    T = np.eye(4)\n\n    for theta, (d, a, alpha) in zip(joint_angles, dh_params):\n        T = T @ dh_matrix(theta, d, a, alpha)\n\n    return T\n\n# DH parameters for 2-DOF planar arm: (d, a, alpha)\n# Joint 1: d=0, a=L1, alpha=0\n# Joint 2: d=0, a=L2, alpha=0\ndh_params = [\n    (0, L1, 0),  # Joint 1\n    (0, L2, 0),  # Joint 2\n]\n\n# Test with same angles as before\njoint_angles = [np.radians(45), np.radians(30)]\nT = forward_kinematics_dh(joint_angles, dh_params)\n\nprint("Transformation matrix:")\nprint(T)\nprint(f"\\nEnd-effector position from DH: ({T[0,3]:.3f}, {T[1,3]:.3f})")\n\n# Verify against direct calculation\nend_pos, _ = forward_kinematics_2dof(joint_angles[0], joint_angles[1])\nprint(f"End-effector position direct:  ({end_pos[0]:.3f}, {end_pos[1]:.3f})")\n'})}),"\n",(0,a.jsx)("checkpoint",{children:(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Verification"}),": Both methods should give the same end-effector position."]})}),"\n",(0,a.jsx)(e.h3,{id:"step-5-verify-with-mujoco-simulation",children:"Step 5: Verify with MuJoCo Simulation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import mujoco\n\n# Create 2-DOF arm model\narm_xml = """\n<mujoco>\n  <option gravity="0 0 0"/>\n\n  <worldbody>\n    <light diffuse="1 1 1" pos="0 0 2"/>\n    <geom type="plane" size="2 2 0.1" rgba="0.8 0.8 0.8 1"/>\n\n    <body name="link1" pos="0 0 0.5">\n      <joint name="joint1" type="hinge" axis="0 0 1" pos="0 0 0"/>\n      <geom type="capsule" fromto="0 0 0 0.5 0 0" size="0.02" rgba="0 0 1 1"/>\n\n      <body name="link2" pos="0.5 0 0">\n        <joint name="joint2" type="hinge" axis="0 0 1" pos="0 0 0"/>\n        <geom type="capsule" fromto="0 0 0 0.4 0 0" size="0.02" rgba="1 0 0 1"/>\n\n        <site name="end_effector" pos="0.4 0 0" size="0.03" rgba="0 1 0 1"/>\n      </body>\n    </body>\n  </worldbody>\n\n  <actuator>\n    <position name="act1" joint="joint1" kp="100"/>\n    <position name="act2" joint="joint2" kp="100"/>\n  </actuator>\n</mujoco>\n"""\n\nmodel = mujoco.MjModel.from_xml_string(arm_xml)\ndata = mujoco.MjData(model)\n\n# Set joint angles\ndata.qpos[0] = np.radians(45)\ndata.qpos[1] = np.radians(30)\n\n# Forward step to update positions\nmujoco.mj_forward(model, data)\n\n# Get end-effector position from simulation\nee_site_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_SITE, "end_effector")\nee_pos_sim = data.site_xpos[ee_site_id]\n\nprint(f"MuJoCo end-effector position: ({ee_pos_sim[0]:.3f}, {ee_pos_sim[1]:.3f})")\nprint(f"Analytical FK position:       ({end_pos[0]:.3f}, {end_pos[1]:.3f})")\nprint(f"Error: {np.linalg.norm(ee_pos_sim[:2] - np.array(end_pos)):.6f} m")\n'})}),"\n",(0,a.jsx)("checkpoint",{children:(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Verification"}),": MuJoCo position should match analytical FK within numerical precision."]})}),"\n",(0,a.jsx)(e.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Working FK implementation for 2-DOF arm"}),"\n",(0,a.jsx)(e.li,{children:"Visualization of arm configurations"}),"\n",(0,a.jsx)(e.li,{children:"Workspace analysis showing annular reachable region"}),"\n",(0,a.jsx)(e.li,{children:"DH parameter implementation"}),"\n",(0,a.jsx)(e.li,{children:"Verification against MuJoCo simulation"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"rubric",children:"Rubric"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Criterion"}),(0,a.jsx)(e.th,{children:"Points"}),(0,a.jsx)(e.th,{children:"Description"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"FK Implementation"}),(0,a.jsx)(e.td,{children:"25"}),(0,a.jsx)(e.td,{children:"Correct forward kinematics calculation"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Visualization"}),(0,a.jsx)(e.td,{children:"20"}),(0,a.jsx)(e.td,{children:"Clear arm configuration plots"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Workspace Analysis"}),(0,a.jsx)(e.td,{children:"20"}),(0,a.jsx)(e.td,{children:"Correct workspace boundaries"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"DH Convention"}),(0,a.jsx)(e.td,{children:"20"}),(0,a.jsx)(e.td,{children:"Proper DH matrix implementation"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Simulation Verification"}),(0,a.jsx)(e.td,{children:"15"}),(0,a.jsx)(e.td,{children:"Matches MuJoCo results"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Total: 100 points"})})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}},8453(n,e,t){t.d(e,{R:()=>o,x:()=>r});var i=t(6540);const a={},s=i.createContext(a);function o(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);