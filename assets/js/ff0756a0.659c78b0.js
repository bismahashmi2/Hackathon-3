"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[9502],{8373(n,e,t){t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"textbook/modules/kinematics-fundamentals/labs/lab-03-02","title":"Inverse Kinematics Solver","description":"Objectives","source":"@site/docs/textbook/modules/03-kinematics-fundamentals/labs/lab-03-02.md","sourceDirName":"textbook/modules/03-kinematics-fundamentals/labs","slug":"/textbook/modules/kinematics-fundamentals/labs/lab-03-02","permalink":"/Hackathon-3/docs/textbook/modules/kinematics-fundamentals/labs/lab-03-02","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/03-kinematics-fundamentals/labs/lab-03-02.md","tags":[],"version":"current","frontMatter":{"id":"lab-03-02","module_id":"03","title":"Inverse Kinematics Solver","difficulty":"intermediate","tier":"simulation","duration_minutes":75,"submission_format":"notebook","auto_gradable":true},"sidebar":"tutorialSidebar","previous":{"title":"Forward Kinematics of a 2-DOF Arm","permalink":"/Hackathon-3/docs/textbook/modules/kinematics-fundamentals/labs/lab-03-01"},"next":{"title":"Full Humanoid FK/IK","permalink":"/Hackathon-3/docs/textbook/modules/kinematics-fundamentals/labs/lab-03-03"}}');var s=t(4848),a=t(8453);const r={id:"lab-03-02",module_id:"03",title:"Inverse Kinematics Solver",difficulty:"intermediate",tier:"simulation",duration_minutes:75,submission_format:"notebook",auto_gradable:!0},l="Lab 03-02: Inverse Kinematics Solver",o={},d=[{value:"Objectives",id:"objectives",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Analytical IK for 2-DOF Arm",id:"step-1-analytical-ik-for-2-dof-arm",level:3},{value:"Step 2: Verify IK Solutions",id:"step-2-verify-ik-solutions",level:3},{value:"Step 3: Handle Singularities and Unreachable Points",id:"step-3-handle-singularities-and-unreachable-points",level:3},{value:"Step 4: Implement Numerical IK with Jacobian",id:"step-4-implement-numerical-ik-with-jacobian",level:3},{value:"Step 5: Compare Analytical and Numerical Solutions",id:"step-5-compare-analytical-and-numerical-solutions",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"lab-03-02-inverse-kinematics-solver",children:"Lab 03-02: Inverse Kinematics Solver"})}),"\n",(0,s.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,s.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Implement analytical IK for a 2-DOF planar arm"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Handle multiple solutions and singularities"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Implement numerical IK using Jacobian"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Validate IK solutions with forward kinematics"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"materials",children:"Materials"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Type"}),(0,s.jsx)(e.th,{children:"Name"}),(0,s.jsx)(e.th,{children:"Version"}),(0,s.jsx)(e.th,{children:"Tier"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"software"}),(0,s.jsx)(e.td,{children:"Python"}),(0,s.jsx)(e.td,{children:"3.10+"}),(0,s.jsx)(e.td,{children:"required"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"software"}),(0,s.jsx)(e.td,{children:"NumPy"}),(0,s.jsx)(e.td,{children:"1.24+"}),(0,s.jsx)(e.td,{children:"required"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"software"}),(0,s.jsx)(e.td,{children:"SciPy"}),(0,s.jsx)(e.td,{children:"1.10+"}),(0,s.jsx)(e.td,{children:"recommended"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"software"}),(0,s.jsx)(e.td,{children:"Matplotlib"}),(0,s.jsx)(e.td,{children:"3.5+"}),(0,s.jsx)(e.td,{children:"required"})]})]})]}),"\n",(0,s.jsx)(e.h2,{id:"background",children:"Background"}),"\n",(0,s.jsx)(e.p,{children:"Inverse kinematics (IK) computes joint angles that achieve a desired end-effector position. Unlike FK, IK often has multiple solutions or no solution."}),"\n",(0,s.jsx)(e.h2,{id:"instructions",children:"Instructions"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-analytical-ik-for-2-dof-arm",children:"Step 1: Analytical IK for 2-DOF Arm"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import numpy as np\nimport matplotlib.pyplot as plt\n\nL1 = 0.5  # Link 1 length\nL2 = 0.4  # Link 2 length\n\ndef inverse_kinematics_2dof(x, y, l1=L1, l2=L2, elbow_up=True):\n    """\n    Analytical inverse kinematics for 2-DOF planar arm.\n\n    Args:\n        x, y: Desired end-effector position\n        l1, l2: Link lengths\n        elbow_up: If True, return elbow-up solution; else elbow-down\n\n    Returns:\n        (theta1, theta2): Joint angles in radians, or None if unreachable\n    """\n    # Check if point is reachable\n    dist = np.sqrt(x**2 + y**2)\n```python\n```python\n    if dist > l1 + l2 or dist < abs(l1 - l2):\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'        return None  # Point is outside workspace\n\n    # Law of cosines to find theta2\n    cos_theta2 = (x**2 + y**2 - l1**2 - l2**2) / (2 * l1 * l2)\n\n    # Clamp to valid range (handles numerical errors)\n    cos_theta2 = np.clip(cos_theta2, -1, 1)\n\n    if elbow_up:\n        theta2 = np.arccos(cos_theta2)\n    else:\n        theta2 = -np.arccos(cos_theta2)\n\n    # Find theta1\n    k1 = l1 + l2 * np.cos(theta2)\n    k2 = l2 * np.sin(theta2)\n\n    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)\n\n    return theta1, theta2\n\n# Test IK\ntarget_x, target_y = 0.6, 0.4\n\n# Get both solutions\nsolution_up = inverse_kinematics_2dof(target_x, target_y, elbow_up=True)\nsolution_down = inverse_kinematics_2dof(target_x, target_y, elbow_up=False)\n\nprint(f"Target position: ({target_x}, {target_y})")\nprint(f"Elbow-up solution:   \u03b81={np.degrees(solution_up[0]):.1f}\xb0, \u03b82={np.degrees(solution_up[1]):.1f}\xb0")\nprint(f"Elbow-down solution: \u03b81={np.degrees(solution_down[0]):.1f}\xb0, \u03b82={np.degrees(solution_down[1]):.1f}\xb0")\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Verification"}),": Both solutions should reach the same target point when verified with FK."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-2-verify-ik-solutions",children:"Step 2: Verify IK Solutions"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def forward_kinematics_2dof(theta1, theta2, l1=L1, l2=L2):\n    \"\"\"Forward kinematics for verification.\"\"\"\n    x = l1 * np.cos(theta1) + l2 * np.cos(theta1 + theta2)\n    y = l1 * np.sin(theta1) + l2 * np.sin(theta1 + theta2)\n    return x, y\n\n# Verify both solutions\nfor name, solution in [(\"Elbow-up\", solution_up), (\"Elbow-down\", solution_down)]:\n    if solution is not None:\n        x_fk, y_fk = forward_kinematics_2dof(solution[0], solution[1])\n        error = np.sqrt((x_fk - target_x)**2 + (y_fk - target_y)**2)\n        print(f\"{name}: FK result ({x_fk:.4f}, {y_fk:.4f}), Error: {error:.6f}\")\n\n# Visualize both solutions\nfig, axes = plt.subplots(1, 2, figsize=(12, 6))\n\nfor ax, (name, solution) in zip(axes, [(\"Elbow-Up\", solution_up), (\"Elbow-Down\", solution_down)]):\n    if solution is None:\n        continue\n\n    theta1, theta2 = solution\n\n    # Compute positions\n    elbow_x = L1 * np.cos(theta1)\n    elbow_y = L1 * np.sin(theta1)\n    end_x = elbow_x + L2 * np.cos(theta1 + theta2)\n    end_y = elbow_y + L2 * np.sin(theta1 + theta2)\n\n    # Plot arm\n    ax.plot([0, elbow_x], [0, elbow_y], 'b-', linewidth=3)\n    ax.plot([elbow_x, end_x], [elbow_y, end_y], 'r-', linewidth=3)\n    ax.plot(0, 0, 'ko', markersize=10)\n    ax.plot(elbow_x, elbow_y, 'ko', markersize=8)\n    ax.plot(end_x, end_y, 'g^', markersize=12)\n\n    # Plot target\n    ax.plot(target_x, target_y, 'mx', markersize=15, markeredgewidth=3, label='Target')\n\n    ax.set_xlim(-1, 1)\n    ax.set_ylim(-0.5, 1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f\"{name} Solution\\n\u03b81={np.degrees(theta1):.1f}\xb0, \u03b82={np.degrees(theta2):.1f}\xb0\")\n    ax.legend()\n\nplt.tight_layout()\nplt.savefig('ik_solutions.png', dpi=150)\nplt.show()\n"})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": Two different arm configurations reaching the same target point."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-3-handle-singularities-and-unreachable-points",children:"Step 3: Handle Singularities and Unreachable Points"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def test_ik_robustness():\n    """Test IK with various target points."""\n    test_points = [\n        (0.6, 0.4, "Normal point"),\n        (0.9, 0.0, "At outer boundary"),\n        (0.1, 0.0, "At inner boundary"),\n        (1.0, 0.0, "Outside workspace"),\n        (0.0, 0.0, "At origin (inside hole)"),\n        (0.0, 0.9, "On y-axis"),\n    ]\n\n    print("IK Robustness Test:")\n    print("-" * 60)\n\n    for x, y, description in test_points:\n        solution = inverse_kinematics_2dof(x, y)\n\n        if solution is None:\n            status = "UNREACHABLE"\n            angles = "N/A"\n        else:\n            # Verify solution\n            x_fk, y_fk = forward_kinematics_2dof(solution[0], solution[1])\n            error = np.sqrt((x_fk - x)**2 + (y_fk - y)**2)\n\n```python\n```python\n            if error < 1e-6:\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'                status = "OK"\n            else:\n                status = f"ERROR: {error:.6f}"\n\n            angles = f"({np.degrees(solution[0]):.1f}\xb0, {np.degrees(solution[1]):.1f}\xb0)"\n\n        print(f"({x:.1f}, {y:.1f}) {description:25} -> {status:15} {angles}")\n\ntest_ik_robustness()\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Analysis"}),": Points at boundaries should be solvable; points outside should return None."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-4-implement-numerical-ik-with-jacobian",children:"Step 4: Implement Numerical IK with Jacobian"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def jacobian_2dof(theta1, theta2, l1=L1, l2=L2):\n    """\n    Compute the Jacobian matrix for 2-DOF arm.\n\n    Returns:\n        2x2 Jacobian matrix relating joint velocities to end-effector velocities\n    """\n    j11 = -l1 * np.sin(theta1) - l2 * np.sin(theta1 + theta2)\n    j12 = -l2 * np.sin(theta1 + theta2)\n    j21 = l1 * np.cos(theta1) + l2 * np.cos(theta1 + theta2)\n    j22 = l2 * np.cos(theta1 + theta2)\n\n    return np.array([[j11, j12], [j21, j22]])\n\ndef inverse_kinematics_numerical(x_target, y_target, theta_init=None,\n                                  max_iter=100, tol=1e-6, l1=L1, l2=L2):\n    """\n    Numerical IK using Jacobian pseudoinverse (damped least squares).\n\n    Args:\n        x_target, y_target: Desired end-effector position\n        theta_init: Initial joint angles (random if None)\n        max_iter: Maximum iterations\n        tol: Convergence tolerance\n\n    Returns:\n        Joint angles or None if failed\n    """\n    # Initialize\n    if theta_init is None:\n        theta = np.random.uniform(-np.pi, np.pi, 2)\n    else:\n        theta = np.array(theta_init)\n\n    damping = 0.01  # Damping factor for numerical stability\n\n    for i in range(max_iter):\n        # Current end-effector position\n        x_curr, y_curr = forward_kinematics_2dof(theta[0], theta[1], l1, l2)\n\n        # Error\n        error = np.array([x_target - x_curr, y_target - y_curr])\n\n```python\n```python\n        if np.linalg.norm(error) < tol:\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'            return theta, i  # Converged\n\n        # Jacobian\n        J = jacobian_2dof(theta[0], theta[1], l1, l2)\n\n        # Damped least squares (more stable than pseudoinverse)\n        JtJ = J.T @ J + damping**2 * np.eye(2)\n        delta_theta = np.linalg.solve(JtJ, J.T @ error)\n\n        # Update\n        theta = theta + delta_theta\n\n    return None, max_iter  # Did not converge\n\n# Test numerical IK\ntarget_x, target_y = 0.6, 0.4\n\n# Run from multiple initial conditions\nprint("Numerical IK Results:")\nprint("-" * 50)\n\nnp.random.seed(42)\nfor trial in range(5):\n    result, iterations = inverse_kinematics_numerical(target_x, target_y)\n\n    if result is not None:\n        x_fk, y_fk = forward_kinematics_2dof(result[0], result[1])\n        error = np.sqrt((x_fk - target_x)**2 + (y_fk - target_y)**2)\n        print(f"Trial {trial+1}: \u03b8=({np.degrees(result[0]):.1f}\xb0, {np.degrees(result[1]):.1f}\xb0), "\n              f"Iterations: {iterations}, Error: {error:.2e}")\n    else:\n        print(f"Trial {trial+1}: Failed to converge")\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Observation"}),": Numerical IK may find different solutions depending on initial guess.\n",(0,s.jsx)(e.strong,{children:"Understanding"}),": This demonstrates why IK is challenging - multiple solutions exist."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-5-compare-analytical-and-numerical-solutions",children:"Step 5: Compare Analytical and Numerical Solutions"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Generate test grid\ntest_points = []\nfor x in np.linspace(-0.7, 0.7, 10):\n    for y in np.linspace(-0.7, 0.7, 10):\n```python\n```python\n        if abs(L1 - L2) < np.sqrt(x**2 + y**2) < L1 + L2:\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'            test_points.append((x, y))\n\n# Compare methods\nanalytical_times = []\nnumerical_times = []\nerrors = []\n\nimport time\n\nfor x, y in test_points:\n    # Analytical\n    t0 = time.time()\n    sol_analytical = inverse_kinematics_2dof(x, y)\n    analytical_times.append(time.time() - t0)\n\n    # Numerical (with good initial guess from analytical)\n    t0 = time.time()\n    if sol_analytical:\n        sol_numerical, _ = inverse_kinematics_numerical(x, y, theta_init=sol_analytical)\n    else:\n        sol_numerical, _ = inverse_kinematics_numerical(x, y)\n    numerical_times.append(time.time() - t0)\n\n    # Compare\n    if sol_analytical and sol_numerical is not None:\n        x1, y1 = forward_kinematics_2dof(*sol_analytical)\n        x2, y2 = forward_kinematics_2dof(*sol_numerical)\n        errors.append(np.sqrt((x1-x2)**2 + (y1-y2)**2))\n\nprint(f"\\nPerformance Comparison ({len(test_points)} points):")\nprint(f"Analytical: {np.mean(analytical_times)*1000:.3f} ms average")\nprint(f"Numerical:  {np.mean(numerical_times)*1000:.3f} ms average")\nprint(f"Speedup:    {np.mean(numerical_times)/np.mean(analytical_times):.1f}x slower")\nprint(f"Max FK error between solutions: {max(errors):.2e}")\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Key Insight"}),": Analytical IK is much faster but only available for simple geometries.\nNumerical IK is general but slower and may converge to different solutions."]})}),"\n",(0,s.jsx)(e.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Working analytical IK with multiple solution handling"}),"\n",(0,s.jsx)(e.li,{children:"Proper handling of unreachable points and singularities"}),"\n",(0,s.jsx)(e.li,{children:"Numerical IK implementation using Jacobian"}),"\n",(0,s.jsx)(e.li,{children:"Comparison between analytical and numerical approaches"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"rubric",children:"Rubric"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Criterion"}),(0,s.jsx)(e.th,{children:"Points"}),(0,s.jsx)(e.th,{children:"Description"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Analytical IK"}),(0,s.jsx)(e.td,{children:"30"}),(0,s.jsx)(e.td,{children:"Correct implementation with both solutions"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Robustness"}),(0,s.jsx)(e.td,{children:"20"}),(0,s.jsx)(e.td,{children:"Proper handling of edge cases"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Numerical IK"}),(0,s.jsx)(e.td,{children:"25"}),(0,s.jsx)(e.td,{children:"Working Jacobian-based solver"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Verification"}),(0,s.jsx)(e.td,{children:"15"}),(0,s.jsx)(e.td,{children:"FK verification of all solutions"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Analysis"}),(0,s.jsx)(e.td,{children:"10"}),(0,s.jsx)(e.td,{children:"Comparison and insights"})]})]})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Total: 100 points"})})]})}function h(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453(n,e,t){t.d(e,{R:()=>r,x:()=>l});var i=t(6540);const s={},a=i.createContext(s);function r(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);