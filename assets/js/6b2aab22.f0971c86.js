"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[209],{8453(n,e,s){s.d(e,{R:()=>o,x:()=>t});var a=s(6540);const r={},i=a.createContext(r);function o(n){const e=a.useContext(i);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),a.createElement(i.Provider,{value:e},n.children)}},9132(n,e,s){s.r(e),s.d(e,{assets:()=>d,contentTitle:()=>t,default:()=>m,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"textbook/modules/simulation-to-real/labs/lab-10-01","title":"Domain Randomization Fundamentals","description":"Objectives","source":"@site/docs/textbook/modules/10-simulation-to-real/labs/lab-10-01.md","sourceDirName":"textbook/modules/10-simulation-to-real/labs","slug":"/textbook/modules/simulation-to-real/labs/lab-10-01","permalink":"/Hackathon-3/docs/textbook/modules/simulation-to-real/labs/lab-10-01","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/10-simulation-to-real/labs/lab-10-01.md","tags":[],"version":"current","frontMatter":{"id":"lab-10-01","module_id":"10","title":"Domain Randomization Fundamentals","difficulty":"guided","tier":"simulation","duration_minutes":75},"sidebar":"tutorialSidebar","previous":{"title":"Ethics in Sim-to-Real Transfer","permalink":"/Hackathon-3/docs/textbook/modules/simulation-to-real/ethics"},"next":{"title":"System Identification for Real Robots","permalink":"/Hackathon-3/docs/textbook/modules/simulation-to-real/labs/lab-10-02"}}');var r=s(4848),i=s(8453);const o={id:"lab-10-01",module_id:"10",title:"Domain Randomization Fundamentals",difficulty:"guided",tier:"simulation",duration_minutes:75},t="Lab 10-01: Domain Randomization Fundamentals",d={},l=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"The Sim-to-Real Gap",id:"the-sim-to-real-gap",level:3},{value:"Domain Randomization Strategy",id:"domain-randomization-strategy",level:3},{value:"Types of Randomization",id:"types-of-randomization",level:3},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Set Up Randomization Framework",id:"step-1-set-up-randomization-framework",level:3},{value:"Step 2: Implement Visual Randomization",id:"step-2-implement-visual-randomization",level:3},{value:"Step 3: Implement Sensor Noise Randomization",id:"step-3-implement-sensor-noise-randomization",level:3},{value:"Step 4: Run Randomized Training Episodes",id:"step-4-run-randomized-training-episodes",level:3},{value:"Step 5: Analyze Robustness",id:"step-5-analyze-robustness",level:3},{value:"Step 6: Curriculum Randomization",id:"step-6-curriculum-randomization",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2},{value:"Common Errors",id:"common-errors",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Related Content",id:"related-content",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"lab-10-01-domain-randomization-fundamentals",children:"Lab 10-01: Domain Randomization Fundamentals"})}),"\n",(0,r.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,r.jsx)(e.p,{children:"By the end of this lab, you will be able to:"}),"\n",(0,r.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Implement physics parameter randomization"]}),"\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Apply visual domain randomization to camera inputs"]}),"\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Configure dynamics randomization for robust control"]}),"\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Analyze policy robustness across parameter distributions"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Completed Module 09 (ROS2 Integration)"}),"\n",(0,r.jsx)(e.li,{children:"Understanding of control systems (Module 05)"}),"\n",(0,r.jsx)(e.li,{children:"Familiarity with MuJoCo simulation"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"materials",children:"Materials"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Type"}),(0,r.jsx)(e.th,{children:"Name"}),(0,r.jsx)(e.th,{children:"Tier"}),(0,r.jsx)(e.th,{children:"Notes"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"software"}),(0,r.jsx)(e.td,{children:"MuJoCo 3.0+"}),(0,r.jsx)(e.td,{children:"required"}),(0,r.jsx)(e.td,{children:"Physics simulation"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"software"}),(0,r.jsx)(e.td,{children:"Python 3.10+"}),(0,r.jsx)(e.td,{children:"required"}),(0,r.jsx)(e.td,{children:"Programming environment"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"software"}),(0,r.jsx)(e.td,{children:"NumPy, SciPy"}),(0,r.jsx)(e.td,{children:"required"}),(0,r.jsx)(e.td,{children:"Randomization"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"software"}),(0,r.jsx)(e.td,{children:"OpenCV"}),(0,r.jsx)(e.td,{children:"optional"}),(0,r.jsx)(e.td,{children:"Visual randomization"})]})]})]}),"\n",(0,r.jsx)(e.h2,{id:"background",children:"Background"}),"\n",(0,r.jsx)(e.h3,{id:"the-sim-to-real-gap",children:"The Sim-to-Real Gap"}),"\n",(0,r.jsx)(e.p,{children:"Simulations differ from reality in:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Physics (friction, damping, contact dynamics)"}),"\n",(0,r.jsx)(e.li,{children:"Visuals (lighting, textures, reflections)"}),"\n",(0,r.jsx)(e.li,{children:"Sensors (noise, latency, calibration)"}),"\n",(0,r.jsx)(e.li,{children:"Actuation (delays, limits, backlash)"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"domain-randomization-strategy",children:"Domain Randomization Strategy"}),"\n",(0,r.jsx)(e.p,{children:'Train on a distribution of environments so that reality appears as "just another sample" from the distribution.'}),"\n",(0,r.jsx)(e.h3,{id:"types-of-randomization",children:"Types of Randomization"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Physics"}),": Mass, friction, damping, joint dynamics"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Visual"}),": Textures, lighting, camera parameters"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Dynamics"}),": Actuator delays, gains, noise"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Observations"}),": Sensor noise, calibration errors"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"instructions",children:"Instructions"}),"\n",(0,r.jsx)(e.h3,{id:"step-1-set-up-randomization-framework",children:"Step 1: Set Up Randomization Framework"}),"\n",(0,r.jsx)(e.p,{children:"Create a domain randomization system:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import mujoco\nimport numpy as np\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Tuple, Optional\nimport copy\n\n@dataclass\nclass RandomizationRange:\n    \"\"\"Defines a randomization range for a parameter.\"\"\"\n    min_val: float\n    max_val: float\n    distribution: str = 'uniform'  # 'uniform', 'normal', 'loguniform'\n    mean: float = 0.0  # For normal distribution\n    std: float = 1.0   # For normal distribution\n\n```python\n```python\n    def sample(self) -> float:\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'        """Sample a value from this range."""\n```python\n```python\n        if self.distribution == \'uniform\':\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'            return np.random.uniform(self.min_val, self.max_val)\n        elif self.distribution == \'normal\':\n            val = np.random.normal(self.mean, self.std)\n            return np.clip(val, self.min_val, self.max_val)\n        elif self.distribution == \'loguniform\':\n            log_min = np.log(self.min_val)\n            log_max = np.log(self.max_val)\n            return np.exp(np.random.uniform(log_min, log_max))\n        else:\n            raise ValueError(f"Unknown distribution: {self.distribution}")\n\nclass DomainRandomizer:\n    """Apply domain randomization to MuJoCo models."""\n\n    def __init__(self, model_path: str):\n        """\n        Initialize randomizer.\n\n        Args:\n            model_path: Path to MuJoCo XML model\n        """\n        self.model_path = model_path\n        self.base_model = mujoco.MjModel.from_xml_path(model_path)\n\n        # Store default values\n        self._store_defaults()\n\n        # Randomization parameters\n        self.physics_ranges: Dict[str, RandomizationRange] = {}\n        self.visual_ranges: Dict[str, RandomizationRange] = {}\n        self.dynamics_ranges: Dict[str, RandomizationRange] = {}\n\n        # Current randomization values\n        self.current_params: Dict[str, float] = {}\n\n    def _store_defaults(self):\n        """Store default model parameters."""\n        self.defaults = {\n            \'body_mass\': self.base_model.body_mass.copy(),\n            \'geom_friction\': self.base_model.geom_friction.copy(),\n            \'dof_damping\': self.base_model.dof_damping.copy(),\n            \'actuator_gainprm\': self.base_model.actuator_gainprm.copy(),\n        }\n\n    def add_physics_randomization(self, param_name: str, range_config: RandomizationRange):\n        """Add physics parameter randomization."""\n        self.physics_ranges[param_name] = range_config\n\n    def add_dynamics_randomization(self, param_name: str, range_config: RandomizationRange):\n        """Add dynamics parameter randomization."""\n        self.dynamics_ranges[param_name] = range_config\n\n```python\n```python\n    def randomize(self) -> mujoco.MjModel:\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"        \"\"\"\n        Create a randomized model.\n\n        Returns:\n            Randomized MjModel\n        \"\"\"\n        # Create fresh model\n        model = mujoco.MjModel.from_xml_path(self.model_path)\n        self.current_params = {}\n\n        # Apply physics randomization\n        self._randomize_physics(model)\n\n        # Apply dynamics randomization\n        self._randomize_dynamics(model)\n\n        return model\n\n    def _randomize_physics(self, model: mujoco.MjModel):\n        \"\"\"Apply physics randomization.\"\"\"\n\n        # Mass randomization\n        if 'mass_scale' in self.physics_ranges:\n            scale = self.physics_ranges['mass_scale'].sample()\n            model.body_mass[:] = self.defaults['body_mass'] * scale\n            self.current_params['mass_scale'] = scale\n\n        # Friction randomization\n        if 'friction_scale' in self.physics_ranges:\n            scale = self.physics_ranges['friction_scale'].sample()\n            model.geom_friction[:, 0] = self.defaults['geom_friction'][:, 0] * scale\n            self.current_params['friction_scale'] = scale\n\n        # Damping randomization\n        if 'damping_scale' in self.physics_ranges:\n            scale = self.physics_ranges['damping_scale'].sample()\n            model.dof_damping[:] = self.defaults['dof_damping'] * scale\n            self.current_params['damping_scale'] = scale\n\n    def _randomize_dynamics(self, model: mujoco.MjModel):\n        \"\"\"Apply dynamics randomization.\"\"\"\n\n        # Actuator gain randomization\n        if 'actuator_gain_scale' in self.dynamics_ranges:\n            scale = self.dynamics_ranges['actuator_gain_scale'].sample()\n            model.actuator_gainprm[:, 0] = self.defaults['actuator_gainprm'][:, 0] * scale\n            self.current_params['actuator_gain_scale'] = scale\n\n```python\n```python\n    def get_current_params(self) -> Dict[str, float]:\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"        \"\"\"Get current randomization parameters.\"\"\"\n        return self.current_params.copy()\n\n# Test the randomizer\nprint(\"Creating domain randomizer...\")\nrandomizer = DomainRandomizer(\"textbook/assets/robot-models/mujoco/2dof-arm.xml\")\n\n# Configure randomization ranges\nrandomizer.add_physics_randomization(\n    'mass_scale',\n    RandomizationRange(0.8, 1.2, 'uniform')\n)\nrandomizer.add_physics_randomization(\n    'friction_scale',\n    RandomizationRange(0.5, 2.0, 'loguniform')\n)\nrandomizer.add_physics_randomization(\n    'damping_scale',\n    RandomizationRange(0.5, 1.5, 'uniform')\n)\nrandomizer.add_dynamics_randomization(\n    'actuator_gain_scale',\n    RandomizationRange(0.9, 1.1, 'normal', mean=1.0, std=0.05)\n)\n\nprint(\"Randomizer configured\")\n"})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Expected"}),": DomainRandomizer created with configurable parameter ranges."]})}),"\n",(0,r.jsx)(e.h3,{id:"step-2-implement-visual-randomization",children:"Step 2: Implement Visual Randomization"}),"\n",(0,r.jsx)(e.p,{children:"Add visual domain randomization:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import cv2\n\nclass VisualRandomizer:\n    \"\"\"Apply visual domain randomization to images.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize visual randomizer.\"\"\"\n        self.randomization_enabled = {\n            'brightness': True,\n            'contrast': True,\n            'saturation': True,\n            'noise': True,\n            'blur': True,\n            'color_jitter': True\n        }\n\n        # Default ranges\n        self.brightness_range = (-0.3, 0.3)\n        self.contrast_range = (0.7, 1.3)\n        self.saturation_range = (0.7, 1.3)\n        self.noise_std_range = (0, 0.05)\n        self.blur_range = (0, 2)\n\n```python\n```python\n    def randomize(self, image: np.ndarray) -> np.ndarray:\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"        \"\"\"\n        Apply visual randomization to image.\n\n        Args:\n            image: Input image (H, W, 3) uint8\n\n        Returns:\n            Randomized image\n        \"\"\"\n        # Convert to float for processing\n        img = image.astype(np.float32) / 255.0\n\n        # Brightness\n        if self.randomization_enabled['brightness']:\n            delta = np.random.uniform(*self.brightness_range)\n            img = img + delta\n            img = np.clip(img, 0, 1)\n\n        # Contrast\n        if self.randomization_enabled['contrast']:\n            factor = np.random.uniform(*self.contrast_range)\n            mean = np.mean(img)\n            img = (img - mean) * factor + mean\n            img = np.clip(img, 0, 1)\n\n        # Color jitter\n        if self.randomization_enabled['color_jitter']:\n            for c in range(3):\n                jitter = np.random.uniform(-0.1, 0.1)\n                img[:, :, c] = np.clip(img[:, :, c] + jitter, 0, 1)\n\n        # Saturation (HSV manipulation)\n        if self.randomization_enabled['saturation']:\n            hsv = cv2.cvtColor((img * 255).astype(np.uint8), cv2.COLOR_RGB2HSV)\n            factor = np.random.uniform(*self.saturation_range)\n            hsv[:, :, 1] = np.clip(hsv[:, :, 1] * factor, 0, 255)\n            img = cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB).astype(np.float32) / 255.0\n\n        # Gaussian noise\n        if self.randomization_enabled['noise']:\n            std = np.random.uniform(*self.noise_std_range)\n            noise = np.random.normal(0, std, img.shape)\n            img = img + noise\n            img = np.clip(img, 0, 1)\n\n        # Gaussian blur\n        if self.randomization_enabled['blur']:\n            sigma = np.random.uniform(*self.blur_range)\n```python\n```python\n            if sigma > 0.1:\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"                ksize = int(sigma * 4) | 1  # Ensure odd\n                img = cv2.GaussianBlur(img, (ksize, ksize), sigma)\n\n        # Convert back to uint8\n        return (img * 255).astype(np.uint8)\n\n```python\n```python\n    def randomize_camera_params(self) -> Dict[str, float]:\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'        """\n        Generate randomized camera parameters.\n\n        Returns:\n            Dict of camera parameter adjustments\n        """\n        return {\n            \'fov_scale\': np.random.uniform(0.95, 1.05),\n            \'position_noise\': np.random.normal(0, 0.01, 3),\n            \'rotation_noise\': np.random.normal(0, 0.02, 3),  # Euler angles\n        }\n\n# Test visual randomization\nvisual_rand = VisualRandomizer()\n\n# Create test image\ntest_image = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)\ntest_image[:, :, 0] = 100  # Red background\ntest_image[200:280, 280:360, :] = [0, 255, 0]  # Green square\n\n# Apply randomization\nrandomized = visual_rand.randomize(test_image)\nprint(f"Original range: [{test_image.min()}, {test_image.max()}]")\nprint(f"Randomized range: [{randomized.min()}, {randomized.max()}]")\n'})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Expected"}),": VisualRandomizer applies brightness, contrast, noise, and blur."]})}),"\n",(0,r.jsx)(e.h3,{id:"step-3-implement-sensor-noise-randomization",children:"Step 3: Implement Sensor Noise Randomization"}),"\n",(0,r.jsx)(e.p,{children:"Add realistic sensor noise models:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"class SensorNoiseRandomizer:\n    \"\"\"Apply randomized sensor noise.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize sensor noise models.\"\"\"\n        # Joint encoder noise\n        self.encoder_noise_std = RandomizationRange(0.0001, 0.001, 'loguniform')\n\n        # IMU noise\n        self.gyro_noise_std = RandomizationRange(0.001, 0.01, 'loguniform')\n        self.gyro_bias = RandomizationRange(-0.01, 0.01, 'uniform')\n        self.accel_noise_std = RandomizationRange(0.01, 0.1, 'loguniform')\n        self.accel_bias = RandomizationRange(-0.1, 0.1, 'uniform')\n\n        # Force sensor noise\n        self.force_noise_std = RandomizationRange(0.1, 1.0, 'loguniform')\n\n        # Current noise parameters (resampled each episode)\n        self.current_noise_params = {}\n\n    def resample_noise_params(self):\n        \"\"\"Resample noise parameters for new episode.\"\"\"\n        self.current_noise_params = {\n            'encoder_noise_std': self.encoder_noise_std.sample(),\n            'gyro_noise_std': self.gyro_noise_std.sample(),\n            'gyro_bias': np.array([self.gyro_bias.sample() for _ in range(3)]),\n            'accel_noise_std': self.accel_noise_std.sample(),\n            'accel_bias': np.array([self.accel_bias.sample() for _ in range(3)]),\n            'force_noise_std': self.force_noise_std.sample()\n        }\n        return self.current_noise_params\n\n```python\n```python\n    def add_encoder_noise(self, positions: np.ndarray) -> np.ndarray:\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'        """Add noise to joint encoder readings."""\n        std = self.current_noise_params.get(\'encoder_noise_std\', 0.0005)\n        noise = np.random.normal(0, std, positions.shape)\n        return positions + noise\n\n```python\n```python\n    def add_imu_noise(self, gyro: np.ndarray, accel: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"        \"\"\"Add noise to IMU readings.\"\"\"\n        gyro_std = self.current_noise_params.get('gyro_noise_std', 0.005)\n        gyro_bias = self.current_noise_params.get('gyro_bias', np.zeros(3))\n        gyro_noisy = gyro + np.random.normal(0, gyro_std, 3) + gyro_bias\n\n        accel_std = self.current_noise_params.get('accel_noise_std', 0.05)\n        accel_bias = self.current_noise_params.get('accel_bias', np.zeros(3))\n        accel_noisy = accel + np.random.normal(0, accel_std, 3) + accel_bias\n\n        return gyro_noisy, accel_noisy\n\n```python\n```python\n    def add_force_noise(self, force: np.ndarray) -> np.ndarray:\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'        """Add noise to force sensor readings."""\n        std = self.current_noise_params.get(\'force_noise_std\', 0.5)\n        noise = np.random.normal(0, std, force.shape)\n        return force + noise\n\n# Test sensor noise\nsensor_noise = SensorNoiseRandomizer()\nparams = sensor_noise.resample_noise_params()\n\nprint("Sensor noise parameters:")\nfor k, v in params.items():\n    if isinstance(v, np.ndarray):\n        print(f"  {k}: {v}")\n    else:\n        print(f"  {k}: {v:.6f}")\n\n# Test noise application\npositions = np.array([0.0, 1.57])\nnoisy_positions = sensor_noise.add_encoder_noise(positions)\nprint(f"\\nOriginal positions: {positions}")\nprint(f"Noisy positions: {noisy_positions}")\n'})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Expected"}),": SensorNoiseRandomizer adds configurable noise to all sensor types."]})}),"\n",(0,r.jsx)(e.h3,{id:"step-4-run-randomized-training-episodes",children:"Step 4: Run Randomized Training Episodes"}),"\n",(0,r.jsx)(e.p,{children:"Create training loop with randomization:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"class RandomizedEnvironment:\n    \"\"\"Environment with domain randomization.\"\"\"\n\n    def __init__(self, model_path: str):\n        self.physics_rand = DomainRandomizer(model_path)\n        self.visual_rand = VisualRandomizer()\n        self.sensor_rand = SensorNoiseRandomizer()\n\n        # Configure physics randomization\n        self.physics_rand.add_physics_randomization(\n            'mass_scale', RandomizationRange(0.8, 1.2)\n        )\n        self.physics_rand.add_physics_randomization(\n            'friction_scale', RandomizationRange(0.5, 2.0, 'loguniform')\n        )\n        self.physics_rand.add_physics_randomization(\n            'damping_scale', RandomizationRange(0.5, 1.5)\n        )\n        self.physics_rand.add_dynamics_randomization(\n            'actuator_gain_scale', RandomizationRange(0.9, 1.1)\n        )\n\n        # Current model and data\n        self.model = None\n        self.data = None\n\n        # Episode statistics\n        self.episode_params = {}\n\n```python\n```python\n    def reset(self, randomize: bool = True) -> np.ndarray:\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"        \"\"\"\n        Reset environment with optional randomization.\n\n        Args:\n            randomize: Whether to apply domain randomization\n\n        Returns:\n            Initial observation\n        \"\"\"\n        if randomize:\n            # Create randomized model\n            self.model = self.physics_rand.randomize()\n            self.episode_params = {\n                'physics': self.physics_rand.get_current_params(),\n                'sensor': self.sensor_rand.resample_noise_params()\n            }\n        else:\n            # Use base model\n            self.model = mujoco.MjModel.from_xml_path(self.physics_rand.model_path)\n            self.episode_params = {'physics': {}, 'sensor': {}}\n\n        self.data = mujoco.MjData(self.model)\n        mujoco.mj_resetData(self.model, self.data)\n        mujoco.mj_forward(self.model, self.data)\n\n        return self._get_observation()\n\n```python\n```python\n    def step(self, action: np.ndarray) -> Tuple[np.ndarray, float, bool, dict]:\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'        """\n        Execute action in environment.\n\n        Returns:\n            obs, reward, done, info\n        """\n        # Apply action\n        self.data.ctrl[:] = action\n\n        # Step simulation\n        mujoco.mj_step(self.model, self.data)\n\n        # Get observation with sensor noise\n        obs = self._get_observation()\n\n        # Compute reward (example: distance to target)\n        reward = self._compute_reward()\n\n        # Check termination\n        done = self._check_done()\n\n        info = {\'params\': self.episode_params}\n\n        return obs, reward, done, info\n\n```python\n```python\n    def _get_observation(self) -> np.ndarray:\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'        """Get observation with sensor noise."""\n        # Joint positions and velocities\n        pos = self.sensor_rand.add_encoder_noise(self.data.qpos.copy())\n        vel = self.sensor_rand.add_encoder_noise(self.data.qvel.copy())\n\n        return np.concatenate([pos, vel])\n\n```python\n```python\n    def _compute_reward(self) -> float:\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'        """Compute reward."""\n        # Example: negative distance to origin\n        return -np.linalg.norm(self.data.qpos)\n\n```python\n```python\n    def _check_done(self) -> bool:\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'        """Check if episode is done."""\n        return False\n\ndef run_randomized_training(env, n_episodes=10, steps_per_episode=100):\n    """Run training with domain randomization."""\n    all_rewards = []\n    all_params = []\n\n    for ep in range(n_episodes):\n        obs = env.reset(randomize=True)\n        episode_reward = 0\n\n        for step in range(steps_per_episode):\n            # Random action for testing\n            action = np.random.uniform(-1, 1, env.model.nu)\n\n            obs, reward, done, info = env.step(action)\n            episode_reward += reward\n\n            if done:\n                break\n\n        all_rewards.append(episode_reward)\n        all_params.append(env.episode_params)\n\n        print(f"Episode {ep}: reward={episode_reward:.2f}, "\n              f"mass_scale={env.episode_params[\'physics\'].get(\'mass_scale\', 1.0):.2f}")\n\n    return all_rewards, all_params\n\n# Run training\nprint("\\nRunning randomized training...")\nenv = RandomizedEnvironment("textbook/assets/robot-models/mujoco/2dof-arm.xml")\nrewards, params = run_randomized_training(env, n_episodes=5)\n'})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Expected"}),": Multiple episodes run with different randomization parameters."]})}),"\n",(0,r.jsx)(e.h3,{id:"step-5-analyze-robustness",children:"Step 5: Analyze Robustness"}),"\n",(0,r.jsx)(e.p,{children:"Evaluate policy robustness across parameter space:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'def analyze_robustness(env, policy_fn, param_name: str, param_range: Tuple[float, float],\n                       n_samples: int = 10, steps: int = 100):\n    """\n    Analyze policy robustness across a parameter range.\n\n    Args:\n        env: Environment\n        policy_fn: Policy function (obs -> action)\n        param_name: Parameter to vary\n        param_range: (min, max) range\n        n_samples: Number of samples\n        steps: Steps per evaluation\n\n    Returns:\n        results: Dict with analysis results\n    """\n    param_values = np.linspace(param_range[0], param_range[1], n_samples)\n    rewards = []\n    success_rates = []\n\n    for param_val in param_values:\n        episode_rewards = []\n\n        # Run multiple episodes at this parameter\n        for _ in range(5):\n            # Configure specific parameter\n```python\n```python\n            if param_name == \'mass_scale\':\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"                env.physics_rand.physics_ranges['mass_scale'] = RandomizationRange(\n                    param_val, param_val  # Fixed value\n                )\n\n            obs = env.reset(randomize=True)\n            ep_reward = 0\n            success = True\n\n            for _ in range(steps):\n                action = policy_fn(obs)\n                obs, reward, done, info = env.step(action)\n                ep_reward += reward\n\n                if done:\n                    break\n\n            episode_rewards.append(ep_reward)\n\n        rewards.append(np.mean(episode_rewards))\n        success_rates.append(sum(1 for r in episode_rewards if r > -50) / len(episode_rewards))\n\n    results = {\n        'param_name': param_name,\n        'param_values': param_values,\n        'rewards': np.array(rewards),\n        'success_rates': np.array(success_rates)\n    }\n\n    # Compute robustness metrics\n    results['mean_reward'] = np.mean(rewards)\n    results['std_reward'] = np.std(rewards)\n    results['min_reward'] = np.min(rewards)\n    results['robustness_ratio'] = results['min_reward'] / results['mean_reward']\n\n    return results\n\n# Simple policy for testing\ndef simple_policy(obs):\n    \"\"\"PD control policy.\"\"\"\n    target = np.array([0.5, 0.5])\n    pos = obs[:2]\n    vel = obs[2:4]\n    kp, kd = 10.0, 1.0\n    return kp * (target - pos) - kd * vel\n\n# Analyze robustness\nprint(\"\\nAnalyzing robustness to mass variation...\")\nresults = analyze_robustness(\n    env,\n    simple_policy,\n    'mass_scale',\n    (0.5, 1.5),\n    n_samples=5,\n    steps=50\n)\n\nprint(f\"\\nRobustness Analysis Results:\")\nprint(f\"  Parameter: {results['param_name']}\")\nprint(f\"  Mean reward: {results['mean_reward']:.2f}\")\nprint(f\"  Std reward: {results['std_reward']:.2f}\")\nprint(f\"  Min reward: {results['min_reward']:.2f}\")\nprint(f\"  Robustness ratio: {results['robustness_ratio']:.2f}\")\n"})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Expected"}),": Policy performance measured across parameter variations."]})}),"\n",(0,r.jsx)(e.h3,{id:"step-6-curriculum-randomization",children:"Step 6: Curriculum Randomization"}),"\n",(0,r.jsx)(e.p,{children:"Implement progressive randomization:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'class CurriculumRandomizer:\n    """Progressive domain randomization curriculum."""\n\n    def __init__(self, base_randomizer: DomainRandomizer):\n        self.base_rand = base_randomizer\n\n        # Curriculum stages (0 = no randomization, 1 = full)\n        self.stage = 0.0\n        self.stage_increment = 0.1\n\n        # Target ranges at full curriculum\n        self.target_ranges = {\n            \'mass_scale\': (0.5, 1.5),\n            \'friction_scale\': (0.3, 3.0),\n            \'damping_scale\': (0.3, 2.0),\n            \'actuator_gain_scale\': (0.8, 1.2)\n        }\n\n        # Current ranges\n        self.current_ranges = {}\n        self._update_ranges()\n\n    def _update_ranges(self):\n        """Update randomization ranges based on current stage."""\n        for param, (target_min, target_max) in self.target_ranges.items():\n            # Interpolate from no randomization to target range\n            center = 1.0\n            current_min = center - self.stage * (center - target_min)\n            current_max = center + self.stage * (target_max - center)\n\n            self.current_ranges[param] = (current_min, current_max)\n\n            # Update base randomizer\n            if param in self.base_rand.physics_ranges:\n                self.base_rand.physics_ranges[param] = RandomizationRange(\n                    current_min, current_max\n                )\n            elif param in self.base_rand.dynamics_ranges:\n                self.base_rand.dynamics_ranges[param] = RandomizationRange(\n                    current_min, current_max\n                )\n\n    def advance_curriculum(self, success_rate: float, threshold: float = 0.8):\n        """\n        Advance curriculum if performance is good.\n\n        Args:\n            success_rate: Recent success rate\n            threshold: Required success rate to advance\n\n        Returns:\n            advanced: Whether curriculum was advanced\n        """\n```python\n```python\n        if success_rate >= threshold and self.stage < 1.0:\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"            self.stage = min(1.0, self.stage + self.stage_increment)\n            self._update_ranges()\n            return True\n        return False\n\n```python\n```python\n    def get_stage_info(self) -> dict:\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"        \"\"\"Get current curriculum information.\"\"\"\n        return {\n            'stage': self.stage,\n            'ranges': self.current_ranges.copy()\n        }\n\n# Test curriculum\ncurriculum = CurriculumRandomizer(randomizer)\n\nprint(\"Curriculum progression:\")\nfor i in range(12):\n    info = curriculum.get_stage_info()\n    print(f\"Stage {info['stage']:.1f}: mass_scale range = {info['ranges']['mass_scale']}\")\n\n    # Simulate advancement\n    curriculum.advance_curriculum(success_rate=0.85)\n"})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Expected"}),": Curriculum progressively increases randomization range."]})}),"\n",(0,r.jsx)(e.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,r.jsx)(e.p,{children:"After completing this lab, you should have:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Code artifacts"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"domain_randomizer.py"}),": Physics and dynamics randomization"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"visual_randomizer.py"}),": Image augmentation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"sensor_noise.py"}),": Sensor noise models"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"curriculum.py"}),": Progressive curriculum"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Understanding"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Types of domain randomization"}),"\n",(0,r.jsx)(e.li,{children:"Distribution selection for parameters"}),"\n",(0,r.jsx)(e.li,{children:"Robustness analysis methods"}),"\n",(0,r.jsx)(e.li,{children:"Curriculum design principles"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"rubric",children:"Rubric"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Criterion"}),(0,r.jsx)(e.th,{children:"Points"}),(0,r.jsx)(e.th,{children:"Description"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Physics Randomization"}),(0,r.jsx)(e.td,{children:"25"}),(0,r.jsx)(e.td,{children:"Mass, friction, damping variation"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Visual Randomization"}),(0,r.jsx)(e.td,{children:"20"}),(0,r.jsx)(e.td,{children:"Image augmentation pipeline"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Sensor Noise"}),(0,r.jsx)(e.td,{children:"20"}),(0,r.jsx)(e.td,{children:"Realistic noise models"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Robustness Analysis"}),(0,r.jsx)(e.td,{children:"20"}),(0,r.jsx)(e.td,{children:"Parameter sweep evaluation"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Curriculum"}),(0,r.jsx)(e.td,{children:"15"}),(0,r.jsx)(e.td,{children:"Progressive randomization"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Total"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"100"})}),(0,r.jsx)(e.td,{})]})]})]}),"\n",(0,r.jsx)(e.h2,{id:"common-errors",children:"Common Errors"}),"\n",(0,r.jsxs)("troubleshooting",{children:[(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Error"}),": Simulation unstable after randomization\n",(0,r.jsx)(e.strong,{children:"Solution"}),": Limit extreme parameter values, check physics timestep."]}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Error"}),": Training doesn't converge with randomization\n",(0,r.jsx)(e.strong,{children:"Solution"}),": Start with smaller ranges, use curriculum."]}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Error"}),": Visual randomization too aggressive\n",(0,r.jsx)(e.strong,{children:"Solution"}),": Tune brightness/contrast ranges based on task."]})]}),"\n",(0,r.jsx)(e.h2,{id:"extensions",children:"Extensions"}),"\n",(0,r.jsx)(e.p,{children:"For advanced students:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Automatic Domain Randomization (ADR)"}),": Adapt ranges based on performance"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Adversarial Randomization"}),": Find hardest parameter combinations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Multi-Task Randomization"}),": Different randomization per task"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Real2Sim"}),": Estimate real-world parameters for calibration"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"related-content",children:"Related Content"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Theory"}),": Module 10 theory.md, Section 10.1 (Domain Gap)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Next Lab"}),": Lab 10-02 (System Identification)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Application"}),": Sim-to-real robot transfer"]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}}}]);