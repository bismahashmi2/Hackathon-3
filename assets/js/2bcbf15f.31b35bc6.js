"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[1778],{8453(e,n,t){t.d(n,{R:()=>s,x:()=>l});var o=t(6540);const r={},i=o.createContext(r);function s(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}},8642(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"textbook/modules/introduction-physical-ai/labs/lab-01-03","title":"Basic Actuation and Control","description":"Objectives","source":"@site/docs/textbook/modules/01-introduction-physical-ai/labs/lab-01-03.md","sourceDirName":"textbook/modules/01-introduction-physical-ai/labs","slug":"/textbook/modules/introduction-physical-ai/labs/lab-01-03","permalink":"/Hackathon-3/docs/textbook/modules/introduction-physical-ai/labs/lab-01-03","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/01-introduction-physical-ai/labs/lab-01-03.md","tags":[],"version":"current","frontMatter":{"id":"lab-01-03","module_id":"01","title":"Basic Actuation and Control","difficulty":"intermediate","tier":"simulation","duration_minutes":75,"submission_format":"notebook","auto_gradable":true},"sidebar":"tutorialSidebar","previous":{"title":"Exploring the Humanoid Model","permalink":"/Hackathon-3/docs/textbook/modules/introduction-physical-ai/labs/lab-01-02"},"next":{"title":"Introduction to Physical AI","permalink":"/Hackathon-3/docs/textbook/modules/introduction-physical-ai/introduction-physical-ai"}}');var r=t(4848),i=t(8453);const s={id:"lab-01-03",module_id:"01",title:"Basic Actuation and Control",difficulty:"intermediate",tier:"simulation",duration_minutes:75,submission_format:"notebook",auto_gradable:!0},l="Lab 01-03: Basic Actuation and Control",a={},d=[{value:"Objectives",id:"objectives",level:2},{value:"Materials",id:"materials",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Understand Control Modes",id:"step-1-understand-control-modes",level:3},{value:"Step 2: Implement Proportional-Derivative (PD) Control",id:"step-2-implement-proportional-derivative-pd-control",level:3},{value:"Step 3: Test the Controller",id:"step-3-test-the-controller",level:3},{value:"Step 4: Tune Controller Gains",id:"step-4-tune-controller-gains",level:3},{value:"Step 5: Create a Pose Sequence",id:"step-5-create-a-pose-sequence",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2},{value:"Discussion Questions",id:"discussion-questions",level:2},{value:"Extensions",id:"extensions",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"lab-01-03-basic-actuation-and-control",children:"Lab 01-03: Basic Actuation and Control"})}),"\n",(0,r.jsx)(n.h2,{id:"objectives",children:"Objectives"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement position-based joint control"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understand the difference between torque and position control"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Create a simple pose controller for the humanoid"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Analyze control performance with different gains"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"materials",children:"Materials"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Name"}),(0,r.jsx)(n.th,{children:"Version"}),(0,r.jsx)(n.th,{children:"Tier"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"software"}),(0,r.jsx)(n.td,{children:"Python"}),(0,r.jsx)(n.td,{children:"3.10+"}),(0,r.jsx)(n.td,{children:"required"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"software"}),(0,r.jsx)(n.td,{children:"MuJoCo"}),(0,r.jsx)(n.td,{children:"3.0+"}),(0,r.jsx)(n.td,{children:"required"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"software"}),(0,r.jsx)(n.td,{children:"NumPy"}),(0,r.jsx)(n.td,{children:"1.24+"}),(0,r.jsx)(n.td,{children:"required"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"software"}),(0,r.jsx)(n.td,{children:"Matplotlib"}),(0,r.jsx)(n.td,{children:"3.5+"}),(0,r.jsx)(n.td,{children:"required"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Completion of Lab 01-01 and Lab 01-02"}),"\n",(0,r.jsx)(n.li,{children:"Understanding of joint/actuator mapping"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"instructions",children:"Instructions"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-understand-control-modes",children:"Step 1: Understand Control Modes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import mujoco\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load model\nmodel = mujoco.MjModel.from_xml_path(\n    mujoco.util.get_resource_path("humanoid/humanoid.xml")\n)\ndata = mujoco.MjData(model)\n\n# The humanoid model uses torque control by default\n# Control signal in data.ctrl directly sets joint torques\nprint("Control dimensions:", model.nu)\nprint("Control range:")\nfor i in range(min(5, model.nu)):\n    name = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_ACTUATOR, i)\n    print(f"  {name}: [{model.actuator_ctrlrange[i, 0]:.1f}, "\n          f"{model.actuator_ctrlrange[i, 1]:.1f}]")\n'})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Verification"}),": Control range should show torque limits (typically \xb1100 or similar)."]})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-implement-proportional-derivative-pd-control",children:"Step 2: Implement Proportional-Derivative (PD) Control"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class PDController:\n    """\n    PD controller for position control of joints.\n\n    Args:\n        kp: Proportional gain (stiffness)\n        kd: Derivative gain (damping)\n    """\n\n    def __init__(self, kp: float = 100.0, kd: float = 10.0):\n        self.kp = kp\n        self.kd = kd\n        self.target_qpos = None\n\n    def set_target(self, target_qpos: np.ndarray):\n        """Set target joint positions."""\n        self.target_qpos = target_qpos.copy()\n\n```python\n```python\n    def compute(self, model, data) -> np.ndarray:\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'        """\n        Compute control torques using PD control.\n\n        Returns:\n            Control signal (torques) for all actuators\n        """\n        if self.target_qpos is None:\n            return np.zeros(model.nu)\n\n        # Get current joint positions and velocities\n        # Skip the free joint (first 7 qpos elements, 6 qvel elements)\n        current_qpos = data.qpos[7:7 + model.nu]\n        current_qvel = data.qvel[6:6 + model.nu]\n\n        # Compute error\n        pos_error = self.target_qpos - current_qpos\n        vel_error = -current_qvel  # Target velocity is zero\n\n        # PD control law: tau = Kp * (q_target - q) + Kd * (0 - q_dot)\n        torques = self.kp * pos_error + self.kd * vel_error\n\n        # Clip to actuator limits\n        for i in range(model.nu):\n            torques[i] = np.clip(\n                torques[i],\n                model.actuator_ctrlrange[i, 0],\n                model.actuator_ctrlrange[i, 1]\n            )\n\n        return torques\n\n# Create controller\ncontroller = PDController(kp=100.0, kd=10.0)\n\n# Set target to initial pose (standing)\ninitial_pose = np.zeros(model.nu)\ncontroller.set_target(initial_pose)\n'})}),"\n",(0,r.jsxs)("checkpoint",{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Understanding Check"}),": Can you explain why we need both P and D terms?"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"P term: Drives the joint toward the target position"}),"\n",(0,r.jsx)(n.li,{children:"D term: Prevents overshoot and oscillation"}),"\n"]})]}),"\n",(0,r.jsx)(n.h3,{id:"step-3-test-the-controller",children:"Step 3: Test the Controller"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Reset simulation\nmujoco.mj_resetData(model, data)\n\n# Perturb the initial state (drop from height)\ndata.qpos[2] = 1.5  # Start higher\n\n# Simulation parameters\nduration = 5.0\ndt = model.opt.timestep\n\n# Data recording\ntimes = []\nheights = []\njoint_errors = []\n\n# Run simulation\n```python\n```python\nwhile data.time < duration:\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"    # Compute control\n    data.ctrl[:] = controller.compute(model, data)\n\n    # Step simulation\n    mujoco.mj_step(model, data)\n\n    # Record data\n    times.append(data.time)\n    heights.append(data.qpos[2])  # Height of root body\n\n    # Compute joint position error\n    current_qpos = data.qpos[7:7 + model.nu]\n    error = np.linalg.norm(controller.target_qpos - current_qpos)\n    joint_errors.append(error)\n\n# Plot results\nfig, axes = plt.subplots(2, 1, figsize=(10, 8))\n\naxes[0].plot(times, heights)\naxes[0].set_ylabel('Height (m)')\naxes[0].set_title('Humanoid Height Over Time')\naxes[0].grid(True, alpha=0.3)\naxes[0].axhline(y=1.4, color='r', linestyle='--', label='Target height')\naxes[0].legend()\n\naxes[1].plot(times, joint_errors)\naxes[1].set_xlabel('Time (s)')\naxes[1].set_ylabel('Joint Error (rad)')\naxes[1].set_title('Total Joint Position Error')\naxes[1].grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('pd_control_results.png', dpi=150)\nplt.show()\n"})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Expected"}),": The humanoid should attempt to maintain its pose.\n",(0,r.jsx)(n.strong,{children:"Analysis"}),": Note that PD control alone cannot keep the humanoid standing (no balance)."]})}),"\n",(0,r.jsx)(n.h3,{id:"step-4-tune-controller-gains",children:"Step 4: Tune Controller Gains"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def evaluate_gains(kp, kd, duration=3.0):\n    """Evaluate controller with given gains."""\n    mujoco.mj_resetData(model, data)\n    data.qpos[2] = 1.5\n\n    ctrl = PDController(kp=kp, kd=kd)\n    ctrl.set_target(np.zeros(model.nu))\n\n    errors = []\n```python\n```python\n    while data.time < duration:\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'        data.ctrl[:] = ctrl.compute(model, data)\n        mujoco.mj_step(model, data)\n        current_qpos = data.qpos[7:7 + model.nu]\n        errors.append(np.linalg.norm(ctrl.target_qpos - current_qpos))\n\n    return np.mean(errors), np.max(errors)\n\n# Test different gain combinations\nkp_values = [50, 100, 200, 400]\nkd_values = [5, 10, 20, 40]\n\nprint("Gain Tuning Results:")\nprint("-" * 50)\nprint(f"{\'Kp\':>8} {\'Kd\':>8} {\'Mean Error\':>12} {\'Max Error\':>12}")\nprint("-" * 50)\n\nresults = []\nfor kp in kp_values:\n    for kd in kd_values:\n        mean_err, max_err = evaluate_gains(kp, kd)\n        results.append((kp, kd, mean_err, max_err))\n        print(f"{kp:>8} {kd:>8} {mean_err:>12.4f} {max_err:>12.4f}")\n\n# Find best combination\nbest = min(results, key=lambda x: x[2])\nprint(f"\\nBest gains: Kp={best[0]}, Kd={best[1]} (Mean error: {best[2]:.4f})")\n'})}),"\n",(0,r.jsxs)("checkpoint",{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Analysis Questions"}),":"]}),(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"How does increasing Kp affect response speed and overshoot?"}),"\n",(0,r.jsx)(n.li,{children:"How does Kd help stabilize the system?"}),"\n",(0,r.jsx)(n.li,{children:"What happens if Kd is too high?"}),"\n"]})]}),"\n",(0,r.jsx)(n.h3,{id:"step-5-create-a-pose-sequence",children:"Step 5: Create a Pose Sequence"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Define a simple arm wave motion\ndef create_wave_sequence(model, num_frames=100):\n    """Create a sequence of poses for arm waving."""\n    poses = []\n\n    for i in range(num_frames):\n        pose = np.zeros(model.nu)\n\n        # Find right shoulder actuator\n        shoulder_id = mujoco.mj_name2id(\n            model, mujoco.mjtObj.mjOBJ_ACTUATOR, "right_shoulder1"\n        )\n\n```python\n```python\n        if shoulder_id >= 0:\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"            # Sinusoidal motion\n            angle = np.sin(2 * np.pi * i / num_frames) * 0.5\n            # Note: We're setting target, not directly controlling\n            pose[shoulder_id] = angle\n\n        poses.append(pose)\n\n    return poses\n\n# Generate poses\nwave_poses = create_wave_sequence(model)\n\n# Run the wave animation\nmujoco.mj_resetData(model, data)\ncontroller = PDController(kp=200.0, kd=20.0)\n\n# Optional: Launch viewer for visualization\ntry:\n    with mujoco.viewer.launch_passive(model, data) as viewer:\n        pose_idx = 0\n```python\n```python\n        while viewer.is_running() and data.time < 5.0:\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'            # Update target pose\n            pose_idx = int(data.time * 20) % len(wave_poses)\n            controller.set_target(wave_poses[pose_idx])\n\n            # Apply control\n            data.ctrl[:] = controller.compute(model, data)\n\n            # Step simulation\n            mujoco.mj_step(model, data)\n            viewer.sync()\n\nexcept Exception as e:\n    print(f"Viewer not available: {e}")\n    print("Running headless simulation...")\n\n    for _ in range(2500):\n        pose_idx = int(data.time * 20) % len(wave_poses)\n        controller.set_target(wave_poses[pose_idx])\n        data.ctrl[:] = controller.compute(model, data)\n        mujoco.mj_step(model, data)\n\n    print("Simulation complete")\n'})}),"\n",(0,r.jsx)("checkpoint",{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Final Verification"}),": The humanoid should perform an arm waving motion.\n",(0,r.jsx)(n.strong,{children:"Note"}),": Due to lack of balance control, it will still fall, but the arm should wave."]})}),"\n",(0,r.jsx)(n.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Working PD controller implementation"}),"\n",(0,r.jsx)(n.li,{children:"Understanding of gain tuning effects"}),"\n",(0,r.jsx)(n.li,{children:"Gain tuning results table"}),"\n",(0,r.jsxs)(n.li,{children:["Control performance visualization (",(0,r.jsx)(n.code,{children:"pd_control_results.png"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Simple pose sequence implementation"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"rubric",children:"Rubric"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Criterion"}),(0,r.jsx)(n.th,{children:"Points"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"PD Implementation"}),(0,r.jsx)(n.td,{children:"25"}),(0,r.jsx)(n.td,{children:"Correctly implements PD control law"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Gain Tuning"}),(0,r.jsx)(n.td,{children:"25"}),(0,r.jsx)(n.td,{children:"Systematically tests and analyzes gains"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Error Analysis"}),(0,r.jsx)(n.td,{children:"20"}),(0,r.jsx)(n.td,{children:"Meaningful analysis of control performance"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Pose Sequence"}),(0,r.jsx)(n.td,{children:"20"}),(0,r.jsx)(n.td,{children:"Successfully creates and runs pose sequence"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Documentation"}),(0,r.jsx)(n.td,{children:"10"}),(0,r.jsx)(n.td,{children:"Clear explanations and comments"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Total: 100 points"})}),"\n",(0,r.jsx)(n.h2,{id:"discussion-questions",children:"Discussion Questions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Why doesn't PD control alone keep the humanoid standing?"}),"\n",(0,r.jsx)(n.li,{children:"What additional control strategies would be needed for balance?"}),"\n",(0,r.jsx)(n.li,{children:"How would you modify the controller for trajectory tracking vs. pose holding?"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"extensions",children:"Extensions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gravity Compensation"}),": Add feedforward term to compensate for gravity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trajectory Tracking"}),": Implement smooth interpolation between poses"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multiple Joints"}),": Create a coordinated multi-joint motion (e.g., walking step)"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);