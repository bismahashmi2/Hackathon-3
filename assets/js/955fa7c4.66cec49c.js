"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[4181],{2859(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"textbook/modules/motion-planning/labs/lab-06-01","title":"RRT Path Planning","description":"Objectives","source":"@site/docs/textbook/modules/06-motion-planning/labs/lab-06-01.md","sourceDirName":"textbook/modules/06-motion-planning/labs","slug":"/textbook/modules/motion-planning/labs/lab-06-01","permalink":"/Hackathon-3/docs/textbook/modules/motion-planning/labs/lab-06-01","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/06-motion-planning/labs/lab-06-01.md","tags":[],"version":"current","frontMatter":{"id":"lab-06-01","module_id":"06","title":"RRT Path Planning","difficulty":"guided","tier":"simulation","duration_minutes":75},"sidebar":"tutorialSidebar","previous":{"title":"Ethics in Motion Planning","permalink":"/Hackathon-3/docs/textbook/modules/motion-planning/ethics"},"next":{"title":"A* Path Planning with Heuristics","permalink":"/Hackathon-3/docs/textbook/modules/motion-planning/labs/lab-06-02"}}');var o=t(4848),s=t(8453);const r={id:"lab-06-01",module_id:"06",title:"RRT Path Planning",difficulty:"guided",tier:"simulation",duration_minutes:75},a="Lab 06-01: RRT Path Planning",l={},d=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"Rapidly-exploring Random Trees (RRT)",id:"rapidly-exploring-random-trees-rrt",level:3},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Set Up the Environment",id:"step-1-set-up-the-environment",level:3},{value:"Step 2: Collision Checking",id:"step-2-collision-checking",level:3},{value:"Step 3: Implement RRT Core Algorithm",id:"step-3-implement-rrt-core-algorithm",level:3},{value:"Step 4: Visualize Tree and Path",id:"step-4-visualize-tree-and-path",level:3},{value:"Step 5: Path Smoothing",id:"step-5-path-smoothing",level:3},{value:"Step 6: Execute Path in Simulation",id:"step-6-execute-path-in-simulation",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2},{value:"Common Errors",id:"common-errors",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Related Content",id:"related-content",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"lab-06-01-rrt-path-planning",children:"Lab 06-01: RRT Path Planning"})}),"\n",(0,o.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this lab, you will be able to:"}),"\n",(0,o.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Implement the Rapidly-exploring Random Tree (RRT) algorithm"]}),"\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Understand collision checking in configuration space"]}),"\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Visualize tree growth and path extraction"]}),"\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Apply RRT to robot arm motion planning"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Completed Module 03 (Kinematics)"}),"\n",(0,o.jsx)(e.li,{children:"Understanding of configuration space concepts"}),"\n",(0,o.jsx)(e.li,{children:"Python programming with NumPy"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"materials",children:"Materials"}),"\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"Type"}),(0,o.jsx)(e.th,{children:"Name"}),(0,o.jsx)(e.th,{children:"Tier"}),(0,o.jsx)(e.th,{children:"Notes"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"software"}),(0,o.jsx)(e.td,{children:"MuJoCo 3.0+"}),(0,o.jsx)(e.td,{children:"required"}),(0,o.jsx)(e.td,{children:"Physics simulation and collision"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"software"}),(0,o.jsx)(e.td,{children:"Python 3.10+"}),(0,o.jsx)(e.td,{children:"required"}),(0,o.jsx)(e.td,{children:"Programming environment"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"software"}),(0,o.jsx)(e.td,{children:"NumPy, Matplotlib"}),(0,o.jsx)(e.td,{children:"required"}),(0,o.jsx)(e.td,{children:"Computation and visualization"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"simulation"}),(0,o.jsx)(e.td,{children:"2dof-arm-obstacles.xml"}),(0,o.jsx)(e.td,{children:"required"}),(0,o.jsx)(e.td,{children:"Arm with obstacle environment"})]})]})]}),"\n",(0,o.jsx)(e.h2,{id:"background",children:"Background"}),"\n",(0,o.jsx)(e.h3,{id:"rapidly-exploring-random-trees-rrt",children:"Rapidly-exploring Random Trees (RRT)"}),"\n",(0,o.jsx)(e.p,{children:"RRT is a sampling-based planner that builds a tree of configurations:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Sample a random configuration q_rand"}),"\n",(0,o.jsx)(e.li,{children:"Find the nearest node in the tree q_near"}),"\n",(0,o.jsx)(e.li,{children:"Extend from q_near toward q_rand by distance \u03b4"}),"\n",(0,o.jsx)(e.li,{children:"If the extension is collision-free, add to tree"}),"\n",(0,o.jsx)(e.li,{children:"Repeat until goal is reached"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"RRT is probabilistically complete but not optimal. Extensions like RRT* add rewiring for asymptotic optimality."}),"\n",(0,o.jsx)(e.h2,{id:"instructions",children:"Instructions"}),"\n",(0,o.jsx)(e.h3,{id:"step-1-set-up-the-environment",children:"Step 1: Set Up the Environment"}),"\n",(0,o.jsx)(e.p,{children:"Load a model with obstacles:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import mujoco\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle, Circle\n\n# Load model with obstacles\nmodel = mujoco.MjModel.from_xml_path("textbook/assets/robot-models/mujoco/2dof-arm-obstacles.xml")\ndata = mujoco.MjData(model)\n\n# Robot parameters\nn_joints = model.njnt\njoint_limits = model.jnt_range[:n_joints].copy()\n\nprint(f"Joint limits:")\nfor i in range(n_joints):\n    print(f"  Joint {i}: [{np.degrees(joint_limits[i, 0]):.1f}, {np.degrees(joint_limits[i, 1]):.1f}] deg")\n\n# Link lengths (for visualization)\nlink_lengths = [0.5, 0.4]  # meters\n'})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": Joint limits loaded from model (e.g., \xb1180\xb0 for each joint)."]})}),"\n",(0,o.jsx)(e.h3,{id:"step-2-collision-checking",children:"Step 2: Collision Checking"}),"\n",(0,o.jsx)(e.p,{children:"Implement collision detection using MuJoCo:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def check_collision(model, data, q):\n    """\n    Check if configuration q is in collision.\n\n    Args:\n        model, data: MuJoCo model and data\n        q: Joint configuration [q0, q1, ...]\n\n    Returns:\n        True if in collision, False otherwise\n    """\n    # Set configuration\n    data.qpos[:len(q)] = q\n    data.qvel[:] = 0\n\n    # Forward kinematics to update geometry\n    mujoco.mj_forward(model, data)\n\n    # Check contacts\n    n_contacts = data.ncon\n```python\n```python\n    if n_contacts > 0:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'        # Filter self-collision (if needed)\n        for i in range(n_contacts):\n            contact = data.contact[i]\n            # Check if contact is with obstacle (not self-collision)\n            geom1 = contact.geom1\n            geom2 = contact.geom2\n            # You may need to filter based on geom names/types\n            return True\n    return False\n\ndef check_collision_simple(q, obstacles):\n    """\n    Simple geometric collision check for 2D arm.\n\n    Args:\n        q: [q0, q1] joint angles\n        obstacles: List of (x, y, radius) obstacles\n\n    Returns:\n        True if in collision\n    """\n    # Forward kinematics\n    l1, l2 = 0.5, 0.4\n    x1 = l1 * np.cos(q[0])\n    y1 = l1 * np.sin(q[0])\n    x2 = x1 + l2 * np.cos(q[0] + q[1])\n    y2 = y1 + l2 * np.sin(q[0] + q[1])\n\n    # Check line segments against obstacles\n    n_samples = 20\n    for obstacle in obstacles:\n        ox, oy, r = obstacle\n\n        # Check link 1\n        for t in np.linspace(0, 1, n_samples):\n            px, py = t * x1, t * y1\n```python\n```python\n            if (px - ox)**2 + (py - oy)**2 < r**2:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"                return True\n\n        # Check link 2\n        for t in np.linspace(0, 1, n_samples):\n            px = x1 + t * (x2 - x1)\n            py = y1 + t * (y2 - y1)\n```python\n```python\n            if (px - ox)**2 + (py - oy)**2 < r**2:\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'                return True\n\n    return False\n\n# Define obstacles\nobstacles = [\n    (0.4, 0.3, 0.1),   # (x, y, radius)\n    (0.2, 0.5, 0.08),\n    (-0.3, 0.4, 0.12)\n]\n\n# Test collision checking\ntest_config = np.array([0.5, 0.3])\nin_collision = check_collision_simple(test_config, obstacles)\nprint(f"Config {np.degrees(test_config)} in collision: {in_collision}")\n'})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": Collision checker returns True for configurations where arm intersects obstacles."]})}),"\n",(0,o.jsx)(e.h3,{id:"step-3-implement-rrt-core-algorithm",children:"Step 3: Implement RRT Core Algorithm"}),"\n",(0,o.jsx)(e.p,{children:"Build the RRT tree:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class RRTNode:\n    """Node in RRT tree."""\n\n    def __init__(self, q, parent=None):\n        self.q = np.array(q)\n        self.parent = parent\n        self.children = []\n\nclass RRT:\n    """Rapidly-exploring Random Tree planner."""\n\n    def __init__(self, q_start, q_goal, joint_limits, obstacles,\n                 step_size=0.1, goal_bias=0.1, max_iterations=5000):\n        """\n        Initialize RRT.\n\n        Args:\n            q_start: Start configuration\n            q_goal: Goal configuration\n            joint_limits: (n, 2) array of [min, max] per joint\n            obstacles: List of obstacles\n            step_size: Maximum extension step (radians)\n            goal_bias: Probability of sampling goal\n            max_iterations: Maximum tree growth iterations\n        """\n        self.q_start = np.array(q_start)\n        self.q_goal = np.array(q_goal)\n        self.joint_limits = np.array(joint_limits)\n        self.obstacles = obstacles\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.max_iterations = max_iterations\n\n        # Tree\n        self.root = RRTNode(q_start)\n        self.nodes = [self.root]\n\n    def sample_random(self):\n        """Sample random configuration (with goal bias)."""\n```python\n```python\n        if np.random.random() < self.goal_bias:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'            return self.q_goal.copy()\n        else:\n            q = np.zeros(len(self.q_start))\n            for i in range(len(q)):\n                q[i] = np.random.uniform(self.joint_limits[i, 0],\n                                         self.joint_limits[i, 1])\n            return q\n\n    def nearest(self, q):\n        """Find nearest node in tree."""\n        min_dist = float(\'inf\')\n        nearest_node = None\n        for node in self.nodes:\n            dist = np.linalg.norm(node.q - q)\n```python\n```python\n            if dist < min_dist:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'                min_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def steer(self, q_from, q_to):\n        """Steer from q_from toward q_to by step_size."""\n        direction = q_to - q_from\n        dist = np.linalg.norm(direction)\n```python\n```python\n        if dist < self.step_size:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'            return q_to.copy()\n        else:\n            return q_from + direction / dist * self.step_size\n\n    def is_collision_free(self, q1, q2, n_checks=10):\n        """Check if path from q1 to q2 is collision-free."""\n        for t in np.linspace(0, 1, n_checks):\n            q = q1 + t * (q2 - q1)\n            if check_collision_simple(q, self.obstacles):\n                return False\n        return True\n\n    def plan(self):\n        """\n        Build tree and find path to goal.\n\n        Returns:\n            path: List of configurations from start to goal, or None if failed\n        """\n        goal_threshold = 0.1  # radians\n\n        for i in range(self.max_iterations):\n            # Sample\n            q_rand = self.sample_random()\n\n            # Find nearest\n            q_near_node = self.nearest(q_rand)\n\n            # Steer\n            q_new = self.steer(q_near_node.q, q_rand)\n\n            # Check collision\n            if self.is_collision_free(q_near_node.q, q_new):\n                # Add node\n                new_node = RRTNode(q_new, parent=q_near_node)\n                q_near_node.children.append(new_node)\n                self.nodes.append(new_node)\n\n                # Check if goal reached\n```python\n```python\n                if np.linalg.norm(q_new - self.q_goal) < goal_threshold:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'                    # Try to connect directly to goal\n                    if self.is_collision_free(q_new, self.q_goal):\n                        goal_node = RRTNode(self.q_goal, parent=new_node)\n                        new_node.children.append(goal_node)\n                        self.nodes.append(goal_node)\n                        print(f"Goal reached in {i+1} iterations!")\n                        return self.extract_path(goal_node)\n\n        print(f"Failed to find path in {self.max_iterations} iterations")\n        return None\n\n    def extract_path(self, goal_node):\n        """Extract path from root to goal."""\n        path = []\n        node = goal_node\n        while node is not None:\n            path.append(node.q)\n            node = node.parent\n        return path[::-1]  # Reverse to get start\u2192goal order\n\n# Define problem\nq_start = np.array([0.0, 0.0])\nq_goal = np.array([np.pi/2, -np.pi/4])\n\n# Run RRT\nrrt = RRT(q_start, q_goal, joint_limits, obstacles,\n          step_size=0.15, goal_bias=0.1, max_iterations=3000)\n\npath = rrt.plan()\nif path:\n    print(f"Path found with {len(path)} waypoints")\n    print(f"Tree has {len(rrt.nodes)} nodes")\n'})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": RRT finds a collision-free path from start to goal."]})}),"\n",(0,o.jsx)(e.h3,{id:"step-4-visualize-tree-and-path",children:"Step 4: Visualize Tree and Path"}),"\n",(0,o.jsx)(e.p,{children:"Create visualization in both configuration space and workspace:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"def forward_kinematics(q, link_lengths=[0.5, 0.4]):\n    \"\"\"Compute end-effector and joint positions.\"\"\"\n    positions = [(0, 0)]\n    x, y = 0, 0\n    angle = 0\n    for i, (qi, l) in enumerate(zip(q, link_lengths)):\n        angle += qi\n        x += l * np.cos(angle)\n        y += l * np.sin(angle)\n        positions.append((x, y))\n    return positions\n\ndef plot_rrt_results(rrt, path, obstacles):\n    \"\"\"Visualize RRT in C-space and workspace.\"\"\"\n    fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n\n    # C-space plot\n    ax = axes[0]\n\n    # Plot tree edges\n    for node in rrt.nodes:\n        if node.parent is not None:\n            ax.plot([node.parent.q[0], node.q[0]],\n                   [node.parent.q[1], node.q[1]],\n                   'b-', alpha=0.3, linewidth=0.5)\n\n    # Plot nodes\n    q_nodes = np.array([n.q for n in rrt.nodes])\n    ax.scatter(q_nodes[:, 0], q_nodes[:, 1], s=5, c='blue', alpha=0.5)\n\n    # Plot path\n    if path:\n        path_array = np.array(path)\n        ax.plot(path_array[:, 0], path_array[:, 1], 'r-', linewidth=3, label='Path')\n\n    ax.scatter([rrt.q_start[0]], [rrt.q_start[1]], s=100, c='green', marker='s', label='Start')\n    ax.scatter([rrt.q_goal[0]], [rrt.q_goal[1]], s=100, c='red', marker='*', label='Goal')\n\n    ax.set_xlabel('q1 (rad)')\n    ax.set_ylabel('q2 (rad)')\n    ax.set_title(f'C-Space: RRT Tree ({len(rrt.nodes)} nodes)')\n    ax.legend()\n    ax.set_aspect('equal')\n    ax.grid(True)\n\n    # Workspace plot\n    ax = axes[1]\n\n    # Draw obstacles\n    for (ox, oy, r) in obstacles:\n        circle = Circle((ox, oy), r, color='gray', alpha=0.7)\n        ax.add_patch(circle)\n\n    # Draw arm at start\n    start_pos = forward_kinematics(rrt.q_start)\n    ax.plot([p[0] for p in start_pos], [p[1] for p in start_pos],\n            'g-', linewidth=3, label='Start pose')\n\n    # Draw arm at goal\n    goal_pos = forward_kinematics(rrt.q_goal)\n    ax.plot([p[0] for p in goal_pos], [p[1] for p in goal_pos],\n            'r--', linewidth=3, label='Goal pose')\n\n    # Draw path waypoints\n    if path:\n        for i, q in enumerate(path):\n            pos = forward_kinematics(q)\n            alpha = 0.2 + 0.8 * i / len(path)\n            ax.plot([p[0] for p in pos], [p[1] for p in pos],\n                    'b-', alpha=alpha, linewidth=1)\n\n    ax.set_xlabel('X (m)')\n    ax.set_ylabel('Y (m)')\n    ax.set_title('Workspace: Arm Configuration')\n    ax.set_xlim(-1.0, 1.0)\n    ax.set_ylim(-1.0, 1.0)\n    ax.set_aspect('equal')\n    ax.legend()\n    ax.grid(True)\n\n    plt.tight_layout()\n    plt.savefig('rrt_results.png', dpi=150)\n    plt.show()\n\nplot_rrt_results(rrt, path, obstacles)\n"})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": Two plots showing tree structure in C-space and arm motion in workspace."]})}),"\n",(0,o.jsx)(e.h3,{id:"step-5-path-smoothing",children:"Step 5: Path Smoothing"}),"\n",(0,o.jsx)(e.p,{children:"Smooth the path to remove unnecessary waypoints:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def smooth_path(path, obstacles, max_iterations=100):\n    """\n    Shortcut-based path smoothing.\n\n    Randomly picks two points and tries to connect them directly.\n    """\n```python\n```python\n    if not path or len(path) < 3:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"        return path\n\n    path = [np.array(q) for q in path]\n    smoothed = path.copy()\n\n    for _ in range(max_iterations):\n```python\n```python\n        if len(smoothed) < 3:\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"            break\n\n        # Pick two random indices\n        i = np.random.randint(0, len(smoothed) - 2)\n        j = np.random.randint(i + 2, len(smoothed))\n\n        # Check if direct connection is collision-free\n        collision_free = True\n        for t in np.linspace(0, 1, 20):\n            q = smoothed[i] + t * (smoothed[j] - smoothed[i])\n            if check_collision_simple(q, obstacles):\n                collision_free = False\n                break\n\n        if collision_free:\n            # Remove intermediate points\n            smoothed = smoothed[:i+1] + smoothed[j:]\n\n    return smoothed\n\n# Smooth the path\nsmoothed_path = smooth_path(path, obstacles, max_iterations=200)\nprint(f\"Original path: {len(path)} waypoints\")\nprint(f\"Smoothed path: {len(smoothed_path)} waypoints\")\n\n# Visualize comparison\nfig, ax = plt.subplots(figsize=(8, 8))\n\n# Draw obstacles\nfor (ox, oy, r) in obstacles:\n    circle = Circle((ox, oy), r, color='gray', alpha=0.7)\n    ax.add_patch(circle)\n\n# Draw original path\nfor q in path:\n    pos = forward_kinematics(q)\n    ax.plot([p[0] for p in pos], [p[1] for p in pos], 'b-', alpha=0.3, linewidth=1)\n\n# Draw smoothed path\nfor q in smoothed_path:\n    pos = forward_kinematics(q)\n    ax.plot([p[0] for p in pos], [p[1] for p in pos], 'r-', linewidth=2)\n\nax.set_xlabel('X (m)')\nax.set_ylabel('Y (m)')\nax.set_title('Path Smoothing Comparison')\nax.set_xlim(-1.0, 1.0)\nax.set_ylim(-1.0, 1.0)\nax.set_aspect('equal')\nax.grid(True)\n\nplt.savefig('path_smoothing.png', dpi=150)\nplt.show()\n"})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": Smoothed path has fewer waypoints but remains collision-free."]})}),"\n",(0,o.jsx)(e.h3,{id:"step-6-execute-path-in-simulation",children:"Step 6: Execute Path in Simulation"}),"\n",(0,o.jsx)(e.p,{children:"Execute the planned path using a simple controller:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def interpolate_path(path, num_points=100):\n    """Linearly interpolate path to get dense waypoints."""\n```python\n```python\n    if len(path) < 2:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"        return path\n\n    # Compute total path length\n    segments = []\n    for i in range(len(path) - 1):\n        dist = np.linalg.norm(np.array(path[i+1]) - np.array(path[i]))\n        segments.append(dist)\n    total_length = sum(segments)\n\n    # Generate interpolated points\n    interpolated = []\n    for i in range(len(path) - 1):\n        n_segment = max(2, int(num_points * segments[i] / total_length))\n```python\n```python\n        for t in np.linspace(0, 1, n_segment, endpoint=(i == len(path) - 2)):\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"            q = np.array(path[i]) + t * (np.array(path[i+1]) - np.array(path[i]))\n            interpolated.append(q)\n\n    return interpolated\n\ndef execute_path(model, data, path, kp=50, kd=10):\n    \"\"\"Execute path with simple PD control.\"\"\"\n    dt = model.opt.timestep\n    interpolated = interpolate_path(path, num_points=200)\n\n    trajectory = {\n        'time': [],\n        'position': [],\n        'target': [],\n        'torque': []\n    }\n\n    for i, target in enumerate(interpolated):\n        # Run for multiple steps per waypoint\n        for _ in range(5):\n            q = data.qpos[:2].copy()\n            qd = data.qvel[:2].copy()\n\n            # PD control\n            error = target - q\n            tau = kp * error - kd * qd\n            tau = np.clip(tau, -50, 50)\n\n            data.ctrl[:2] = tau\n            mujoco.mj_step(model, data)\n\n            trajectory['time'].append(data.time)\n            trajectory['position'].append(q.copy())\n            trajectory['target'].append(target.copy())\n            trajectory['torque'].append(tau.copy())\n\n    return trajectory\n\n# Execute the smoothed path\nmujoco.mj_resetData(model, data)\ndata.qpos[:2] = smoothed_path[0]\n\ntrajectory = execute_path(model, data, smoothed_path)\n\nprint(f\"Execution complete. Final position: {np.degrees(trajectory['position'][-1])} deg\")\nprint(f\"Target position: {np.degrees(smoothed_path[-1])} deg\")\n"})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": Robot follows path to reach goal configuration."]})}),"\n",(0,o.jsx)(e.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,o.jsx)(e.p,{children:"After completing this lab, you should have:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Code artifacts"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"rrt.py"}),": RRT planner implementation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"collision_check.py"}),": Collision checking utilities"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"path_smoothing.py"}),": Path post-processing"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Visual outputs"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"rrt_results.png"}),": Tree and path visualization"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"path_smoothing.png"}),": Before/after smoothing comparison"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Understanding"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Sampling-based planning principles"}),"\n",(0,o.jsx)(e.li,{children:"Configuration space vs. workspace"}),"\n",(0,o.jsx)(e.li,{children:"Trade-offs in RRT parameters"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"rubric",children:"Rubric"}),"\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"Criterion"}),(0,o.jsx)(e.th,{children:"Points"}),(0,o.jsx)(e.th,{children:"Description"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Collision Checking"}),(0,o.jsx)(e.td,{children:"15"}),(0,o.jsx)(e.td,{children:"Correct detection of arm-obstacle intersection"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"RRT Implementation"}),(0,o.jsx)(e.td,{children:"30"}),(0,o.jsx)(e.td,{children:"Proper sampling, steering, tree growth"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Path Finding"}),(0,o.jsx)(e.td,{children:"20"}),(0,o.jsx)(e.td,{children:"Successfully finds collision-free path"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Visualization"}),(0,o.jsx)(e.td,{children:"15"}),(0,o.jsx)(e.td,{children:"Clear C-space and workspace plots"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Path Smoothing"}),(0,o.jsx)(e.td,{children:"20"}),(0,o.jsx)(e.td,{children:"Reduces waypoints while maintaining collision-free"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:(0,o.jsx)(e.strong,{children:"Total"})}),(0,o.jsx)(e.td,{children:(0,o.jsx)(e.strong,{children:"100"})}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.h2,{id:"common-errors",children:"Common Errors"}),"\n",(0,o.jsxs)("troubleshooting",{children:[(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Error"}),": RRT takes too long or fails to find path\n",(0,o.jsx)(e.strong,{children:"Solution"}),": Increase step_size, increase goal_bias, or increase max_iterations."]}),(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Error"}),": Path appears to go through obstacles\n",(0,o.jsx)(e.strong,{children:"Solution"}),": Increase n_checks in collision checking, or check collision geometry."]}),(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Error"}),": Smoothed path collides with obstacles\n",(0,o.jsx)(e.strong,{children:"Solution"}),": Increase interpolation density in smoothing collision check."]})]}),"\n",(0,o.jsx)(e.h2,{id:"extensions",children:"Extensions"}),"\n",(0,o.jsx)(e.p,{children:"For advanced students:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"RRT"}),"*: Add rewiring for asymptotic optimality"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Bidirectional RRT"}),": Grow trees from start and goal"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Informed RRT"}),"*: Use ellipsoidal sampling after first solution"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Higher-dimensional planning"}),": Extend to 6-DOF robot arm"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"related-content",children:"Related Content"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Theory"}),": Module 06 theory.md, Section 6.2 (Sampling-Based Planning)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Next Lab"}),": Lab 06-02 (A* with Heuristics)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Application"}),": See Amazon Digit case study for warehouse navigation planning"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},8453(n,e,t){t.d(e,{R:()=>r,x:()=>a});var i=t(6540);const o={},s=i.createContext(o);function r(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);