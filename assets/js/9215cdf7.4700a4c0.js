"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[504],{2720(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"textbook/modules/locomotion/labs/lab-08-02","title":"Walking Gait Generation","description":"Objectives","source":"@site/docs/textbook/modules/08-locomotion/labs/lab-08-02.md","sourceDirName":"textbook/modules/08-locomotion/labs","slug":"/textbook/modules/locomotion/labs/lab-08-02","permalink":"/Hackathon-3/docs/textbook/modules/locomotion/labs/lab-08-02","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/08-locomotion/labs/lab-08-02.md","tags":[],"version":"current","frontMatter":{"id":"lab-08-02","module_id":"08","title":"Walking Gait Generation","difficulty":"intermediate","tier":"simulation","duration_minutes":90},"sidebar":"tutorialSidebar","previous":{"title":"Bipedal Balance and Standing","permalink":"/Hackathon-3/docs/textbook/modules/locomotion/labs/lab-08-01"},"next":{"title":"Dynamic Locomotion and Running","permalink":"/Hackathon-3/docs/textbook/modules/locomotion/labs/lab-08-03"}}');var i=t(4848),r=t(8453);const o={id:"lab-08-02",module_id:"08",title:"Walking Gait Generation",difficulty:"intermediate",tier:"simulation",duration_minutes:90},l="Lab 08-02: Walking Gait Generation",a={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"Walking as Controlled Falling",id:"walking-as-controlled-falling",level:3},{value:"ZMP Preview Control",id:"zmp-preview-control",level:3},{value:"Walking Phases",id:"walking-phases",level:3},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Set Up Walking Model",id:"step-1-set-up-walking-model",level:3},{value:"Step 2: Implement Footstep Planner",id:"step-2-implement-footstep-planner",level:3},{value:"Step 3: Generate ZMP Trajectory",id:"step-3-generate-zmp-trajectory",level:3},{value:"Step 4: Compute CoM Trajectory (Preview Control)",id:"step-4-compute-com-trajectory-preview-control",level:3},{value:"Step 5: Generate Swing Leg Trajectories",id:"step-5-generate-swing-leg-trajectories",level:3},{value:"Step 6: Execute Walking Simulation",id:"step-6-execute-walking-simulation",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2},{value:"Common Errors",id:"common-errors",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Related Content",id:"related-content",level:2}];function d(e){const n={annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mover:"mover",mrow:"mrow",msub:"msub",msup:"msup",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"lab-08-02-walking-gait-generation",children:"Lab 08-02: Walking Gait Generation"})}),"\n",(0,i.jsx)(n.h2,{id:"objectives",children:"Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this lab, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Generate walking trajectories using LIPM-based ZMP planning"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement footstep planning with desired velocity"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Create swing leg trajectories using polynomial interpolation"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Execute basic walking gaits in simulation"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Completed Lab 08-01 (Balance and Standing)"}),"\n",(0,i.jsx)(n.li,{children:"Understanding of trajectory generation"}),"\n",(0,i.jsx)(n.li,{children:"Familiarity with finite state machines"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"materials",children:"Materials"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"Tier"}),(0,i.jsx)(n.th,{children:"Notes"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"software"}),(0,i.jsx)(n.td,{children:"MuJoCo 3.0+"}),(0,i.jsx)(n.td,{children:"required"}),(0,i.jsx)(n.td,{children:"Physics simulation"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"software"}),(0,i.jsx)(n.td,{children:"Python 3.10+"}),(0,i.jsx)(n.td,{children:"required"}),(0,i.jsx)(n.td,{children:"Programming environment"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"software"}),(0,i.jsx)(n.td,{children:"NumPy, SciPy"}),(0,i.jsx)(n.td,{children:"required"}),(0,i.jsx)(n.td,{children:"Optimization, interpolation"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"simulation"}),(0,i.jsx)(n.td,{children:"humanoid-walker.xml"}),(0,i.jsx)(n.td,{children:"required"}),(0,i.jsx)(n.td,{children:"Full humanoid model"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,i.jsx)(n.h3,{id:"walking-as-controlled-falling",children:"Walking as Controlled Falling"}),"\n",(0,i.jsx)(n.p,{children:"Walking is a series of controlled falls where:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"CoM moves outside support polygon"}),"\n",(0,i.jsx)(n.li,{children:"Swing leg catches the fall"}),"\n",(0,i.jsx)(n.li,{children:"Weight transfers to new support"}),"\n",(0,i.jsx)(n.li,{children:"Process repeats with other leg"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"zmp-preview-control",children:"ZMP Preview Control"}),"\n",(0,i.jsx)(n.p,{children:"For smooth walking, we plan ZMP trajectory ahead and compute CoM trajectory that achieves it:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsxs)(n.msub,{children:[(0,i.jsxs)(n.mover,{accent:"true",children:[(0,i.jsx)(n.mi,{children:"x"}),(0,i.jsx)(n.mo,{children:"\xa8"})]}),(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"C"}),(0,i.jsx)(n.mi,{children:"o"}),(0,i.jsx)(n.mi,{children:"M"})]})]}),(0,i.jsx)(n.mo,{children:"="}),(0,i.jsxs)(n.msup,{children:[(0,i.jsx)(n.mi,{children:"\u03c9"}),(0,i.jsx)(n.mn,{children:"2"})]}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsxs)(n.msub,{children:[(0,i.jsx)(n.mi,{children:"x"}),(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"C"}),(0,i.jsx)(n.mi,{children:"o"}),(0,i.jsx)(n.mi,{children:"M"})]})]}),(0,i.jsx)(n.mo,{children:"\u2212"}),(0,i.jsxs)(n.msub,{children:[(0,i.jsx)(n.mi,{children:"x"}),(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"Z"}),(0,i.jsx)(n.mi,{children:"M"}),(0,i.jsx)(n.mi,{children:"P"})]})]}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\ddot{x}_{CoM} = \\omega^2 (x_{CoM} - x_{ZMP})"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.8179em",verticalAlign:"-0.15em"}}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord accent",children:(0,i.jsx)(n.span,{className:"vlist-t",children:(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsxs)(n.span,{className:"vlist",style:{height:"0.6679em"},children:[(0,i.jsxs)(n.span,{style:{top:"-3em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"x"})]}),(0,i.jsxs)(n.span,{style:{top:"-3em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(n.span,{className:"accent-body",style:{left:"-0.2222em"},children:(0,i.jsx)(n.span,{className:"mord",children:"\xa8"})})]})]})})})}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(n.span,{className:"vlist-r",children:[(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.3283em"},children:(0,i.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsxs)(n.span,{className:"mord mtight",children:[(0,i.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.07153em"},children:"C"}),(0,i.jsx)(n.span,{className:"mord mathnormal mtight",children:"o"}),(0,i.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.10903em"},children:"M"})]})})]})}),(0,i.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(n.span,{})})})]})})]}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"\u03c9"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsx)(n.span,{className:"vlist-t",children:(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,i.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord mathnormal",children:"x"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(n.span,{className:"vlist-r",children:[(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.3283em"},children:(0,i.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsxs)(n.span,{className:"mord mtight",children:[(0,i.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.07153em"},children:"C"}),(0,i.jsx)(n.span,{className:"mord mathnormal mtight",children:"o"}),(0,i.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.10903em"},children:"M"})]})})]})}),(0,i.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(n.span,{})})})]})})]}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"\u2212"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord mathnormal",children:"x"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(n.span,{className:"vlist-r",children:[(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.3283em"},children:(0,i.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:(0,i.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.13889em"},children:"ZMP"})})})]})}),(0,i.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(n.span,{})})})]})})]}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})]})]})}),"\n",(0,i.jsx)(n.p,{children:"Given future ZMP trajectory, we can compute required CoM trajectory."}),"\n",(0,i.jsx)(n.h3,{id:"walking-phases",children:"Walking Phases"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Double Support (DS)"}),": Both feet on ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Support (SS)"}),": One foot on ground, other swinging"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transitions"}),": Weight shift between phases"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"instructions",children:"Instructions"}),"\n",(0,i.jsx)(n.h3,{id:"step-1-set-up-walking-model",children:"Step 1: Set Up Walking Model"}),"\n",(0,i.jsx)(n.p,{children:"Load a walking-capable humanoid model:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import mujoco\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\nimport matplotlib.pyplot as plt\n\n# Load humanoid model\nmodel = mujoco.MjModel.from_xml_path(\n    \"textbook/assets/robot-models/mujoco/humanoid-walker.xml\"\n)\ndata = mujoco.MjData(model)\n\n# Identify leg components\ndef find_body_id(name):\n    return mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, name)\n\nbody_ids = {\n    'torso': find_body_id('torso'),\n    'pelvis': find_body_id('pelvis'),\n    'left_hip': find_body_id('left_hip'),\n    'left_knee': find_body_id('left_knee'),\n    'left_ankle': find_body_id('left_ankle'),\n    'left_foot': find_body_id('left_foot'),\n    'right_hip': find_body_id('right_hip'),\n    'right_knee': find_body_id('right_knee'),\n    'right_ankle': find_body_id('right_ankle'),\n    'right_foot': find_body_id('right_foot'),\n}\n\n# Find actuators for each joint\ndef find_actuators():\n    actuators = {}\n    for i in range(model.nu):\n        name = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_ACTUATOR, i)\n        if name:\n            actuators[name] = i\n    return actuators\n\nactuator_ids = find_actuators()\nprint(f\"Found {len(actuator_ids)} actuators\")\n\n# Initialize simulation\nmujoco.mj_resetData(model, data)\nmujoco.mj_forward(model, data)\n\nprint(f\"Initial CoM: {data.subtree_com[0]}\")\n"})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": Humanoid model loaded with identified leg joints and actuators."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-2-implement-footstep-planner",children:"Step 2: Implement Footstep Planner"}),"\n",(0,i.jsx)(n.p,{children:"Generate footstep sequence for desired walking:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class FootstepPlanner:\n    \"\"\"Generate footstep positions for walking.\"\"\"\n\n    def __init__(self, step_length=0.15, step_width=0.1, step_time=0.5):\n        \"\"\"\n        Initialize footstep planner.\n\n        Args:\n            step_length: Forward distance per step (m)\n            step_width: Lateral distance between feet (m)\n            step_time: Duration of each step (s)\n        \"\"\"\n        self.step_length = step_length\n        self.step_width = step_width\n        self.step_time = step_time\n        self.double_support_ratio = 0.2  # Fraction of step in DS\n\n    def generate_footsteps(self, n_steps, start_pos=[0, 0], start_foot='left'):\n        \"\"\"\n        Generate sequence of footstep positions.\n\n        Args:\n            n_steps: Number of steps to generate\n            start_pos: [x, y] starting position\n            start_foot: 'left' or 'right' foot starts\n\n        Returns:\n            footsteps: List of {'foot': str, 'pos': [x, y], 'time': float}\n        \"\"\"\n        footsteps = []\n        x = start_pos[0]\n        foot = start_foot\n\n        # Initial stance (both feet)\n        y_left = self.step_width / 2\n        y_right = -self.step_width / 2\n\n        footsteps.append({\n            'foot': 'left',\n            'pos': [x, y_left],\n            'time': 0.0,\n            'type': 'stance'\n        })\n        footsteps.append({\n            'foot': 'right',\n            'pos': [x, y_right],\n            'time': 0.0,\n            'type': 'stance'\n        })\n\n        # Generate walking steps\n        t = 0.0\n        for i in range(n_steps):\n            t += self.step_time\n\n```python\n```python\n            if foot == 'left':\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                x += self.step_length\n                footsteps.append({\n                    'foot': 'left',\n                    'pos': [x, y_left],\n                    'time': t,\n                    'type': 'swing_end'\n                })\n                foot = 'right'\n            else:\n                x += self.step_length\n                footsteps.append({\n                    'foot': 'right',\n                    'pos': [x, y_right],\n                    'time': t,\n                    'type': 'swing_end'\n                })\n                foot = 'left'\n\n        return footsteps\n\n    def get_support_phase(self, t, footsteps):\n        \"\"\"\n        Determine support phase at time t.\n\n        Returns:\n            phase: 'double', 'left_support', or 'right_support'\n            progress: 0-1 progress through current phase\n        \"\"\"\n        # Find current step\n        for i in range(len(footsteps) - 1, -1, -1):\n```python\n```python\n            if footsteps[i]['time'] <= t:\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"```python\n```python\n                if i == len(footsteps) - 1:\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                    return 'double', 1.0\n\n                next_step = footsteps[i + 1]\n                step_duration = next_step['time'] - footsteps[i]['time']\n                step_progress = (t - footsteps[i]['time']) / step_duration\n\n                ds_duration = self.double_support_ratio * step_duration\n\n```python\n```python\n                if step_progress < self.double_support_ratio / 2:\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                    return 'double', step_progress / (self.double_support_ratio / 2)\n\n```python\n```python\n                if step_progress > 1 - self.double_support_ratio / 2:\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                    return 'double', (step_progress - (1 - self.double_support_ratio / 2)) / (self.double_support_ratio / 2)\n\n                # Single support phase\n```python\n```python\n                if next_step['foot'] == 'left':\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                    return 'right_support', step_progress\n                else:\n                    return 'left_support', step_progress\n\n        return 'double', 0.0\n\n# Create planner and generate steps\nplanner = FootstepPlanner(step_length=0.15, step_width=0.1, step_time=0.6)\nfootsteps = planner.generate_footsteps(6)\n\nprint(\"Footstep sequence:\")\nfor fs in footsteps:\n    print(f\"  t={fs['time']:.2f}s: {fs['foot']} foot at {fs['pos']}\")\n"})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": Footstep sequence generated with alternating left/right steps."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-3-generate-zmp-trajectory",children:"Step 3: Generate ZMP Trajectory"}),"\n",(0,i.jsx)(n.p,{children:"Create ZMP reference trajectory from footsteps:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class ZMPTrajectoryGenerator:\n    """Generate ZMP reference trajectory for walking."""\n\n    def __init__(self, planner):\n        self.planner = planner\n\n    def generate_zmp_trajectory(self, footsteps, dt=0.01):\n        """\n        Generate ZMP reference trajectory.\n\n        ZMP moves between feet during double support,\n        stays at support foot during single support.\n\n        Args:\n            footsteps: List of footstep dictionaries\n            dt: Time discretization\n\n        Returns:\n            t: Time vector\n            zmp_ref: Nx2 array of ZMP references\n        """\n        total_time = footsteps[-1][\'time\'] + 0.5  # Extra settling time\n        t = np.arange(0, total_time, dt)\n        zmp_ref = np.zeros((len(t), 2))\n\n        for i, ti in enumerate(t):\n            zmp_ref[i] = self._get_zmp_at_time(ti, footsteps)\n\n        return t, zmp_ref\n\n    def _get_zmp_at_time(self, t, footsteps):\n        """Get desired ZMP position at time t."""\n        # Find active footsteps\n        left_foot_pos = None\n        right_foot_pos = None\n\n        for fs in footsteps:\n```python\n```python\n            if fs[\'time\'] <= t:\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"```python\n```python\n                if fs['foot'] == 'left':\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                    left_foot_pos = np.array(fs['pos'])\n                else:\n                    right_foot_pos = np.array(fs['pos'])\n\n        # Get phase\n        phase, progress = self.planner.get_support_phase(t, footsteps)\n\n```python\n```python\n        if phase == 'double':\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'            # Interpolate between feet\n            if left_foot_pos is not None and right_foot_pos is not None:\n                # Determine transition direction\n                mid = (left_foot_pos + right_foot_pos) / 2\n                return mid\n            elif left_foot_pos is not None:\n                return left_foot_pos\n            else:\n                return right_foot_pos if right_foot_pos is not None else np.zeros(2)\n\n        elif phase == \'left_support\':\n            return left_foot_pos if left_foot_pos is not None else np.zeros(2)\n\n        else:  # right_support\n            return right_foot_pos if right_foot_pos is not None else np.zeros(2)\n\n# Generate ZMP trajectory\nzmp_gen = ZMPTrajectoryGenerator(planner)\nt_zmp, zmp_ref = zmp_gen.generate_zmp_trajectory(footsteps)\n\nprint(f"ZMP trajectory: {len(t_zmp)} points over {t_zmp[-1]:.2f}s")\nprint(f"ZMP X range: [{zmp_ref[:, 0].min():.3f}, {zmp_ref[:, 0].max():.3f}]")\n'})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": ZMP trajectory generated following footstep positions."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-4-compute-com-trajectory-preview-control",children:"Step 4: Compute CoM Trajectory (Preview Control)"}),"\n",(0,i.jsx)(n.p,{children:"Use preview control to compute CoM trajectory:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class PreviewController:\n    """Preview control for CoM trajectory generation."""\n\n    def __init__(self, z_c=0.8, dt=0.01, preview_time=1.0):\n        """\n        Initialize preview controller.\n\n        Args:\n            z_c: CoM height (m)\n            dt: Time step\n            preview_time: Preview horizon (s)\n        """\n        self.z_c = z_c\n        self.dt = dt\n        self.g = 9.81\n        self.omega = np.sqrt(self.g / z_c)\n\n        # LIPM state-space model\n        # x = [com, com_dot, com_ddot]^T\n        # u = ZMP\n        A = np.array([\n            [1, dt, dt**2/2],\n            [0, 1, dt],\n            [0, 0, 1]\n        ])\n        B = np.array([\n            [1 - np.cosh(self.omega * dt)],\n            [-self.omega * np.sinh(self.omega * dt)],\n            [-self.omega**2 * np.cosh(self.omega * dt)]\n        ])\n        C = np.array([[1, 0, -self.z_c / self.g]])\n\n        self.A = A\n        self.B = B\n        self.C = C\n\n        # Preview gain computation (simplified Ricatti)\n        self.n_preview = int(preview_time / dt)\n        self._compute_preview_gains()\n\n    def _compute_preview_gains(self):\n        """Compute preview and integral gains."""\n        # Simplified gains (can use LQR for better results)\n        Q = 1e6  # State cost\n        R = 1    # Input cost\n\n        # State feedback\n        self.K = np.array([self.omega**2, 2*self.omega, 1]) * 0.5\n\n        # Preview gains (simplified exponential decay)\n        self.G_preview = np.zeros(self.n_preview)\n        for i in range(self.n_preview):\n            self.G_preview[i] = 0.3 * np.exp(-0.5 * i * self.dt)\n\n    def generate_com_trajectory(self, zmp_ref, x0=None):\n        """\n        Generate CoM trajectory using preview control.\n\n        Args:\n            zmp_ref: Nx1 array of ZMP references\n            x0: Initial state [com, com_dot, com_ddot] or None\n\n        Returns:\n            com_trajectory: Nx1 array of CoM positions\n        """\n        n = len(zmp_ref)\n\n        if x0 is None:\n            x0 = np.array([zmp_ref[0], 0, 0])\n\n        x = x0.copy()\n        com_trajectory = np.zeros(n)\n        com_velocity = np.zeros(n)\n\n        for i in range(n):\n            # Current ZMP error\n            zmp_current = self.C @ x\n\n            # State feedback term\n            u_fb = -self.K @ x\n\n            # Preview term\n            u_preview = 0\n            for j in range(min(self.n_preview, n - i)):\n                u_preview += self.G_preview[j] * zmp_ref[i + j]\n\n            # Control input (desired ZMP adjustment)\n            u = zmp_ref[i]  # Simplified: just track reference\n\n            # State update\n            x = self.A @ x + self.B.flatten() * (u - x[0])\n\n            # Record\n            com_trajectory[i] = x[0]\n            com_velocity[i] = x[1]\n\n        return com_trajectory, com_velocity\n\n# Generate CoM trajectory for X and Y\npreview = PreviewController(z_c=0.8, dt=0.01)\n\ncom_x, com_vx = preview.generate_com_trajectory(zmp_ref[:, 0])\ncom_y, com_vy = preview.generate_com_trajectory(zmp_ref[:, 1])\n\nprint(f"CoM trajectory generated")\nprint(f"CoM X: [{com_x.min():.3f}, {com_x.max():.3f}]")\nprint(f"CoM Y: [{com_y.min():.3f}, {com_y.max():.3f}]")\n'})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": CoM trajectory smoothly follows ZMP reference with preview."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-5-generate-swing-leg-trajectories",children:"Step 5: Generate Swing Leg Trajectories"}),"\n",(0,i.jsx)(n.p,{children:"Create smooth swing foot trajectories:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class SwingLegTrajectory:\n    """Generate swing leg trajectory using polynomial interpolation."""\n\n    def __init__(self, swing_height=0.05, ground_clearance=0.02):\n        """\n        Args:\n            swing_height: Maximum foot lift height\n            ground_clearance: Height above ground at start/end\n        """\n        self.swing_height = swing_height\n        self.ground_clearance = ground_clearance\n\n    def generate_trajectory(self, start_pos, end_pos, duration, dt=0.01):\n        """\n        Generate 3D swing foot trajectory.\n\n        Uses cubic spline for X,Y and parabolic for Z.\n\n        Args:\n            start_pos: [x, y, z] start position\n            end_pos: [x, y, z] end position\n            duration: Swing time (s)\n            dt: Time step\n\n        Returns:\n            t: Time vector\n            pos: Nx3 position trajectory\n            vel: Nx3 velocity trajectory\n        """\n        t = np.arange(0, duration, dt)\n        n = len(t)\n        s = t / duration  # Normalized time [0, 1]\n\n        pos = np.zeros((n, 3))\n        vel = np.zeros((n, 3))\n\n        # X trajectory: smooth 5th order polynomial\n        # Boundary conditions: pos, vel, acc = 0 at start/end\n        for i, si in enumerate(s):\n            # Smooth interpolation\n            h = 10*si**3 - 15*si**4 + 6*si**5  # Position\n            hdot = (30*si**2 - 60*si**3 + 30*si**4) / duration  # Velocity\n\n            pos[i, 0] = start_pos[0] + h * (end_pos[0] - start_pos[0])\n            pos[i, 1] = start_pos[1] + h * (end_pos[1] - start_pos[1])\n            vel[i, 0] = hdot * (end_pos[0] - start_pos[0])\n            vel[i, 1] = hdot * (end_pos[1] - start_pos[1])\n\n        # Z trajectory: parabolic arc\n        for i, si in enumerate(s):\n            # Parabola peaking at midpoint\n            z_lift = 4 * self.swing_height * si * (1 - si)\n            z_base = start_pos[2] + si * (end_pos[2] - start_pos[2])\n            pos[i, 2] = z_base + z_lift\n\n            # Z velocity\n            z_lift_dot = 4 * self.swing_height * (1 - 2*si) / duration\n            z_base_dot = (end_pos[2] - start_pos[2]) / duration\n            vel[i, 2] = z_base_dot + z_lift_dot\n\n        return t, pos, vel\n\n# Test swing trajectory\nswing_gen = SwingLegTrajectory(swing_height=0.08)\n\nstart = np.array([0, 0.05, 0.0])\nend = np.array([0.15, 0.05, 0.0])\n\nt_swing, swing_pos, swing_vel = swing_gen.generate_trajectory(start, end, duration=0.3)\n\nprint(f"Swing trajectory: {len(t_swing)} points")\nprint(f"Max height: {swing_pos[:, 2].max():.3f} m")\nprint(f"Final position: {swing_pos[-1]}")\n'})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": Swing trajectory with smooth arc, maximum height at midpoint."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-6-execute-walking-simulation",children:"Step 6: Execute Walking Simulation"}),"\n",(0,i.jsx)(n.p,{children:"Combine all components for walking execution:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class WalkingController:\n    """Full walking controller combining all trajectory generators."""\n\n    def __init__(self, model, data, com_height=0.8):\n        self.model = model\n        self.data = data\n        self.com_height = com_height\n\n        # Components\n        self.footstep_planner = FootstepPlanner(step_length=0.15, step_time=0.6)\n        self.zmp_generator = ZMPTrajectoryGenerator(self.footstep_planner)\n        self.preview_controller = PreviewController(z_c=com_height)\n        self.swing_generator = SwingLegTrajectory(swing_height=0.06)\n\n        # Tracking gains (PD)\n        self.kp_com = 500\n        self.kd_com = 50\n        self.kp_foot = 200\n        self.kd_foot = 20\n\n    def compute_inverse_kinematics(self, com_target, left_foot_target, right_foot_target):\n        """\n        Simplified IK: compute joint angles for desired poses.\n\n        In practice, use iterative IK or analytical solution.\n        """\n        # Placeholder: return current joint positions\n        # Real implementation would solve IK here\n        return self.data.qpos.copy()\n\n    def run_walking(self, n_steps=4, dt=0.002):\n        """\n        Execute walking with specified number of steps.\n\n        Returns:\n            history: Walking trajectory data\n        """\n        # Plan footsteps\n        footsteps = self.footstep_planner.generate_footsteps(n_steps)\n\n        # Generate trajectories\n        t_ref, zmp_ref = self.zmp_generator.generate_zmp_trajectory(footsteps, dt=dt)\n        com_x, com_vx = self.preview_controller.generate_com_trajectory(zmp_ref[:, 0])\n        com_y, com_vy = self.preview_controller.generate_com_trajectory(zmp_ref[:, 1])\n\n        # History\n        history = {\n            \'time\': [],\n            \'com\': [],\n            \'zmp\': [],\n            \'left_foot\': [],\n            \'right_foot\': []\n        }\n\n        # Current foot positions\n        left_foot_pos = np.array([0, self.footstep_planner.step_width/2, 0])\n        right_foot_pos = np.array([0, -self.footstep_planner.step_width/2, 0])\n\n        swing_foot = None\n        swing_trajectory = None\n        swing_index = 0\n        current_step = 0\n\n        for i, t in enumerate(t_ref):\n            # Get phase\n            phase, progress = self.footstep_planner.get_support_phase(t, footsteps)\n\n            # CoM target\n            com_target = np.array([com_x[i], com_y[i], self.com_height])\n\n            # Update swing foot if entering single support\n```python\n```python\n            if phase == \'left_support\' and swing_foot != \'right\':\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                # Start right swing\n                swing_foot = 'right'\n```python\n```python\n                if current_step + 2 < len(footsteps):\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"```python\n```python\n                    next_fs = [fs for fs in footsteps if fs['foot'] == 'right' and fs['time'] > t]\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                    if next_fs:\n                        target = np.array([next_fs[0]['pos'][0], next_fs[0]['pos'][1], 0])\n                        _, swing_trajectory, _ = self.swing_generator.generate_trajectory(\n                            right_foot_pos, target, 0.3, dt\n                        )\n                        swing_index = 0\n\n            elif phase == 'right_support' and swing_foot != 'left':\n                swing_foot = 'left'\n```python\n```python\n                if current_step + 2 < len(footsteps):\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"```python\n```python\n                    next_fs = [fs for fs in footsteps if fs['foot'] == 'left' and fs['time'] > t]\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                    if next_fs:\n                        target = np.array([next_fs[0]['pos'][0], next_fs[0]['pos'][1], 0])\n                        _, swing_trajectory, _ = self.swing_generator.generate_trajectory(\n                            left_foot_pos, target, 0.3, dt\n                        )\n                        swing_index = 0\n\n            elif phase == 'double':\n                swing_foot = None\n\n            # Update swing foot position\n```python\n```python\n            if swing_trajectory is not None and swing_index < len(swing_trajectory):\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"```python\n```python\n                if swing_foot == 'left':\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                    left_foot_pos = swing_trajectory[swing_index]\n                else:\n                    right_foot_pos = swing_trajectory[swing_index]\n                swing_index += 1\n\n            # Record\n            history['time'].append(t)\n            history['com'].append(com_target.copy())\n            history['zmp'].append(zmp_ref[i].copy())\n            history['left_foot'].append(left_foot_pos.copy())\n            history['right_foot'].append(right_foot_pos.copy())\n\n        return history\n\n# Create controller and run\nmujoco.mj_resetData(model, data)\nmujoco.mj_forward(model, data)\n\nwalker = WalkingController(model, data)\nhistory = walker.run_walking(n_steps=6)\n\nprint(f\"\\nWalking simulation: {len(history['time'])} steps\")\nprint(f\"Final CoM X: {history['com'][-1][0]:.3f} m\")\nprint(f\"Distance walked: {history['com'][-1][0] - history['com'][0][0]:.3f} m\")\n"})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": Walking trajectories generated for CoM and both feet over 6 steps."]})}),"\n",(0,i.jsx)(n.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"After completing this lab, you should have:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Code artifacts"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"footstep_planner.py"}),": Footstep sequence generation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"zmp_trajectory.py"}),": ZMP reference trajectory"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"preview_controller.py"}),": CoM trajectory from ZMP"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"swing_trajectory.py"}),": Swing leg motion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"walking_controller.py"}),": Integration of all components"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Understanding"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Footstep planning principles"}),"\n",(0,i.jsx)(n.li,{children:"ZMP preview control concept"}),"\n",(0,i.jsx)(n.li,{children:"Gait phase transitions"}),"\n",(0,i.jsx)(n.li,{children:"Swing leg trajectory requirements"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Experimental results"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Walking trajectory plots"}),"\n",(0,i.jsx)(n.li,{children:"Phase timing analysis"}),"\n",(0,i.jsx)(n.li,{children:"ZMP tracking performance"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"rubric",children:"Rubric"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Criterion"}),(0,i.jsx)(n.th,{children:"Points"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Footstep Planning"}),(0,i.jsx)(n.td,{children:"20"}),(0,i.jsx)(n.td,{children:"Correct alternating step sequence"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ZMP Trajectory"}),(0,i.jsx)(n.td,{children:"20"}),(0,i.jsx)(n.td,{children:"Smooth ZMP following footsteps"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"CoM Generation"}),(0,i.jsx)(n.td,{children:"20"}),(0,i.jsx)(n.td,{children:"Preview control produces stable trajectory"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Swing Trajectories"}),(0,i.jsx)(n.td,{children:"20"}),(0,i.jsx)(n.td,{children:"Smooth foot arcs with clearance"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Integration"}),(0,i.jsx)(n.td,{children:"20"}),(0,i.jsx)(n.td,{children:"Complete walking sequence"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Total"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"100"})}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"common-errors",children:"Common Errors"}),"\n",(0,i.jsxs)("troubleshooting",{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Error"}),": CoM trajectory diverges\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Check preview gains, ensure ZMP is within support polygon."]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Error"}),": Feet collide during walking\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Increase swing height, check step width parameter."]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Error"}),": Discontinuities in trajectories\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Verify phase transition timing, smooth interpolation."]})]}),"\n",(0,i.jsx)(n.h2,{id:"extensions",children:"Extensions"}),"\n",(0,i.jsx)(n.p,{children:"For advanced students:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Turning"}),": Add footstep rotation for curved walking"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Variable Speed"}),": Adapt step length/time for speed changes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Push Recovery"}),": Add stepping response to perturbations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rough Terrain"}),": Height variation in swing trajectories"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-content",children:"Related Content"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Theory"}),": Module 08 theory.md, Section 8.2 (Gait Generation)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Previous Lab"}),": Lab 08-01 (Balance and Standing)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Next Lab"}),": Lab 08-03 (Dynamic Locomotion)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Application"}),": Humanoid robots, exoskeletons, prosthetics"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>l});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);