"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[4100],{3086(n,e,r){r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>f,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"textbook/modules/ros2-integration/labs/lab-09-02","title":"tf2 and Coordinate Frames","description":"Objectives","source":"@site/docs/textbook/modules/09-ros2-integration/labs/lab-09-02.md","sourceDirName":"textbook/modules/09-ros2-integration/labs","slug":"/textbook/modules/ros2-integration/labs/lab-09-02","permalink":"/Hackathon-3/docs/textbook/modules/ros2-integration/labs/lab-09-02","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/09-ros2-integration/labs/lab-09-02.md","tags":[],"version":"current","frontMatter":{"id":"lab-09-02","module_id":"09","title":"tf2 and Coordinate Frames","difficulty":"intermediate","tier":"simulation","duration_minutes":90},"sidebar":"tutorialSidebar","previous":{"title":"ROS2 Fundamentals and Communication","permalink":"/Hackathon-3/docs/textbook/modules/ros2-integration/labs/lab-09-01"},"next":{"title":"Gazebo Simulation Integration","permalink":"/Hackathon-3/docs/textbook/modules/ros2-integration/labs/lab-09-03"}}');var s=r(4848),a=r(8453);const o={id:"lab-09-02",module_id:"09",title:"tf2 and Coordinate Frames",difficulty:"intermediate",tier:"simulation",duration_minutes:90},i="Lab 09-02: tf2 and Coordinate Frames",l={},d=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"Why tf2?",id:"why-tf2",level:3},{value:"Transform Tree",id:"transform-tree",level:3},{value:"Transform Types",id:"transform-types",level:3},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Understand Transform Broadcasting",id:"step-1-understand-transform-broadcasting",level:3},{value:"Step 2: Create Dynamic Transform Broadcaster",id:"step-2-create-dynamic-transform-broadcaster",level:3},{value:"Step 3: Create Transform Listener",id:"step-3-create-transform-listener",level:3},{value:"Step 4: Implement Sensor Data Transformation",id:"step-4-implement-sensor-data-transformation",level:3},{value:"Step 5: Visualize with RViz",id:"step-5-visualize-with-rviz",level:3},{value:"Step 6: Build Complete Transform Tree",id:"step-6-build-complete-transform-tree",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2},{value:"Common Errors",id:"common-errors",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Related Content",id:"related-content",level:2}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"lab-09-02-tf2-and-coordinate-frames",children:"Lab 09-02: tf2 and Coordinate Frames"})}),"\n",(0,s.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this lab, you will be able to:"}),"\n",(0,s.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Understand and use the tf2 transform library"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Create static and dynamic transform broadcasters"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Query transforms between coordinate frames"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Visualize coordinate frames in RViz"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Completed Lab 09-01 (ROS2 Fundamentals)"}),"\n",(0,s.jsx)(e.li,{children:"Understanding of rigid body transformations (Module 03)"}),"\n",(0,s.jsx)(e.li,{children:"Familiarity with quaternion representations"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"materials",children:"Materials"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Type"}),(0,s.jsx)(e.th,{children:"Name"}),(0,s.jsx)(e.th,{children:"Tier"}),(0,s.jsx)(e.th,{children:"Notes"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"software"}),(0,s.jsx)(e.td,{children:"ROS2 Humble"}),(0,s.jsx)(e.td,{children:"required"}),(0,s.jsx)(e.td,{children:"tf2_ros package"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"software"}),(0,s.jsx)(e.td,{children:"Python 3.10+"}),(0,s.jsx)(e.td,{children:"required"}),(0,s.jsx)(e.td,{children:"tf2_py interface"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"software"}),(0,s.jsx)(e.td,{children:"RViz2"}),(0,s.jsx)(e.td,{children:"required"}),(0,s.jsx)(e.td,{children:"Visualization"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"simulation"}),(0,s.jsx)(e.td,{children:"Robot URDF"}),(0,s.jsx)(e.td,{children:"required"}),(0,s.jsx)(e.td,{children:"Robot model with frames"})]})]})]}),"\n",(0,s.jsx)(e.h2,{id:"background",children:"Background"}),"\n",(0,s.jsx)(e.h3,{id:"why-tf2",children:"Why tf2?"}),"\n",(0,s.jsx)(e.p,{children:"tf2 provides:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Distributed transform tree management"}),"\n",(0,s.jsx)(e.li,{children:"Time-synchronized frame queries"}),"\n",(0,s.jsx)(e.li,{children:"Automatic interpolation and extrapolation"}),"\n",(0,s.jsx)(e.li,{children:"Standard interface for all ROS2 packages"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"transform-tree",children:"Transform Tree"}),"\n",(0,s.jsx)(e.p,{children:"Transforms form a tree structure:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Root frame"}),": Usually ",(0,s.jsx)(e.code,{children:"world"})," or ",(0,s.jsx)(e.code,{children:"map"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Child frames"}),": Link to single parent"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Chains"}),": Multi-hop transform lookups"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"transform-types",children:"Transform Types"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Static"}),": Fixed transforms (sensor mounts)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dynamic"}),": Time-varying transforms (joint angles, robot pose)"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"instructions",children:"Instructions"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-understand-transform-broadcasting",children:"Step 1: Understand Transform Broadcasting"}),"\n",(0,s.jsx)(e.p,{children:"Create a static transform broadcaster:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nstatic_tf_broadcaster.py\nBroadcasts static transforms for sensor mounts.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import TransformStamped\nfrom tf2_ros import StaticTransformBroadcaster\nimport numpy as np\n\nclass StaticFramePublisher(Node):\n    \"\"\"Publish static transforms for robot sensors.\"\"\"\n\n    def __init__(self):\n        super().__init__('static_tf_broadcaster')\n\n        # Static transform broadcaster\n        self.tf_broadcaster = StaticTransformBroadcaster(self)\n\n        # Define sensor transforms\n        transforms = []\n\n        # Camera on end-effector\n        camera_tf = TransformStamped()\n        camera_tf.header.stamp = self.get_clock().now().to_msg()\n        camera_tf.header.frame_id = 'end_effector'\n        camera_tf.child_frame_id = 'camera_link'\n        camera_tf.transform.translation.x = 0.05\n        camera_tf.transform.translation.y = 0.0\n        camera_tf.transform.translation.z = 0.02\n        # Rotate camera to look forward (Z out)\n        camera_tf.transform.rotation.x = 0.0\n        camera_tf.transform.rotation.y = 0.707\n        camera_tf.transform.rotation.z = 0.0\n        camera_tf.transform.rotation.w = 0.707\n        transforms.append(camera_tf)\n\n        # IMU on robot base\n        imu_tf = TransformStamped()\n        imu_tf.header.stamp = self.get_clock().now().to_msg()\n        imu_tf.header.frame_id = 'base_link'\n        imu_tf.child_frame_id = 'imu_link'\n        imu_tf.transform.translation.x = 0.0\n        imu_tf.transform.translation.y = 0.0\n        imu_tf.transform.translation.z = 0.1\n        imu_tf.transform.rotation.x = 0.0\n        imu_tf.transform.rotation.y = 0.0\n        imu_tf.transform.rotation.z = 0.0\n        imu_tf.transform.rotation.w = 1.0\n        transforms.append(imu_tf)\n\n        # LIDAR on top\n        lidar_tf = TransformStamped()\n        lidar_tf.header.stamp = self.get_clock().now().to_msg()\n        lidar_tf.header.frame_id = 'base_link'\n        lidar_tf.child_frame_id = 'lidar_link'\n        lidar_tf.transform.translation.x = 0.0\n        lidar_tf.transform.translation.y = 0.0\n        lidar_tf.transform.translation.z = 0.5\n        lidar_tf.transform.rotation.x = 0.0\n        lidar_tf.transform.rotation.y = 0.0\n        lidar_tf.transform.rotation.z = 0.0\n        lidar_tf.transform.rotation.w = 1.0\n        transforms.append(lidar_tf)\n\n        # Broadcast all static transforms\n        self.tf_broadcaster.sendTransform(transforms)\n\n        self.get_logger().info(f'Published {len(transforms)} static transforms')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = StaticFramePublisher()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\n```python\n```python\nif __name__ == '__main__':\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"    main()\n"})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": Static transforms visible with ",(0,s.jsx)(e.code,{children:"ros2 run tf2_ros tf2_echo base_link camera_link"}),"."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-2-create-dynamic-transform-broadcaster",children:"Step 2: Create Dynamic Transform Broadcaster"}),"\n",(0,s.jsx)(e.p,{children:"Broadcast robot joint transforms:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\ndynamic_tf_broadcaster.py\nBroadcasts dynamic transforms from robot joint states.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import TransformStamped\nfrom sensor_msgs.msg import JointState\nfrom tf2_ros import TransformBroadcaster\nimport numpy as np\n\nclass DynamicFramePublisher(Node):\n    """Publish dynamic transforms from joint states."""\n\n    def __init__(self):\n        super().__init__(\'dynamic_tf_broadcaster\')\n\n        # Dynamic transform broadcaster\n        self.tf_broadcaster = TransformBroadcaster(self)\n\n        # Subscribe to joint states\n        self.joint_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_callback,\n            10\n        )\n\n        # Robot kinematic parameters (simplified 2-link arm)\n        self.link_lengths = [0.5, 0.4]  # meters\n\n        # Timer for simulated joint states (if no real robot)\n        self.timer = self.create_timer(0.02, self.simulate_and_broadcast)  # 50 Hz\n        self.sim_time = 0.0\n\n        self.get_logger().info(\'Dynamic TF broadcaster started\')\n\n    def simulate_and_broadcast(self):\n        """Simulate joint motion and broadcast transforms."""\n        self.sim_time += 0.02\n\n        # Sinusoidal joint motion\n        q1 = 0.5 * np.sin(2 * np.pi * 0.2 * self.sim_time)\n        q2 = 0.3 * np.sin(2 * np.pi * 0.3 * self.sim_time + np.pi/4)\n\n        # Broadcast transforms\n        self.broadcast_arm_transforms(q1, q2)\n\n    def joint_callback(self, msg):\n        """Handle real joint state messages."""\n```python\n```python\n        if len(msg.position) >= 2:\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"            q1 = msg.position[0]\n            q2 = msg.position[1]\n            self.broadcast_arm_transforms(q1, q2)\n\n    def broadcast_arm_transforms(self, q1, q2):\n        \"\"\"Broadcast transform for 2-link arm.\"\"\"\n        now = self.get_clock().now().to_msg()\n\n        transforms = []\n\n        # Base to link1 (rotation about Z)\n        t1 = TransformStamped()\n        t1.header.stamp = now\n        t1.header.frame_id = 'base_link'\n        t1.child_frame_id = 'link1'\n        t1.transform.translation.x = 0.0\n        t1.transform.translation.y = 0.0\n        t1.transform.translation.z = 0.1  # Height of first joint\n\n        # Quaternion for rotation about Z by q1\n        t1.transform.rotation.x = 0.0\n        t1.transform.rotation.y = 0.0\n        t1.transform.rotation.z = np.sin(q1 / 2)\n        t1.transform.rotation.w = np.cos(q1 / 2)\n        transforms.append(t1)\n\n        # Link1 to link2 (at end of link1, rotation about Z)\n        t2 = TransformStamped()\n        t2.header.stamp = now\n        t2.header.frame_id = 'link1'\n        t2.child_frame_id = 'link2'\n        t2.transform.translation.x = self.link_lengths[0]\n        t2.transform.translation.y = 0.0\n        t2.transform.translation.z = 0.0\n\n        t2.transform.rotation.x = 0.0\n        t2.transform.rotation.y = 0.0\n        t2.transform.rotation.z = np.sin(q2 / 2)\n        t2.transform.rotation.w = np.cos(q2 / 2)\n        transforms.append(t2)\n\n        # Link2 to end_effector\n        t3 = TransformStamped()\n        t3.header.stamp = now\n        t3.header.frame_id = 'link2'\n        t3.child_frame_id = 'end_effector'\n        t3.transform.translation.x = self.link_lengths[1]\n        t3.transform.translation.y = 0.0\n        t3.transform.translation.z = 0.0\n        t3.transform.rotation.w = 1.0\n        transforms.append(t3)\n\n        # Broadcast\n        for t in transforms:\n            self.tf_broadcaster.sendTransform(t)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = DynamicFramePublisher()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n```python\n```python\nif __name__ == '__main__':\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"    main()\n"})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": Dynamic transforms update at 50 Hz, ",(0,s.jsx)(e.code,{children:"tf2_echo base_link end_effector"})," shows changing values."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-3-create-transform-listener",children:"Step 3: Create Transform Listener"}),"\n",(0,s.jsx)(e.p,{children:"Query transforms between frames:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\ntf_listener.py\nListens to transforms and computes end-effector pose.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, PointStamped\nfrom tf2_ros import TransformListener, Buffer\nfrom tf2_geometry_msgs import do_transform_point\nimport numpy as np\n\nclass TransformListenerNode(Node):\n    """Listen to transforms and compute poses."""\n\n    def __init__(self):\n        super().__init__(\'tf_listener\')\n\n        # TF2 buffer and listener\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Publisher for end-effector pose\n        self.pose_pub = self.create_publisher(\n            PoseStamped,\n            \'/end_effector_pose\',\n            10\n        )\n\n        # Timer for periodic queries\n        self.timer = self.create_timer(0.1, self.query_transforms)  # 10 Hz\n\n        self.get_logger().info(\'Transform listener started\')\n\n    def query_transforms(self):\n        """Query transform from base to end-effector."""\n        try:\n            # Get transform\n            transform = self.tf_buffer.lookup_transform(\n                \'base_link\',\n                \'end_effector\',\n                rclpy.time.Time(),  # Get latest\n                timeout=rclpy.duration.Duration(seconds=0.1)\n            )\n\n            # Create pose message\n            pose = PoseStamped()\n            pose.header.stamp = self.get_clock().now().to_msg()\n            pose.header.frame_id = \'base_link\'\n            pose.pose.position.x = transform.transform.translation.x\n            pose.pose.position.y = transform.transform.translation.y\n            pose.pose.position.z = transform.transform.translation.z\n            pose.pose.orientation = transform.transform.rotation\n\n            self.pose_pub.publish(pose)\n\n            # Log position\n            self.get_logger().info(\n                f\'EE position: [{pose.pose.position.x:.3f}, \'\n                f\'{pose.pose.position.y:.3f}, {pose.pose.position.z:.3f}]\'\n            )\n\n        except Exception as e:\n            self.get_logger().warn(f\'Transform lookup failed: {e}\')\n\n    def transform_point(self, point, from_frame, to_frame):\n        """\n        Transform a point between frames.\n\n        Args:\n            point: [x, y, z] in from_frame\n            from_frame: Source frame\n            to_frame: Target frame\n\n        Returns:\n            Transformed [x, y, z] or None if failed\n        """\n        try:\n            # Create point message\n            pt = PointStamped()\n            pt.header.frame_id = from_frame\n            pt.header.stamp = self.get_clock().now().to_msg()\n            pt.point.x = point[0]\n            pt.point.y = point[1]\n            pt.point.z = point[2]\n\n            # Get transform\n            transform = self.tf_buffer.lookup_transform(\n                to_frame,\n                from_frame,\n                rclpy.time.Time(),\n                timeout=rclpy.duration.Duration(seconds=0.1)\n            )\n\n            # Transform point\n            pt_transformed = do_transform_point(pt, transform)\n\n            return [\n                pt_transformed.point.x,\n                pt_transformed.point.y,\n                pt_transformed.point.z\n            ]\n\n        except Exception as e:\n            self.get_logger().error(f\'Point transform failed: {e}\')\n            return None\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = TransformListenerNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n```python\n```python\nif __name__ == \'__main__\':\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"    main()\n"})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": End-effector pose published to ",(0,s.jsx)(e.code,{children:"/end_effector_pose"})," topic."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-4-implement-sensor-data-transformation",children:"Step 4: Implement Sensor Data Transformation"}),"\n",(0,s.jsx)(e.p,{children:"Transform sensor data to robot base frame:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nsensor_transform.py\nTransform sensor data between frames.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import PointCloud2, LaserScan\nfrom geometry_msgs.msg import PointStamped\nfrom tf2_ros import TransformListener, Buffer\nfrom tf2_sensor_msgs.tf2_sensor_msgs import do_transform_cloud\nimport numpy as np\n\nclass SensorTransformNode(Node):\n    """Transform sensor data to base frame."""\n\n    def __init__(self):\n        super().__init__(\'sensor_transform\')\n\n        # TF2\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Target frame\n        self.target_frame = \'base_link\'\n\n        # Subscribers\n        self.scan_sub = self.create_subscription(\n            LaserScan,\n            \'/scan\',\n            self.scan_callback,\n            10\n        )\n\n        # Publishers\n        self.points_pub = self.create_publisher(\n            PointCloud2,\n            \'/scan_base_frame\',\n            10\n        )\n\n        self.get_logger().info(\'Sensor transform node started\')\n\n    def scan_callback(self, msg):\n        """Transform laser scan to base frame."""\n        try:\n            # Get transform from scan frame to base\n            transform = self.tf_buffer.lookup_transform(\n                self.target_frame,\n                msg.header.frame_id,\n                rclpy.time.Time(),\n                timeout=rclpy.duration.Duration(seconds=0.1)\n            )\n\n            # Convert scan to points in sensor frame\n            angles = np.arange(\n                msg.angle_min,\n                msg.angle_max + msg.angle_increment,\n                msg.angle_increment\n            )[:len(msg.ranges)]\n\n            ranges = np.array(msg.ranges)\n\n            # Filter invalid ranges\n```python\n```python\n            valid = (ranges > msg.range_min) & (ranges < msg.range_max)\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'            angles = angles[valid]\n            ranges = ranges[valid]\n\n            # Convert to Cartesian\n            points_sensor = np.zeros((len(ranges), 3))\n            points_sensor[:, 0] = ranges * np.cos(angles)\n            points_sensor[:, 1] = ranges * np.sin(angles)\n            points_sensor[:, 2] = 0.0\n\n            # Transform to base frame\n            points_base = self.transform_points(\n                points_sensor,\n                transform\n            )\n\n            self.get_logger().info(\n                f\'Transformed {len(points_base)} scan points to {self.target_frame}\'\n            )\n\n        except Exception as e:\n            self.get_logger().warn(f\'Scan transform failed: {e}\')\n\n    def transform_points(self, points, transform):\n        """\n        Transform array of points using transform.\n\n        Args:\n            points: Nx3 array of points\n            transform: geometry_msgs/TransformStamped\n\n        Returns:\n            Nx3 array of transformed points\n        """\n        # Extract translation\n        t = np.array([\n            transform.transform.translation.x,\n            transform.transform.translation.y,\n            transform.transform.translation.z\n        ])\n\n        # Extract rotation quaternion\n        q = transform.transform.rotation\n        quat = np.array([q.w, q.x, q.y, q.z])\n\n        # Convert quaternion to rotation matrix\n        R = self.quaternion_to_matrix(quat)\n\n        # Transform: p\' = R @ p + t\n        points_transformed = (R @ points.T).T + t\n\n        return points_transformed\n\n    def quaternion_to_matrix(self, q):\n        """Convert quaternion [w, x, y, z] to rotation matrix."""\n        w, x, y, z = q\n\n        R = np.array([\n            [1 - 2*y**2 - 2*z**2, 2*x*y - 2*w*z, 2*x*z + 2*w*y],\n            [2*x*y + 2*w*z, 1 - 2*x**2 - 2*z**2, 2*y*z - 2*w*x],\n            [2*x*z - 2*w*y, 2*y*z + 2*w*x, 1 - 2*x**2 - 2*y**2]\n        ])\n\n        return R\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = SensorTransformNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n```python\n```python\nif __name__ == \'__main__\':\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"    main()\n"})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": Sensor data transformed to base_link frame."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-5-visualize-with-rviz",children:"Step 5: Visualize with RViz"}),"\n",(0,s.jsx)(e.p,{children:"Create RViz configuration:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"# rviz_config.yaml\nPanels:\n  - Class: rviz_common/Displays\n    Name: Displays\n  - Class: rviz_common/Views\n    Name: Views\n\nVisualization Manager:\n  Displays:\n    - Class: rviz_default_plugins/TF\n      Enabled: true\n      Frame Timeout: 15\n      Frames:\n        All Enabled: true\n      Marker Scale: 0.3\n      Name: TF\n      Show Arrows: true\n      Show Axes: true\n      Show Names: true\n\n    - Class: rviz_default_plugins/RobotModel\n      Enabled: true\n      Name: RobotModel\n      Description Topic: /robot_description\n\n    - Class: rviz_default_plugins/Axes\n      Enabled: true\n      Length: 0.5\n      Name: World Axes\n      Radius: 0.02\n      Reference Frame: world\n\n  Global Options:\n    Background Color: 48; 48; 48\n    Fixed Frame: base_link\n    Frame Rate: 30\n\n  Tools:\n    - Class: rviz_default_plugins/MoveCamera\n    - Class: rviz_default_plugins/Select\n    - Class: rviz_default_plugins/FocusCamera\n\n  Views:\n    Current:\n      Class: rviz_default_plugins/Orbit\n      Distance: 3\n      Enable Stereo Rendering: false\n      Name: Current View\n      Pitch: 0.5\n      Target Frame: base_link\n      Yaw: 0.5\n"})}),"\n",(0,s.jsx)(e.p,{children:"Launch RViz:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"rviz2 -d rviz_config.yaml\n"})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": RViz shows coordinate frames updating in real-time."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-6-build-complete-transform-tree",children:"Step 6: Build Complete Transform Tree"}),"\n",(0,s.jsx)(e.p,{children:"Integrate all frames:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\ncomplete_tf_tree.py\nPublishes complete transform tree for robot system.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import TransformStamped\nfrom tf2_ros import TransformBroadcaster, StaticTransformBroadcaster\nimport numpy as np\n\nclass CompleteTFTree(Node):\n    \"\"\"Manage complete transform tree.\"\"\"\n\n    def __init__(self):\n        super().__init__('complete_tf_tree')\n\n        self.static_broadcaster = StaticTransformBroadcaster(self)\n        self.dynamic_broadcaster = TransformBroadcaster(self)\n\n        # Publish static transforms\n        self.publish_static_transforms()\n\n        # Timer for dynamic transforms\n        self.timer = self.create_timer(0.02, self.publish_dynamic_transforms)\n\n        self.sim_time = 0.0\n        self.get_logger().info('Complete TF tree manager started')\n\n    def publish_static_transforms(self):\n        \"\"\"Publish all static transforms.\"\"\"\n        static_tfs = []\n\n        # World to map (identity for simulation)\n        static_tfs.append(self.make_transform(\n            'world', 'map', [0, 0, 0], [0, 0, 0, 1]\n        ))\n\n        # Sensor mounts\n        static_tfs.append(self.make_transform(\n            'base_link', 'imu_link', [0, 0, 0.1], [0, 0, 0, 1]\n        ))\n        static_tfs.append(self.make_transform(\n            'base_link', 'lidar_link', [0.1, 0, 0.3], [0, 0, 0, 1]\n        ))\n        static_tfs.append(self.make_transform(\n            'end_effector', 'camera_link', [0.05, 0, 0.02], [0, 0.707, 0, 0.707]\n        ))\n        static_tfs.append(self.make_transform(\n            'end_effector', 'gripper_link', [0.1, 0, 0], [0, 0, 0, 1]\n        ))\n\n        self.static_broadcaster.sendTransform(static_tfs)\n        self.get_logger().info(f'Published {len(static_tfs)} static transforms')\n\n    def publish_dynamic_transforms(self):\n        \"\"\"Publish all dynamic transforms.\"\"\"\n        self.sim_time += 0.02\n        now = self.get_clock().now().to_msg()\n\n        dynamic_tfs = []\n\n        # Map to odom (localization drift simulation)\n        drift = 0.001 * self.sim_time\n        dynamic_tfs.append(self.make_transform(\n            'map', 'odom', [drift, drift/2, 0], [0, 0, 0, 1], now\n        ))\n\n        # Odom to base_link (robot motion)\n        x = 0.1 * self.sim_time  # Forward motion\n        y = 0.05 * np.sin(0.5 * self.sim_time)  # Slight sway\n        yaw = 0.1 * np.sin(0.2 * self.sim_time)\n        dynamic_tfs.append(self.make_transform(\n            'odom', 'base_link', [x, y, 0], self.yaw_to_quat(yaw), now\n        ))\n\n        # Joint transforms (2-link arm on base)\n        q1 = 0.5 * np.sin(0.3 * self.sim_time)\n        q2 = 0.3 * np.sin(0.4 * self.sim_time + 0.5)\n\n        dynamic_tfs.append(self.make_transform(\n            'base_link', 'link1', [0, 0, 0.2], self.yaw_to_quat(q1), now\n        ))\n        dynamic_tfs.append(self.make_transform(\n            'link1', 'link2', [0.4, 0, 0], self.yaw_to_quat(q2), now\n        ))\n        dynamic_tfs.append(self.make_transform(\n            'link2', 'end_effector', [0.3, 0, 0], [0, 0, 0, 1], now\n        ))\n\n        for tf in dynamic_tfs:\n            self.dynamic_broadcaster.sendTransform(tf)\n\n    def make_transform(self, parent, child, translation, rotation, stamp=None):\n        \"\"\"Create TransformStamped message.\"\"\"\n        t = TransformStamped()\n        t.header.stamp = stamp if stamp else self.get_clock().now().to_msg()\n        t.header.frame_id = parent\n        t.child_frame_id = child\n        t.transform.translation.x = float(translation[0])\n        t.transform.translation.y = float(translation[1])\n        t.transform.translation.z = float(translation[2])\n        t.transform.rotation.x = float(rotation[0])\n        t.transform.rotation.y = float(rotation[1])\n        t.transform.rotation.z = float(rotation[2])\n        t.transform.rotation.w = float(rotation[3])\n        return t\n\n    def yaw_to_quat(self, yaw):\n        \"\"\"Convert yaw angle to quaternion [x, y, z, w].\"\"\"\n        return [0, 0, np.sin(yaw/2), np.cos(yaw/2)]\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = CompleteTFTree()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\n```python\n```python\nif __name__ == '__main__':\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"    main()\n"})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": Complete transform tree: world \u2192 map \u2192 odom \u2192 base_link \u2192 links \u2192 sensors."]})}),"\n",(0,s.jsx)(e.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,s.jsx)(e.p,{children:"After completing this lab, you should have:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Code artifacts"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"static_tf_broadcaster.py"}),": Static frame publisher"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"dynamic_tf_broadcaster.py"}),": Joint-based transforms"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"tf_listener.py"}),": Transform queries"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"sensor_transform.py"}),": Sensor data transformation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"complete_tf_tree.py"}),": Full system integration"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Understanding"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Transform tree structure and conventions"}),"\n",(0,s.jsx)(e.li,{children:"Static vs. dynamic transforms"}),"\n",(0,s.jsx)(e.li,{children:"Transform lookup with time synchronization"}),"\n",(0,s.jsx)(e.li,{children:"RViz visualization of frames"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"rubric",children:"Rubric"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Criterion"}),(0,s.jsx)(e.th,{children:"Points"}),(0,s.jsx)(e.th,{children:"Description"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Static Transforms"}),(0,s.jsx)(e.td,{children:"20"}),(0,s.jsx)(e.td,{children:"Correct sensor mount transforms"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Dynamic Transforms"}),(0,s.jsx)(e.td,{children:"25"}),(0,s.jsx)(e.td,{children:"Proper joint-based broadcasting"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Transform Listener"}),(0,s.jsx)(e.td,{children:"20"}),(0,s.jsx)(e.td,{children:"Successful frame queries"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Sensor Transform"}),(0,s.jsx)(e.td,{children:"20"}),(0,s.jsx)(e.td,{children:"Point cloud transformation"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Visualization"}),(0,s.jsx)(e.td,{children:"15"}),(0,s.jsx)(e.td,{children:"Working RViz display"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Total"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"100"})}),(0,s.jsx)(e.td,{})]})]})]}),"\n",(0,s.jsx)(e.h2,{id:"common-errors",children:"Common Errors"}),"\n",(0,s.jsxs)("troubleshooting",{children:[(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Error"}),': "Lookup would require extrapolation into the future"\n',(0,s.jsx)(e.strong,{children:"Solution"}),": Use ",(0,s.jsx)(e.code,{children:"rclpy.time.Time()"})," for latest available transform."]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Error"}),": Transform tree disconnected\n",(0,s.jsx)(e.strong,{children:"Solution"}),": Check frame_id spelling, ensure parent exists."]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Error"}),": Transforms flickering in RViz\n",(0,s.jsx)(e.strong,{children:"Solution"}),": Increase buffer duration, check timestamp consistency."]})]}),"\n",(0,s.jsx)(e.h2,{id:"extensions",children:"Extensions"}),"\n",(0,s.jsx)(e.p,{children:"For advanced students:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"URDF Integration"}),": Load transforms from robot URDF"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Time Travel"}),": Query past transforms for sensor fusion"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Multi-Robot"}),": Handle multiple tf prefixes"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Transform Monitor"}),": Build debugging tool for tf issues"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"related-content",children:"Related Content"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Theory"}),": Module 09 theory.md, Section 9.2 (tf2 System)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Previous Lab"}),": Lab 09-01 (ROS2 Fundamentals)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Next Lab"}),": Lab 09-03 (Gazebo Integration)"]}),"\n"]})]})}function f(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(m,{...n})}):m(n)}},8453(n,e,r){r.d(e,{R:()=>o,x:()=>i});var t=r(6540);const s={},a=t.createContext(s);function o(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);