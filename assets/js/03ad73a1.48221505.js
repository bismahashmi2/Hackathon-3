"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[2831],{8358(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"textbook/modules/manipulation/labs/lab-07-03","title":"Dexterous Multi-Finger Manipulation","description":"Objectives","source":"@site/docs/textbook/modules/07-manipulation/labs/lab-07-03.md","sourceDirName":"textbook/modules/07-manipulation/labs","slug":"/textbook/modules/manipulation/labs/lab-07-03","permalink":"/Hackathon-3/docs/textbook/modules/manipulation/labs/lab-07-03","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/07-manipulation/labs/lab-07-03.md","tags":[],"version":"current","frontMatter":{"id":"lab-07-03","module_id":"07","title":"Dexterous Multi-Finger Manipulation","difficulty":"challenge","tier":"simulation","duration_minutes":120},"sidebar":"tutorialSidebar","previous":{"title":"Force Control and Compliance","permalink":"/Hackathon-3/docs/textbook/modules/manipulation/labs/lab-07-02"},"next":{"title":"Manipulation","permalink":"/Hackathon-3/docs/textbook/modules/manipulation/manipulation"}}');var o=t(4848),r=t(8453);const s={id:"lab-07-03",module_id:"07",title:"Dexterous Multi-Finger Manipulation",difficulty:"challenge",tier:"simulation",duration_minutes:120},a="Lab 07-03: Dexterous Multi-Finger Manipulation",l={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"Dexterous Manipulation",id:"dexterous-manipulation",level:3},{value:"Multi-Finger Coordination",id:"multi-finger-coordination",level:3},{value:"Grasp Quality Metrics",id:"grasp-quality-metrics",level:3},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Load the Dexterous Hand Model",id:"step-1-load-the-dexterous-hand-model",level:3},{value:"Step 2: Implement Finger Kinematics",id:"step-2-implement-finger-kinematics",level:3},{value:"Step 3: Implement Contact-Based Grasp Analysis",id:"step-3-implement-contact-based-grasp-analysis",level:3},{value:"Step 4: Implement Multi-Finger Grasp Controller",id:"step-4-implement-multi-finger-grasp-controller",level:3},{value:"Step 5: Implement In-Hand Manipulation",id:"step-5-implement-in-hand-manipulation",level:3},{value:"Step 6: Full Manipulation Demonstration",id:"step-6-full-manipulation-demonstration",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2},{value:"Common Errors",id:"common-errors",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Related Content",id:"related-content",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"lab-07-03-dexterous-multi-finger-manipulation",children:"Lab 07-03: Dexterous Multi-Finger Manipulation"})}),"\n",(0,o.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this lab, you will be able to:"}),"\n",(0,o.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Control a multi-fingered robotic hand in simulation"]}),"\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Implement grasp synthesis for complex objects"]}),"\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Execute in-hand manipulation (regrasp, rotation)"]}),"\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Analyze grasp stability using contact analysis"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Completed Labs 07-01 and 07-02"}),"\n",(0,o.jsx)(e.li,{children:"Strong understanding of kinematics and Jacobians"}),"\n",(0,o.jsx)(e.li,{children:"Familiarity with constrained optimization"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"materials",children:"Materials"}),"\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"Type"}),(0,o.jsx)(e.th,{children:"Name"}),(0,o.jsx)(e.th,{children:"Tier"}),(0,o.jsx)(e.th,{children:"Notes"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"software"}),(0,o.jsx)(e.td,{children:"MuJoCo 3.0+"}),(0,o.jsx)(e.td,{children:"required"}),(0,o.jsx)(e.td,{children:"Physics with multi-contact"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"software"}),(0,o.jsx)(e.td,{children:"Python 3.10+"}),(0,o.jsx)(e.td,{children:"required"}),(0,o.jsx)(e.td,{children:"Programming environment"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"software"}),(0,o.jsx)(e.td,{children:"NumPy, SciPy"}),(0,o.jsx)(e.td,{children:"required"}),(0,o.jsx)(e.td,{children:"Optimization"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"simulation"}),(0,o.jsx)(e.td,{children:"shadow-hand.xml"}),(0,o.jsx)(e.td,{children:"required"}),(0,o.jsx)(e.td,{children:"Shadow Dexterous Hand model"})]})]})]}),"\n",(0,o.jsx)(e.h2,{id:"background",children:"Background"}),"\n",(0,o.jsx)(e.h3,{id:"dexterous-manipulation",children:"Dexterous Manipulation"}),"\n",(0,o.jsx)(e.p,{children:"Dexterous manipulation enables:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"In-hand repositioning without regrasping"}),"\n",(0,o.jsx)(e.li,{children:"Manipulation of complex, non-convex objects"}),"\n",(0,o.jsx)(e.li,{children:"Human-like object handling capabilities"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"multi-finger-coordination",children:"Multi-Finger Coordination"}),"\n",(0,o.jsx)(e.p,{children:"Key challenges:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"High-dimensional joint space (20+ DOF for Shadow Hand)"}),"\n",(0,o.jsx)(e.li,{children:"Contact mode transitions (slip, stick, break)"}),"\n",(0,o.jsx)(e.li,{children:"Force closure maintenance during motion"}),"\n",(0,o.jsx)(e.li,{children:"Fingertip rolling and sliding"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"grasp-quality-metrics",children:"Grasp Quality Metrics"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Force Closure"}),": Wrench space spanned by contacts"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Grasp Wrench Space (GWS)"}),": Set of achievable wrenches"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"\u03b5-metric"}),": Largest inscribed ball in GWS"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"instructions",children:"Instructions"}),"\n",(0,o.jsx)(e.h3,{id:"step-1-load-the-dexterous-hand-model",children:"Step 1: Load the Dexterous Hand Model"}),"\n",(0,o.jsx)(e.p,{children:"Initialize the Shadow Hand simulation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import mujoco\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial import ConvexHull\nimport matplotlib.pyplot as plt\n\n# Load Shadow Hand model\nmodel = mujoco.MjModel.from_xml_path(\n    \"textbook/assets/robot-models/mujoco/shadow-hand.xml\"\n)\ndata = mujoco.MjData(model)\n\n# Explore the model structure\nprint(f\"Number of joints: {model.njnt}\")\nprint(f\"Number of actuators: {model.nu}\")\nprint(f\"Number of bodies: {model.nbody}\")\n\n# Identify finger components\nfinger_names = ['thumb', 'index', 'middle', 'ring', 'little']\nfinger_joints = {}\nfinger_tips = {}\n\nfor finger in finger_names:\n    # Find joints for this finger\n    joints = []\n    for i in range(model.njnt):\n        name = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_JOINT, i)\n        if name and finger in name.lower():\n            joints.append((i, name))\n    finger_joints[finger] = joints\n\n    # Find fingertip body\n    for i in range(model.nbody):\n        name = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_BODY, i)\n        if name and finger in name.lower() and 'tip' in name.lower():\n            finger_tips[finger] = i\n\nprint(\"\\nFinger structure:\")\nfor finger, joints in finger_joints.items():\n    print(f\"  {finger}: {len(joints)} joints, tip_id={finger_tips.get(finger, 'N/A')}\")\n\n# Initialize\nmujoco.mj_resetData(model, data)\nmujoco.mj_forward(model, data)\n"})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": Shadow Hand model loaded with 20+ joints, 5 finger kinematic chains identified."]})}),"\n",(0,o.jsx)(e.h3,{id:"step-2-implement-finger-kinematics",children:"Step 2: Implement Finger Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Compute forward kinematics and Jacobians for each finger:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class FingerKinematics:\n    """Kinematics for a single finger chain."""\n\n    def __init__(self, model, data, finger_name, tip_body_id, joint_ids):\n        self.model = model\n        self.data = data\n        self.name = finger_name\n        self.tip_id = tip_body_id\n        self.joint_ids = joint_ids  # List of joint indices\n\n        # Get joint position indices in qpos\n        self.qpos_indices = []\n        for jid in joint_ids:\n            adr = model.jnt_qposadr[jid]\n            self.qpos_indices.append(adr)\n\n    def get_tip_pose(self):\n        """Get fingertip position and orientation."""\n        pos = self.data.xpos[self.tip_id].copy()\n        quat = self.data.xquat[self.tip_id].copy()\n        return pos, quat\n\n    def get_jacobian(self):\n        """Compute Jacobian from finger base to tip."""\n        jacp = np.zeros((3, self.model.nv))\n        jacr = np.zeros((3, self.model.nv))\n\n        mujoco.mj_jacBody(self.model, self.data, jacp, jacr, self.tip_id)\n\n        # Extract columns for this finger\'s joints\n        finger_jacp = jacp[:, self.qpos_indices]\n        finger_jacr = jacr[:, self.qpos_indices]\n\n        return finger_jacp, finger_jacr\n\n    def set_joint_positions(self, q):\n        """Set finger joint positions."""\n        for i, idx in enumerate(self.qpos_indices):\n            self.data.qpos[idx] = q[i]\n        mujoco.mj_forward(self.model, self.data)\n\n# Create finger kinematics objects\nfingers = {}\nfor finger_name in finger_names:\n    if finger_name in finger_tips:\n        # Get joint IDs for this finger\n        joint_ids = [j[0] for j in finger_joints[finger_name]]\n        fingers[finger_name] = FingerKinematics(\n            model, data, finger_name, finger_tips[finger_name], joint_ids\n        )\n\n# Test kinematics\nfor name, fk in fingers.items():\n    pos, quat = fk.get_tip_pose()\n    jacp, _ = fk.get_jacobian()\n    print(f"{name} tip: pos={pos}, jacobian shape={jacp.shape}")\n'})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": Finger kinematics objects created with working forward kinematics and Jacobians."]})}),"\n",(0,o.jsx)(e.h3,{id:"step-3-implement-contact-based-grasp-analysis",children:"Step 3: Implement Contact-Based Grasp Analysis"}),"\n",(0,o.jsx)(e.p,{children:"Analyze grasp quality using contact information:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class GraspAnalyzer:\n    """Analyze grasp quality from contact information."""\n\n    def __init__(self, model, data, object_body_id):\n        self.model = model\n        self.data = data\n        self.object_id = object_body_id\n\n    def get_contacts_with_object(self):\n        """Extract all contacts with the grasped object."""\n        contacts = []\n\n        for i in range(self.data.ncon):\n            contact = self.data.contact[i]\n            geom1 = contact.geom1\n            geom2 = contact.geom2\n\n            body1 = self.model.geom_bodyid[geom1]\n            body2 = self.model.geom_bodyid[geom2]\n\n            # Check if one body is the object\n```python\n```python\n            if body1 == self.object_id or body2 == self.object_id:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"                # Get contact information\n                pos = contact.pos.copy()\n                normal = contact.frame[:3].copy()\n\n                # Get contact force\n                force = np.zeros(6)\n                mujoco.mj_contactForce(self.model, self.data, i, force)\n\n                contacts.append({\n                    'position': pos,\n                    'normal': normal,\n                    'force': force[:3],\n                    'geom1': geom1,\n                    'geom2': geom2\n                })\n\n        return contacts\n\n    def compute_grasp_matrix(self, contacts, object_center):\n        \"\"\"\n        Compute the grasp matrix G that maps contact forces to object wrench.\n\n        W_object = G @ f_contacts\n\n        Args:\n            contacts: List of contact dictionaries\n            object_center: Object center position\n\n        Returns:\n            G: 6 x 3n grasp matrix\n        \"\"\"\n        n = len(contacts)\n```python\n```python\n        if n == 0:\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'            return np.zeros((6, 0))\n\n        G = np.zeros((6, 3 * n))\n\n        for i, contact in enumerate(contacts):\n            r = contact[\'position\'] - object_center\n\n            # Force component\n            G[:3, 3*i:3*i+3] = np.eye(3)\n\n            # Torque component (cross product matrix)\n            G[3:6, 3*i:3*i+3] = np.array([\n                [0, -r[2], r[1]],\n                [r[2], 0, -r[0]],\n                [-r[1], r[0], 0]\n            ])\n\n        return G\n\n    def compute_force_closure(self, contacts, object_center, mu=0.5):\n        """\n        Check if grasp achieves force closure.\n\n        Uses the friction cone linearization approach.\n\n        Args:\n            contacts: Contact list\n            object_center: Object center\n            mu: Friction coefficient\n\n        Returns:\n            is_closure: Boolean\n            epsilon: Quality metric (largest perturbation that can be resisted)\n        """\n        n = len(contacts)\n```python\n```python\n        if n < 3:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"            return False, 0.0\n\n        # Build wrench set from friction cones\n        # Linearize friction cone with 4 edges\n        n_edges = 4\n        wrenches = []\n\n        for contact in contacts:\n            r = contact['position'] - object_center\n            normal = contact['normal']\n\n            # Build friction cone basis\n```python\n```python\n            if abs(normal[2]) < 0.9:\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"                t1 = np.cross(normal, [0, 0, 1])\n            else:\n                t1 = np.cross(normal, [1, 0, 0])\n            t1 /= np.linalg.norm(t1)\n            t2 = np.cross(normal, t1)\n\n            # Generate cone edges\n            for j in range(n_edges):\n                angle = 2 * np.pi * j / n_edges\n                direction = normal + mu * (np.cos(angle) * t1 + np.sin(angle) * t2)\n                direction /= np.linalg.norm(direction)\n\n                # Compute wrench\n                torque = np.cross(r, direction)\n                wrench = np.concatenate([direction, torque])\n                wrenches.append(wrench)\n\n        wrenches = np.array(wrenches)\n\n        # Check if origin is inside convex hull of wrenches\n        try:\n            hull = ConvexHull(wrenches)\n            # Compute distance to convex hull\n            # Simplified: check if we can achieve any wrench direction\n\n            # More sophisticated: find largest ball around origin in GWS\n            # Using linear programming\n            from scipy.optimize import linprog\n\n            # Find minimum over all wrench directions\n            epsilon = float('inf')\n            for direction in [np.eye(6)[i] for i in range(6)] + [-np.eye(6)[i] for i in range(6)]:\n                # Can we achieve unit wrench in this direction?\n                # min c^T x s.t. G @ x = direction, x >= 0\n                # Using wrench matrix form\n                c = np.ones(len(wrenches))\n                result = linprog(c, A_eq=wrenches.T, b_eq=direction,\n                                bounds=(0, None), method='highs')\n                if result.success:\n```python\n```python\n                    epsilon = min(epsilon, 1.0 / result.fun if result.fun > 0 else float('inf'))\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"                else:\n                    epsilon = 0\n                    break\n\n```python\n```python\n            is_closure = epsilon > 0.01\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'            return is_closure, min(epsilon, 1.0)\n\n        except Exception:\n            return False, 0.0\n\n    def evaluate_grasp(self):\n        """Full grasp evaluation."""\n        contacts = self.get_contacts_with_object()\n        object_center = self.data.xpos[self.object_id].copy()\n\n        result = {\n            \'n_contacts\': len(contacts),\n            \'contacts\': contacts\n        }\n\n```python\n```python\n        if len(contacts) >= 2:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"            G = self.compute_grasp_matrix(contacts, object_center)\n            result['grasp_matrix'] = G\n            result['grasp_rank'] = np.linalg.matrix_rank(G)\n\n            # Check force closure\n            is_closure, epsilon = self.compute_force_closure(contacts, object_center)\n            result['force_closure'] = is_closure\n            result['epsilon'] = epsilon\n        else:\n            result['force_closure'] = False\n            result['epsilon'] = 0\n\n        return result\n\n# Find object body\nobject_body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, \"object\")\n```python\n```python\nif object_body_id >= 0:\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'    analyzer = GraspAnalyzer(model, data, object_body_id)\n    print("GraspAnalyzer ready")\n'})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": GraspAnalyzer created with methods for contact extraction and closure checking."]})}),"\n",(0,o.jsx)(e.h3,{id:"step-4-implement-multi-finger-grasp-controller",children:"Step 4: Implement Multi-Finger Grasp Controller"}),"\n",(0,o.jsx)(e.p,{children:"Control all fingers for coordinated grasping:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class MultiFingerGraspController:\n    """Controller for coordinated multi-finger grasping."""\n\n    def __init__(self, model, data, fingers, object_body_id):\n        self.model = model\n        self.data = data\n        self.fingers = fingers\n        self.object_id = object_body_id\n\n        # Control gains\n        self.kp = 5.0  # Position gain\n        self.kd = 0.5  # Damping gain\n        self.kf = 0.1  # Force gain\n\n        # Grasp state\n        self.target_contacts = {}\n        self.grasp_force = 2.0  # N per finger\n\n    def set_target_contacts(self, contact_points):\n        """\n        Set target contact points for each finger.\n\n        Args:\n            contact_points: Dict mapping finger name to target 3D position\n        """\n        self.target_contacts = contact_points\n\n    def compute_approach_torques(self):\n        """\n        Compute torques to approach target contact points.\n\n        Returns:\n            tau: Full joint torque vector\n        """\n        tau = np.zeros(self.model.nv)\n\n        for finger_name, target_pos in self.target_contacts.items():\n            if finger_name not in self.fingers:\n                continue\n\n            fk = self.fingers[finger_name]\n            current_pos, _ = fk.get_tip_pose()\n\n            # Position error\n            error = target_pos - current_pos\n\n            # Get Jacobian\n            jacp, _ = fk.get_jacobian()\n\n            # Damping from velocity\n            finger_vel = np.zeros(len(fk.qpos_indices))\n            for i, idx in enumerate(fk.qpos_indices):\n                finger_vel[i] = self.data.qvel[idx]\n\n            # Cartesian velocity\n            cart_vel = jacp @ finger_vel\n\n            # Compute Cartesian force\n            F = self.kp * error - self.kd * cart_vel\n\n            # Map to joint torques (simplified: use transpose)\n            finger_tau = jacp.T @ F\n\n            # Apply to full torque vector\n            for i, idx in enumerate(fk.qpos_indices):\n                tau[idx] += finger_tau[i]\n\n        return tau\n\n    def compute_squeeze_torques(self, squeeze_force):\n        """\n        Compute torques to apply squeezing force toward object center.\n\n        Args:\n            squeeze_force: Force magnitude toward object\n\n        Returns:\n            tau: Joint torques\n        """\n        tau = np.zeros(self.model.nv)\n        object_pos = self.data.xpos[self.object_id]\n\n        for finger_name, fk in self.fingers.items():\n            current_pos, _ = fk.get_tip_pose()\n\n            # Direction toward object center\n            direction = object_pos - current_pos\n            dist = np.linalg.norm(direction)\n```python\n```python\n            if dist > 0.001:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"                direction /= dist\n\n            # Force toward object\n            F = squeeze_force * direction\n\n            # Get Jacobian and map to joints\n            jacp, _ = fk.get_jacobian()\n            finger_tau = jacp.T @ F\n\n            for i, idx in enumerate(fk.qpos_indices):\n                tau[idx] += finger_tau[i]\n\n        return tau\n\n    def execute_grasp(self, n_steps=1000, approach_steps=500):\n        \"\"\"\n        Execute full grasp sequence.\n\n        Args:\n            n_steps: Total simulation steps\n            approach_steps: Steps for approach phase\n\n        Returns:\n            history: Recorded data\n        \"\"\"\n        history = {\n            'step': [],\n            'contacts': [],\n            'force_closure': [],\n            'object_pos': []\n        }\n\n        for step in range(n_steps):\n            # Phase 1: Approach\n```python\n```python\n            if step < approach_steps:\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"                tau = self.compute_approach_torques()\n            # Phase 2: Squeeze\n            else:\n                tau = self.compute_squeeze_torques(self.grasp_force)\n\n            # Apply torques\n            tau = np.clip(tau, -10, 10)\n            self.data.ctrl[:len(tau)] = tau\n\n            # Step simulation\n            mujoco.mj_step(self.model, self.data)\n\n            # Record periodically\n```python\n```python\n            if step % 50 == 0:\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"                analyzer = GraspAnalyzer(self.model, self.data, self.object_id)\n                result = analyzer.evaluate_grasp()\n\n                history['step'].append(step)\n                history['contacts'].append(result['n_contacts'])\n                history['force_closure'].append(result['force_closure'])\n                history['object_pos'].append(self.data.xpos[self.object_id].copy())\n\n        return history\n\n# Create grasp controller\n```python\n```python\nif object_body_id >= 0:\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"    grasp_ctrl = MultiFingerGraspController(model, data, fingers, object_body_id)\n\n    # Set target contacts around object\n    object_pos = data.xpos[object_body_id]\n    object_size = 0.03  # Approximate object radius\n\n    target_contacts = {\n        'thumb': object_pos + np.array([-object_size, 0, 0]),\n        'index': object_pos + np.array([object_size, object_size, 0]),\n        'middle': object_pos + np.array([object_size, 0, 0]),\n        'ring': object_pos + np.array([object_size, -object_size, 0]),\n    }\n    grasp_ctrl.set_target_contacts(target_contacts)\n\n    print(\"MultiFingerGraspController ready with targets set\")\n"})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": Controller configured with target contact positions for approach and squeeze phases."]})}),"\n",(0,o.jsx)(e.h3,{id:"step-5-implement-in-hand-manipulation",children:"Step 5: Implement In-Hand Manipulation"}),"\n",(0,o.jsx)(e.p,{children:"Execute controlled rotation of grasped object:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class InHandManipulator:\n    """Controller for in-hand object manipulation."""\n\n    def __init__(self, model, data, fingers, object_body_id):\n        self.model = model\n        self.data = data\n        self.fingers = fingers\n        self.object_id = object_body_id\n\n        # Manipulation parameters\n        self.rotation_gain = 0.5\n        self.squeeze_force = 3.0\n\n    def compute_rotation_torques(self, axis, angle_rate):\n        """\n        Compute fingertip motions to rotate object about axis.\n\n        Args:\n            axis: Rotation axis (unit vector)\n            angle_rate: Desired angular velocity (rad/s)\n\n        Returns:\n            tau: Joint torques\n        """\n        tau = np.zeros(self.model.nv)\n        object_pos = self.data.xpos[self.object_id]\n\n        for finger_name, fk in self.fingers.items():\n            tip_pos, _ = fk.get_tip_pose()\n\n            # Vector from object center to fingertip\n            r = tip_pos - object_pos\n\n            # Desired tangential velocity\n            v_desired = angle_rate * np.cross(axis, r)\n\n            # Get current velocity\n            jacp, _ = fk.get_jacobian()\n            finger_vel = np.zeros(len(fk.qpos_indices))\n            for i, idx in enumerate(fk.qpos_indices):\n                finger_vel[i] = self.data.qvel[idx]\n            v_current = jacp @ finger_vel\n\n            # Velocity error\n            v_error = v_desired - v_current\n\n            # Force from velocity control\n            F_rotation = 2.0 * v_error\n\n            # Add inward squeeze force\n            squeeze_dir = object_pos - tip_pos\n            squeeze_dist = np.linalg.norm(squeeze_dir)\n```python\n```python\n            if squeeze_dist > 0.001:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'                squeeze_dir /= squeeze_dist\n            F_squeeze = self.squeeze_force * squeeze_dir\n\n            # Total force\n            F_total = F_rotation + F_squeeze\n\n            # Map to joint torques\n            finger_tau = jacp.T @ F_total\n\n            for i, idx in enumerate(fk.qpos_indices):\n                tau[idx] += finger_tau[i]\n\n        return tau\n\n    def rotate_object(self, axis, target_angle, duration=2.0, dt=0.002):\n        """\n        Rotate object by specified angle.\n\n        Args:\n            axis: Rotation axis (normalized)\n            target_angle: Target rotation in radians\n            duration: Time for rotation\n\n        Returns:\n            history: Rotation trajectory data\n        """\n        history = {\n            \'time\': [],\n            \'angle\': [],\n            \'object_quat\': []\n        }\n\n        axis = axis / np.linalg.norm(axis)\n        angle_rate = target_angle / duration\n        steps = int(duration / dt)\n\n        # Record initial orientation\n        quat_init = self.data.xquat[self.object_id].copy()\n\n        for step in range(steps):\n            # Compute manipulation torques\n            tau = self.compute_rotation_torques(axis, angle_rate)\n            tau = np.clip(tau, -10, 10)\n            self.data.ctrl[:len(tau)] = tau\n\n            # Step simulation\n            mujoco.mj_step(self.model, self.data)\n\n            # Compute rotation angle from initial\n            quat_current = self.data.xquat[self.object_id].copy()\n\n            # Quaternion difference to get rotation\n            # Simplified: compute angle from w component\n            # For small rotations: angle \u2248 2 * arccos(|w|)\n            quat_diff = self._quat_multiply(quat_current, self._quat_conjugate(quat_init))\n            angle = 2 * np.arccos(np.clip(abs(quat_diff[0]), -1, 1))\n\n            history[\'time\'].append(step * dt)\n            history[\'angle\'].append(angle)\n            history[\'object_quat\'].append(quat_current.copy())\n\n        return history\n\n    def _quat_multiply(self, q1, q2):\n        """Quaternion multiplication."""\n        w1, x1, y1, z1 = q1\n        w2, x2, y2, z2 = q2\n        return np.array([\n            w1*w2 - x1*x2 - y1*y2 - z1*z2,\n            w1*x2 + x1*w2 + y1*z2 - z1*y2,\n            w1*y2 - x1*z2 + y1*w2 + z1*x2,\n            w1*z2 + x1*y2 - y1*x2 + z1*w2\n        ])\n\n    def _quat_conjugate(self, q):\n        """Quaternion conjugate."""\n        return np.array([q[0], -q[1], -q[2], -q[3]])\n\n# Create manipulator\n```python\n```python\nif object_body_id >= 0:\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'    manipulator = InHandManipulator(model, data, fingers, object_body_id)\n    print("InHandManipulator ready")\n'})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": InHandManipulator created with object rotation capability."]})}),"\n",(0,o.jsx)(e.h3,{id:"step-6-full-manipulation-demonstration",children:"Step 6: Full Manipulation Demonstration"}),"\n",(0,o.jsx)(e.p,{children:"Execute complete pick, rotate, and place sequence:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'def full_manipulation_demo(grasp_ctrl, manipulator, analyzer):\n    """\n    Execute complete manipulation demonstration.\n\n    Sequence:\n    1. Approach object\n    2. Form grasp\n    3. Verify force closure\n    4. Rotate object 90\xb0\n    5. Verify grasp maintained\n    """\n    print("=" * 50)\n    print("DEXTEROUS MANIPULATION DEMONSTRATION")\n    print("=" * 50)\n\n    # Phase 1: Approach and grasp\n    print("\\n[Phase 1] Approaching and grasping object...")\n    history = grasp_ctrl.execute_grasp(n_steps=800, approach_steps=400)\n\n    result = analyzer.evaluate_grasp()\n    print(f"  Contacts established: {result[\'n_contacts\']}")\n    print(f"  Force closure: {result[\'force_closure\']}")\n    print(f"  Epsilon metric: {result.get(\'epsilon\', 0):.3f}")\n\n    if not result[\'force_closure\']:\n        print("  WARNING: No force closure - grasp may fail")\n\n    # Phase 2: Lift test\n    print("\\n[Phase 2] Testing grasp stability...")\n    initial_z = grasp_ctrl.data.xpos[grasp_ctrl.object_id][2]\n\n    # Apply upward motion to hand base (if applicable)\n    for _ in range(200):\n        tau = grasp_ctrl.compute_squeeze_torques(5.0)\n        tau = np.clip(tau, -10, 10)\n        grasp_ctrl.data.ctrl[:len(tau)] = tau\n        mujoco.mj_step(grasp_ctrl.model, grasp_ctrl.data)\n\n    result = analyzer.evaluate_grasp()\n    print(f"  Contacts maintained: {result[\'n_contacts\']}")\n\n    # Phase 3: In-hand rotation\n    print("\\n[Phase 3] Rotating object 90\xb0...")\n    rotation_history = manipulator.rotate_object(\n        axis=np.array([0, 0, 1]),  # Z-axis rotation\n        target_angle=np.pi/2,\n        duration=3.0\n    )\n\n    final_angle = rotation_history[\'angle\'][-1]\n    print(f"  Target rotation: {np.pi/2:.3f} rad")\n    print(f"  Achieved rotation: {final_angle:.3f} rad")\n    print(f"  Rotation error: {abs(np.pi/2 - final_angle):.3f} rad")\n\n    # Phase 4: Final grasp check\n    print("\\n[Phase 4] Verifying final grasp...")\n    result = analyzer.evaluate_grasp()\n    print(f"  Final contacts: {result[\'n_contacts\']}")\n    print(f"  Force closure maintained: {result[\'force_closure\']}")\n\n    print("\\n" + "=" * 50)\n    print("DEMONSTRATION COMPLETE")\n    print("=" * 50)\n\n    return {\n        \'grasp_history\': history,\n        \'rotation_history\': rotation_history,\n        \'final_grasp\': result\n    }\n\n# Run demonstration (if models are properly loaded)\nprint("\\nTo run full demonstration:")\nprint("  demo_result = full_manipulation_demo(grasp_ctrl, manipulator, analyzer)")\n'})}),"\n",(0,o.jsx)("checkpoint",{children:(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Expected"}),": Framework for complete manipulation sequence defined and ready to execute."]})}),"\n",(0,o.jsx)(e.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,o.jsx)(e.p,{children:"After completing this lab, you should have:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Code artifacts"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"finger_kinematics.py"}),": Multi-finger FK and Jacobians"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"grasp_analyzer.py"}),": Contact analysis and quality metrics"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"multi_finger_controller.py"}),": Coordinated grasp control"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"in_hand_manipulator.py"}),": Rotation and repositioning"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Understanding"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"High-DOF hand control strategies"}),"\n",(0,o.jsx)(e.li,{children:"Force closure concept and verification"}),"\n",(0,o.jsx)(e.li,{children:"Contact mode management during manipulation"}),"\n",(0,o.jsx)(e.li,{children:"Challenges of dexterous manipulation"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Experimental results"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Grasp quality metrics (\u03b5-metric, contact count)"}),"\n",(0,o.jsx)(e.li,{children:"In-hand rotation accuracy"}),"\n",(0,o.jsx)(e.li,{children:"Grasp stability during manipulation"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"rubric",children:"Rubric"}),"\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"Criterion"}),(0,o.jsx)(e.th,{children:"Points"}),(0,o.jsx)(e.th,{children:"Description"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Finger Kinematics"}),(0,o.jsx)(e.td,{children:"15"}),(0,o.jsx)(e.td,{children:"Correct FK and Jacobian for all fingers"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Grasp Analysis"}),(0,o.jsx)(e.td,{children:"20"}),(0,o.jsx)(e.td,{children:"Working contact extraction and closure check"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Multi-Finger Control"}),(0,o.jsx)(e.td,{children:"25"}),(0,o.jsx)(e.td,{children:"Coordinated approach and squeeze"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"In-Hand Manipulation"}),(0,o.jsx)(e.td,{children:"25"}),(0,o.jsx)(e.td,{children:"Successful object rotation"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Integration"}),(0,o.jsx)(e.td,{children:"15"}),(0,o.jsx)(e.td,{children:"Complete pick-rotate sequence"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:(0,o.jsx)(e.strong,{children:"Total"})}),(0,o.jsx)(e.td,{children:(0,o.jsx)(e.strong,{children:"100"})}),(0,o.jsx)(e.td,{})]})]})]}),"\n",(0,o.jsx)(e.h2,{id:"common-errors",children:"Common Errors"}),"\n",(0,o.jsxs)("troubleshooting",{children:[(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Error"}),": Object drops during rotation\n",(0,o.jsx)(e.strong,{children:"Solution"}),": Increase squeeze force, ensure all fingers maintain contact."]}),(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Error"}),": Grasp analysis fails with few contacts\n",(0,o.jsx)(e.strong,{children:"Solution"}),": Check collision groups, adjust approach positions, verify friction."]}),(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Error"}),": Fingers collide with each other\n",(0,o.jsx)(e.strong,{children:"Solution"}),": Add collision avoidance, use different approach angles."]})]}),"\n",(0,o.jsx)(e.h2,{id:"extensions",children:"Extensions"}),"\n",(0,o.jsx)(e.p,{children:"For advanced students:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Tactile Sensing"}),": Use simulated tactile arrays for slip detection"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Learned Manipulation"}),": Train policy with RL for complex objects"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Contact-Rich Tasks"}),": Tool use (screwdriver, hammer)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Bimanual"}),": Coordinate two hands for large object manipulation"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"related-content",children:"Related Content"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Theory"}),": Module 07 theory.md, Section 7.4 (Dexterous Manipulation)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Previous Lab"}),": Lab 07-02 (Force Control)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Application"}),": Robotic prosthetics, surgical robots, warehouse automation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Research"}),": OpenAI Rubik's cube, Stanford dexterity benchmarks"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>s,x:()=>a});var i=t(6540);const o={},r=i.createContext(o);function s(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);