"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[2760],{5309(n,e,t){t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"textbook/modules/kinematics-fundamentals/labs/lab-03-03","title":"Full Humanoid FK/IK","description":"Objectives","source":"@site/docs/textbook/modules/03-kinematics-fundamentals/labs/lab-03-03.md","sourceDirName":"textbook/modules/03-kinematics-fundamentals/labs","slug":"/textbook/modules/kinematics-fundamentals/labs/lab-03-03","permalink":"/Hackathon-3/docs/textbook/modules/kinematics-fundamentals/labs/lab-03-03","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/03-kinematics-fundamentals/labs/lab-03-03.md","tags":[],"version":"current","frontMatter":{"id":"lab-03-03","module_id":"03","title":"Full Humanoid FK/IK","difficulty":"challenge","tier":"simulation","duration_minutes":90,"submission_format":"notebook","auto_gradable":false},"sidebar":"tutorialSidebar","previous":{"title":"Inverse Kinematics Solver","permalink":"/Hackathon-3/docs/textbook/modules/kinematics-fundamentals/labs/lab-03-02"},"next":{"title":"Kinematics Fundamentals","permalink":"/Hackathon-3/docs/textbook/modules/kinematics-fundamentals/kinematics-fundamentals"}}');var i=t(4848),s=t(8453);const a={id:"lab-03-03",module_id:"03",title:"Full Humanoid FK/IK",difficulty:"challenge",tier:"simulation",duration_minutes:90,submission_format:"notebook",auto_gradable:!1},r="Lab 03-03: Full Humanoid FK/IK",d={},l=[{value:"Objectives",id:"objectives",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Load and Analyze the Humanoid",id:"step-1-load-and-analyze-the-humanoid",level:3},{value:"Step 2: Implement FK for a Limb",id:"step-2-implement-fk-for-a-limb",level:3},{value:"Step 3: Implement Numerical IK for Humanoid",id:"step-3-implement-numerical-ik-for-humanoid",level:3},{value:"Step 4: Multi-Limb Coordination",id:"step-4-multi-limb-coordination",level:3},{value:"Step 5: Visualize the Pose",id:"step-5-visualize-the-pose",level:3},{value:"Step 6: Animate a Trajectory",id:"step-6-animate-a-trajectory",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2},{value:"Extensions",id:"extensions",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"lab-03-03-full-humanoid-fkik",children:"Lab 03-03: Full Humanoid FK/IK"})}),"\n",(0,i.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,i.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Implement FK for multi-DOF humanoid limbs"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Apply IK to position humanoid hands and feet"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Handle kinematic chains with multiple joints"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Create coordinated multi-limb poses"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"materials",children:"Materials"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Type"}),(0,i.jsx)(e.th,{children:"Name"}),(0,i.jsx)(e.th,{children:"Version"}),(0,i.jsx)(e.th,{children:"Tier"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"software"}),(0,i.jsx)(e.td,{children:"Python"}),(0,i.jsx)(e.td,{children:"3.10+"}),(0,i.jsx)(e.td,{children:"required"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"software"}),(0,i.jsx)(e.td,{children:"MuJoCo"}),(0,i.jsx)(e.td,{children:"3.0+"}),(0,i.jsx)(e.td,{children:"required"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"software"}),(0,i.jsx)(e.td,{children:"NumPy"}),(0,i.jsx)(e.td,{children:"1.24+"}),(0,i.jsx)(e.td,{children:"required"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"software"}),(0,i.jsx)(e.td,{children:"SciPy"}),(0,i.jsx)(e.td,{children:"1.10+"}),(0,i.jsx)(e.td,{children:"required"})]})]})]}),"\n",(0,i.jsx)(e.h2,{id:"background",children:"Background"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid robots have complex kinematic structures with multiple branching chains. This lab applies FK/IK concepts to realistic humanoid limbs."}),"\n",(0,i.jsx)(e.h2,{id:"instructions",children:"Instructions"}),"\n",(0,i.jsx)(e.h3,{id:"step-1-load-and-analyze-the-humanoid",children:"Step 1: Load and Analyze the Humanoid"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import mujoco\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Load humanoid model\nmodel = mujoco.MjModel.from_xml_path(\n    mujoco.util.get_resource_path("humanoid/humanoid.xml")\n)\ndata = mujoco.MjData(model)\n\n# Analyze kinematic structure\nprint("Humanoid Kinematic Structure")\nprint("=" * 50)\nprint(f"Bodies: {model.nbody}")\nprint(f"Joints: {model.njnt}")\nprint(f"DOF: {model.nv}")\n\n# List all bodies\nprint("\\nBody hierarchy:")\nfor i in range(model.nbody):\n    name = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_BODY, i)\n    parent_id = model.body_parentid[i]\n```python\n```python\n    parent_name = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_BODY, parent_id) if i > 0 else "world"\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"    print(f\"  {i}: {name} (parent: {parent_name})\")\n\n# Identify end-effectors\nend_effectors = ['right_hand', 'left_hand', 'right_foot', 'left_foot']\nfor ee in end_effectors:\n    body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, ee)\n```python\n```python\n    if body_id >= 0:\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'        print(f"\\n{ee} (body {body_id}):")\n        # Find joints in chain from root to this body\n        chain = []\n        current = body_id\n```python\n```python\n        while current > 0:\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"            for j in range(model.njnt):\n```python\n```python\n                if model.jnt_bodyid[j] == current:\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'                    jnt_name = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_JOINT, j)\n                    chain.append(jnt_name)\n            current = model.body_parentid[current]\n        print(f"  Joint chain: {list(reversed(chain))}")\n'})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Understanding"}),": Note the kinematic chains for each limb.\nRight arm chain typically: right_shoulder1 \u2192 right_shoulder2 \u2192 right_elbow"]})}),"\n",(0,i.jsx)(e.h3,{id:"step-2-implement-fk-for-a-limb",children:"Step 2: Implement FK for a Limb"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def get_body_position(model, data, body_name):\n    """Get world position of a body."""\n    body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, body_name)\n    return data.xpos[body_id].copy()\n\ndef get_body_orientation(model, data, body_name):\n    """Get world orientation (rotation matrix) of a body."""\n    body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, body_name)\n    return data.xmat[body_id].reshape(3, 3).copy()\n\ndef compute_limb_fk(model, data, joint_angles, joint_names, end_effector):\n    """\n    Compute FK for a limb by setting joint angles.\n\n    Args:\n        model, data: MuJoCo model and data\n        joint_angles: Dict mapping joint names to angles\n        joint_names: List of joint names in the limb\n        end_effector: Name of end-effector body\n\n    Returns:\n        End-effector position and orientation\n    """\n    # Reset\n    mujoco.mj_resetData(model, data)\n\n    # Set joint angles\n    for jname, angle in joint_angles.items():\n        jnt_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, jname)\n```python\n```python\n        if jnt_id >= 0:\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"            qpos_addr = model.jnt_qposadr[jnt_id]\n            data.qpos[qpos_addr] = angle\n\n    # Forward kinematics\n    mujoco.mj_forward(model, data)\n\n    pos = get_body_position(model, data, end_effector)\n    ori = get_body_orientation(model, data, end_effector)\n\n    return pos, ori\n\n# Test FK for right arm\nright_arm_joints = ['right_shoulder1', 'right_shoulder2', 'right_elbow']\n\n# Set some joint angles\ntest_angles = {\n    'right_shoulder1': np.radians(45),\n    'right_shoulder2': np.radians(-30),\n    'right_elbow': np.radians(60),\n}\n\npos, ori = compute_limb_fk(model, data, test_angles, right_arm_joints, 'right_hand')\n\nprint(f\"Right hand FK result:\")\nprint(f\"  Position: {pos}\")\nprint(f\"  Orientation:\\n{ori}\")\n"})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Verification"}),": Change joint angles and observe how hand position changes."]})}),"\n",(0,i.jsx)(e.h3,{id:"step-3-implement-numerical-ik-for-humanoid",children:"Step 3: Implement Numerical IK for Humanoid"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def ik_cost_function(joint_values, model, data, joint_names, target_pos,\n                     target_body, weight_pos=1.0, weight_ori=0.0, target_ori=None):\n    """\n    Cost function for IK optimization.\n\n    Args:\n        joint_values: Array of joint angles to optimize\n        target_pos: Desired end-effector position\n        target_body: Name of end-effector body\n        weight_pos, weight_ori: Weights for position and orientation error\n        target_ori: Optional target orientation (3x3 matrix)\n    """\n    # Set joint values\n    mujoco.mj_resetData(model, data)\n\n    for i, jname in enumerate(joint_names):\n        jnt_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, jname)\n```python\n```python\n        if jnt_id >= 0:\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"            qpos_addr = model.jnt_qposadr[jnt_id]\n            data.qpos[qpos_addr] = joint_values[i]\n\n    mujoco.mj_forward(model, data)\n\n    # Position error\n    current_pos = get_body_position(model, data, target_body)\n    pos_error = np.sum((current_pos - target_pos)**2)\n\n    # Orientation error (optional)\n    ori_error = 0\n```python\n```python\n    if target_ori is not None and weight_ori > 0:\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"        current_ori = get_body_orientation(model, data, target_body)\n        ori_error = np.sum((current_ori - target_ori)**2)\n\n    return weight_pos * pos_error + weight_ori * ori_error\n\ndef solve_limb_ik(model, data, target_pos, joint_names, end_effector,\n                  initial_guess=None, bounds=None):\n    \"\"\"\n    Solve IK for a limb using numerical optimization.\n\n    Returns:\n        Dictionary of joint names to angles, or None if failed\n    \"\"\"\n    n_joints = len(joint_names)\n\n    if initial_guess is None:\n        initial_guess = np.zeros(n_joints)\n\n    if bounds is None:\n        # Default bounds: \xb1180 degrees\n        bounds = [(-np.pi, np.pi)] * n_joints\n\n    # Optimize\n    result = minimize(\n        ik_cost_function,\n        initial_guess,\n        args=(model, data, joint_names, target_pos, end_effector),\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 200, 'ftol': 1e-8}\n    )\n\n```python\n```python\n    if result.fun < 0.001:  # Converged close enough\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'        return {jname: angle for jname, angle in zip(joint_names, result.x)}\n    else:\n        print(f"IK failed to converge. Final error: {result.fun:.6f}")\n        return None\n\n# Test IK: Move right hand to specific position\ntarget_position = np.array([0.3, -0.3, 1.2])\n\nsolution = solve_limb_ik(\n    model, data,\n    target_pos=target_position,\n    joint_names=right_arm_joints,\n    end_effector=\'right_hand\'\n)\n\nif solution:\n    print(f"\\nIK Solution for target {target_position}:")\n    for jname, angle in solution.items():\n        print(f"  {jname}: {np.degrees(angle):.1f}\xb0")\n\n    # Verify\n    pos, _ = compute_limb_fk(model, data, solution, right_arm_joints, \'right_hand\')\n    error = np.linalg.norm(pos - target_position)\n    print(f"\\nVerification:")\n    print(f"  Achieved position: {pos}")\n    print(f"  Position error: {error:.6f} m")\n'})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Verification"}),": IK solution should place the hand close to target position."]})}),"\n",(0,i.jsx)(e.h3,{id:"step-4-multi-limb-coordination",children:"Step 4: Multi-Limb Coordination"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"def create_coordinated_pose(model, data, pose_spec):\n    \"\"\"\n    Create a coordinated pose with multiple limb targets.\n\n    Args:\n        pose_spec: Dictionary with structure:\n            {\n                'right_hand': {'pos': [x,y,z], 'joints': [...]},\n                'left_hand': {'pos': [x,y,z], 'joints': [...]},\n                ...\n            }\n\n    Returns:\n        Dictionary of all joint angles\n    \"\"\"\n    all_joints = {}\n\n    for limb_name, spec in pose_spec.items():\n        if 'pos' in spec and 'joints' in spec:\n            solution = solve_limb_ik(\n                model, data,\n                target_pos=np.array(spec['pos']),\n                joint_names=spec['joints'],\n                end_effector=limb_name\n            )\n            if solution:\n                all_joints.update(solution)\n            else:\n                print(f\"Warning: Could not solve IK for {limb_name}\")\n\n    return all_joints\n\n# Define a reaching pose\nreaching_pose = {\n    'right_hand': {\n        'pos': [0.4, -0.2, 1.3],\n        'joints': ['right_shoulder1', 'right_shoulder2', 'right_elbow']\n    },\n    'left_hand': {\n        'pos': [0.2, 0.3, 1.0],\n        'joints': ['left_shoulder1', 'left_shoulder2', 'left_elbow']\n    }\n}\n\nprint(\"Solving coordinated reaching pose...\")\npose_joints = create_coordinated_pose(model, data, reaching_pose)\n\nif pose_joints:\n    print(\"\\nCoordinated pose joint angles:\")\n    for jname, angle in sorted(pose_joints.items()):\n        print(f\"  {jname}: {np.degrees(angle):.1f}\xb0\")\n"})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Challenge"}),": Try creating different coordinated poses (arms up, reaching forward, etc.)"]})}),"\n",(0,i.jsx)(e.h3,{id:"step-5-visualize-the-pose",children:"Step 5: Visualize the Pose"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def apply_pose(model, data, joint_angles):\n    """Apply joint angles to the model."""\n    mujoco.mj_resetData(model, data)\n\n    for jname, angle in joint_angles.items():\n        jnt_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_JOINT, jname)\n```python\n```python\n        if jnt_id >= 0:\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'            qpos_addr = model.jnt_qposadr[jnt_id]\n            data.qpos[qpos_addr] = angle\n\n    # Lift humanoid off ground\n    data.qpos[2] = 1.4  # Z position\n\n    mujoco.mj_forward(model, data)\n\n# Apply the coordinated pose and visualize\nif pose_joints:\n    apply_pose(model, data, pose_joints)\n\n    # Record end-effector positions\n    print("\\nEnd-effector positions after applying pose:")\n    for ee in [\'right_hand\', \'left_hand\']:\n        pos = get_body_position(model, data, ee)\n        print(f"  {ee}: {pos}")\n\n    # Launch viewer (if available)\n    try:\n        print("\\nLaunching viewer - close window when done...")\n        with mujoco.viewer.launch_passive(model, data) as viewer:\n            while viewer.is_running():\n                mujoco.mj_step(model, data)\n                viewer.sync()\n    except Exception as e:\n        print(f"Viewer not available: {e}")\n        print("Pose applied successfully (run in environment with display for visualization)")\n'})}),"\n",(0,i.jsx)(e.h3,{id:"step-6-animate-a-trajectory",children:"Step 6: Animate a Trajectory"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"def interpolate_poses(pose1, pose2, num_steps=50):\n    \"\"\"Linearly interpolate between two poses.\"\"\"\n    poses = []\n    for t in np.linspace(0, 1, num_steps):\n        interp_pose = {}\n        all_joints = set(pose1.keys()) | set(pose2.keys())\n        for jname in all_joints:\n            angle1 = pose1.get(jname, 0)\n            angle2 = pose2.get(jname, 0)\n            interp_pose[jname] = angle1 + t * (angle2 - angle1)\n        poses.append(interp_pose)\n    return poses\n\n# Create start and end poses\nstart_pose = create_coordinated_pose(model, data, {\n    'right_hand': {\n        'pos': [0.3, -0.4, 0.8],\n        'joints': right_arm_joints\n    }\n})\n\nend_pose = create_coordinated_pose(model, data, {\n    'right_hand': {\n        'pos': [0.5, -0.2, 1.4],\n        'joints': right_arm_joints\n    }\n})\n\nif start_pose and end_pose:\n    # Generate trajectory\n    trajectory = interpolate_poses(start_pose, end_pose, num_steps=100)\n\n    print(f\"Generated trajectory with {len(trajectory)} waypoints\")\n\n    # Record hand positions along trajectory\n    hand_positions = []\n    for pose in trajectory:\n        apply_pose(model, data, pose)\n        pos = get_body_position(model, data, 'right_hand')\n        hand_positions.append(pos.copy())\n\n    hand_positions = np.array(hand_positions)\n\n    # Plot trajectory\n    import matplotlib.pyplot as plt\n    from mpl_toolkits.mplot3d import Axes3D\n\n    fig = plt.figure(figsize=(10, 8))\n    ax = fig.add_subplot(111, projection='3d')\n\n    ax.plot(hand_positions[:, 0], hand_positions[:, 1], hand_positions[:, 2],\n            'b-', linewidth=2, label='Hand trajectory')\n    ax.scatter(*hand_positions[0], c='g', s=100, marker='o', label='Start')\n    ax.scatter(*hand_positions[-1], c='r', s=100, marker='^', label='End')\n\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_zlabel('Z')\n    ax.set_title('Right Hand Trajectory (Joint Space Interpolation)')\n    ax.legend()\n\n    plt.savefig('hand_trajectory.png', dpi=150)\n    plt.show()\n"})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Observation"}),": Joint-space interpolation produces smooth joint motion but may not produce straight-line Cartesian motion."]})}),"\n",(0,i.jsx)(e.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Understanding of humanoid kinematic structure"}),"\n",(0,i.jsx)(e.li,{children:"Working FK for limb chains"}),"\n",(0,i.jsx)(e.li,{children:"Numerical IK for positioning end-effectors"}),"\n",(0,i.jsx)(e.li,{children:"Multi-limb coordinated poses"}),"\n",(0,i.jsx)(e.li,{children:"Animated trajectories with visualization"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"rubric",children:"Rubric"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Criterion"}),(0,i.jsx)(e.th,{children:"Points"}),(0,i.jsx)(e.th,{children:"Description"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Kinematic Analysis"}),(0,i.jsx)(e.td,{children:"15"}),(0,i.jsx)(e.td,{children:"Correct identification of joint chains"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"FK Implementation"}),(0,i.jsx)(e.td,{children:"20"}),(0,i.jsx)(e.td,{children:"Accurate forward kinematics"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"IK Solver"}),(0,i.jsx)(e.td,{children:"25"}),(0,i.jsx)(e.td,{children:"Working numerical IK with good convergence"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Multi-Limb Coordination"}),(0,i.jsx)(e.td,{children:"20"}),(0,i.jsx)(e.td,{children:"Successful coordinated poses"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Trajectory Generation"}),(0,i.jsx)(e.td,{children:"20"}),(0,i.jsx)(e.td,{children:"Smooth animated movement"})]})]})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Total: 100 points"})}),"\n",(0,i.jsx)(e.h2,{id:"extensions",children:"Extensions"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cartesian-Space Interpolation"}),": Implement straight-line motion in Cartesian space"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Full-Body IK"}),": Include torso and legs for whole-body reaching"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Obstacle Avoidance"}),": Add constraints to avoid self-collision"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Real-Time IK"}),": Optimize for speed to enable interactive control"]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},8453(n,e,t){t.d(e,{R:()=>a,x:()=>r});var o=t(6540);const i={},s=o.createContext(i);function a(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);