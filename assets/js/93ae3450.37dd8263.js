"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[283],{7825(e,n,t){t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"textbook/modules/rigid-body-dynamics/labs/lab-02-02","title":"Simulating Free Fall and Impact","description":"Objectives","source":"@site/docs/textbook/modules/02-rigid-body-dynamics/labs/lab-02-02.md","sourceDirName":"textbook/modules/02-rigid-body-dynamics/labs","slug":"/textbook/modules/rigid-body-dynamics/labs/lab-02-02","permalink":"/Hackathon-3/docs/textbook/modules/rigid-body-dynamics/labs/lab-02-02","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/02-rigid-body-dynamics/labs/lab-02-02.md","tags":[],"version":"current","frontMatter":{"id":"lab-02-02","module_id":"02","title":"Simulating Free Fall and Impact","difficulty":"intermediate","tier":"simulation","duration_minutes":75,"submission_format":"notebook","auto_gradable":true},"sidebar":"tutorialSidebar","previous":{"title":"Computing Rigid Body Forces","permalink":"/Hackathon-3/docs/textbook/modules/rigid-body-dynamics/labs/lab-02-01"},"next":{"title":"Torque-Motion Relationship","permalink":"/Hackathon-3/docs/textbook/modules/rigid-body-dynamics/labs/lab-02-03"}}');var s=t(4848),o=t(8453);const l={id:"lab-02-02",module_id:"02",title:"Simulating Free Fall and Impact",difficulty:"intermediate",tier:"simulation",duration_minutes:75,submission_format:"notebook",auto_gradable:!0},a="Lab 02-02: Simulating Free Fall and Impact",r={},d=[{value:"Objectives",id:"objectives",level:2},{value:"Materials",id:"materials",level:2},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Energy Conservation Analysis",id:"step-1-energy-conservation-analysis",level:3},{value:"Step 2: Coefficient of Restitution",id:"step-2-coefficient-of-restitution",level:3},{value:"Step 3: Two-Body Collision",id:"step-3-two-body-collision",level:3},{value:"Step 4: Vary Collision Parameters",id:"step-4-vary-collision-parameters",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"lab-02-02-simulating-free-fall-and-impact",children:"Lab 02-02: Simulating Free Fall and Impact"})}),"\n",(0,s.jsx)(n.h2,{id:"objectives",children:"Objectives"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Analyze energy conservation during free fall"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Study impact dynamics and coefficient of restitution"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understand momentum transfer during collisions"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Compare simulation results with analytical predictions"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"materials",children:"Materials"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Version"}),(0,s.jsx)(n.th,{children:"Tier"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"software"}),(0,s.jsx)(n.td,{children:"Python"}),(0,s.jsx)(n.td,{children:"3.10+"}),(0,s.jsx)(n.td,{children:"required"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"software"}),(0,s.jsx)(n.td,{children:"MuJoCo"}),(0,s.jsx)(n.td,{children:"3.0+"}),(0,s.jsx)(n.td,{children:"required"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"software"}),(0,s.jsx)(n.td,{children:"NumPy"}),(0,s.jsx)(n.td,{children:"1.24+"}),(0,s.jsx)(n.td,{children:"required"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"software"}),(0,s.jsx)(n.td,{children:"Matplotlib"}),(0,s.jsx)(n.td,{children:"3.5+"}),(0,s.jsx)(n.td,{children:"required"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"instructions",children:"Instructions"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-energy-conservation-analysis",children:"Step 1: Energy Conservation Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import mujoco\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create bouncing ball model\nball_xml = """\n<mujoco>\n  <option gravity="0 0 -9.81" timestep="0.0005"/>\n\n  <default>\n    <geom condim="1" solimp="0.9 0.95 0.001" solref="0.02 1"/>\n  </default>\n\n  <worldbody>\n    <light diffuse="1 1 1" pos="0 0 5"/>\n    <geom type="plane" size="5 5 0.1" rgba="0.8 0.8 0.8 1"/>\n\n    <body name="ball" pos="0 0 3">\n      <joint type="free"/>\n      <geom type="sphere" size="0.1" mass="1.0" rgba="1 0.2 0.2 1"/>\n    </body>\n  </worldbody>\n</mujoco>\n"""\n\nmodel = mujoco.MjModel.from_xml_string(ball_xml)\ndata = mujoco.MjData(model)\n\ndef compute_energy(model, data):\n    """Compute kinetic and potential energy."""\n    mass = model.body_mass[1]\n    height = data.qpos[2]\n    vel = np.linalg.norm(data.qvel[:3])\n\n    kinetic = 0.5 * mass * vel**2\n    potential = mass * 9.81 * height\n\n    return kinetic, potential\n\n# Simulate and record energy\nmujoco.mj_resetData(model, data)\n\ntimes = []\nkinetic_energy = []\npotential_energy = []\ntotal_energy = []\nheights = []\n\nfor _ in range(4000):  # 2 seconds\n    mujoco.mj_step(model, data)\n\n    ke, pe = compute_energy(model, data)\n    times.append(data.time)\n    kinetic_energy.append(ke)\n    potential_energy.append(pe)\n    total_energy.append(ke + pe)\n    heights.append(data.qpos[2])\n\n# Plot energy over time\nfig, axes = plt.subplots(2, 1, figsize=(12, 8))\n\naxes[0].plot(times, heights)\naxes[0].set_ylabel(\'Height (m)\')\naxes[0].set_title(\'Ball Trajectory\')\naxes[0].grid(True)\n\naxes[1].plot(times, kinetic_energy, label=\'Kinetic\', alpha=0.7)\naxes[1].plot(times, potential_energy, label=\'Potential\', alpha=0.7)\naxes[1].plot(times, total_energy, label=\'Total\', linewidth=2)\naxes[1].set_xlabel(\'Time (s)\')\naxes[1].set_ylabel(\'Energy (J)\')\naxes[1].set_title(\'Energy vs Time\')\naxes[1].legend()\naxes[1].grid(True)\n\nplt.tight_layout()\nplt.savefig(\'energy_analysis.png\', dpi=150)\nplt.show()\n\nprint(f"Initial total energy: {total_energy[0]:.3f} J")\nprint(f"Final total energy: {total_energy[-1]:.3f} J")\nprint(f"Energy loss: {(1 - total_energy[-1]/total_energy[0])*100:.1f}%")\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Expected"}),": Total energy should decrease at each bounce due to inelastic collision.\n",(0,s.jsx)(n.strong,{children:"Analysis"}),": Note how energy is lost during contact but conserved during flight."]})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-coefficient-of-restitution",children:"Step 2: Coefficient of Restitution"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def measure_restitution(model, data, drop_height):\n    """Measure coefficient of restitution from drop test."""\n    mujoco.mj_resetData(model, data)\n    data.qpos[2] = drop_height\n\n    bounce_heights = []\n    prev_height = drop_height\n    going_down = True\n    min_height_seen = drop_height\n\n    for _ in range(10000):\n        mujoco.mj_step(model, data)\n\n        height = data.qpos[2]\n        vel_z = data.qvel[2]\n\n        # Detect bounce (transition from going down to going up)\n```python\n```python\n        if going_down and vel_z > 0.1 and height < prev_height + 0.01:\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"            going_down = False\n            min_height_seen = height\n\n        # Detect peak (transition from going up to going down)\n```python\n```python\n        if not going_down and vel_z < -0.1:\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"            bounce_heights.append(prev_height)\n            going_down = True\n\n```python\n```python\n            if len(bounce_heights) >= 5:\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"                break\n\n        prev_height = height\n\n    # Compute coefficient of restitution\n    # e = sqrt(h_after / h_before) for each bounce\n    restitutions = []\n    heights_list = [drop_height] + bounce_heights\n\n    for i in range(len(heights_list) - 1):\n```python\n```python\n        if heights_list[i] > 0.01:  # Avoid division issues\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"            e = np.sqrt(heights_list[i+1] / heights_list[i])\n            restitutions.append(e)\n\n    return heights_list, restitutions\n\n# Test with different drop heights\ndrop_heights = [1.0, 2.0, 3.0]\nresults = {}\n\nfor h in drop_heights:\n    heights, e_values = measure_restitution(model, data, h)\n    results[h] = (heights, e_values)\n    print(f\"\\nDrop height {h}m:\")\n    print(f\"  Bounce heights: {[f'{hh:.3f}' for hh in heights]}\")\n    print(f\"  Restitution coefficients: {[f'{e:.3f}' for e in e_values]}\")\n    print(f\"  Average e: {np.mean(e_values):.3f}\")\n\n# Plot bounce decay\nfig, ax = plt.subplots(figsize=(10, 6))\n\nfor h, (heights, _) in results.items():\n    bounces = range(len(heights))\n    ax.plot(bounces, heights, 'o-', label=f'Drop from {h}m')\n\nax.set_xlabel('Bounce Number')\nax.set_ylabel('Height (m)')\nax.set_title('Bounce Height Decay')\nax.legend()\nax.grid(True)\nplt.savefig('bounce_decay.png', dpi=150)\nplt.show()\n"})}),"\n",(0,s.jsxs)("checkpoint",{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Analysis Questions"}),":"]}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Is the coefficient of restitution constant across bounces?"}),"\n",(0,s.jsx)(n.li,{children:"Does it depend on drop height (impact velocity)?"}),"\n"]})]}),"\n",(0,s.jsx)(n.h3,{id:"step-3-two-body-collision",children:"Step 3: Two-Body Collision"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Create two-ball collision model\ncollision_xml = """\n<mujoco>\n  <option gravity="0 0 0" timestep="0.0001"/>\n\n  <worldbody>\n    <light diffuse="1 1 1" pos="0 0 3"/>\n\n    <body name="ball1" pos="-1 0 1">\n      <joint type="free"/>\n      <geom type="sphere" size="0.1" mass="1.0" rgba="1 0.2 0.2 1"/>\n    </body>\n\n    <body name="ball2" pos="1 0 1">\n      <joint type="free"/>\n      <geom type="sphere" size="0.1" mass="1.0" rgba="0.2 0.2 1 1"/>\n    </body>\n  </worldbody>\n</mujoco>\n"""\n\nmodel2 = mujoco.MjModel.from_xml_string(collision_xml)\ndata2 = mujoco.MjData(model2)\n\n# Set initial velocities (head-on collision)\nmujoco.mj_resetData(model2, data2)\ndata2.qvel[0] = 2.0   # ball1 moving right\ndata2.qvel[6] = -1.0  # ball2 moving left\n\n# Record before collision\nm1 = model2.body_mass[1]\nm2 = model2.body_mass[2]\nv1_before = data2.qvel[0]\nv2_before = data2.qvel[6]\n\np_before = m1 * v1_before + m2 * v2_before\nke_before = 0.5 * m1 * v1_before**2 + 0.5 * m2 * v2_before**2\n\nprint("Before Collision:")\nprint(f"  Ball 1: v = {v1_before:.2f} m/s")\nprint(f"  Ball 2: v = {v2_before:.2f} m/s")\nprint(f"  Total momentum: {p_before:.2f} kg\u22c5m/s")\nprint(f"  Total KE: {ke_before:.2f} J")\n\n# Record trajectory\ntimes = []\nx1_positions = []\nx2_positions = []\nv1_velocities = []\nv2_velocities = []\nmomenta = []\n\nfor _ in range(5000):\n    mujoco.mj_step(model2, data2)\n\n    times.append(data2.time)\n    x1_positions.append(data2.qpos[0])\n    x2_positions.append(data2.qpos[7])\n    v1_velocities.append(data2.qvel[0])\n    v2_velocities.append(data2.qvel[6])\n    momenta.append(m1 * data2.qvel[0] + m2 * data2.qvel[6])\n\n# After collision\nv1_after = v1_velocities[-1]\nv2_after = v2_velocities[-1]\np_after = momenta[-1]\nke_after = 0.5 * m1 * v1_after**2 + 0.5 * m2 * v2_after**2\n\nprint("\\nAfter Collision:")\nprint(f"  Ball 1: v = {v1_after:.2f} m/s")\nprint(f"  Ball 2: v = {v2_after:.2f} m/s")\nprint(f"  Total momentum: {p_after:.2f} kg\u22c5m/s")\nprint(f"  Total KE: {ke_after:.2f} J")\nprint(f"\\nMomentum conservation: {abs(p_after - p_before) < 0.01}")\nprint(f"Energy loss: {(ke_before - ke_after):.3f} J ({(1-ke_after/ke_before)*100:.1f}%)")\n\n# Plot collision\nfig, axes = plt.subplots(3, 1, figsize=(10, 10))\n\naxes[0].plot(times, x1_positions, label=\'Ball 1\')\naxes[0].plot(times, x2_positions, label=\'Ball 2\')\naxes[0].set_ylabel(\'X Position (m)\')\naxes[0].legend()\naxes[0].grid(True)\n\naxes[1].plot(times, v1_velocities, label=\'Ball 1\')\naxes[1].plot(times, v2_velocities, label=\'Ball 2\')\naxes[1].set_ylabel(\'X Velocity (m/s)\')\naxes[1].legend()\naxes[1].grid(True)\n\naxes[2].plot(times, momenta)\naxes[2].axhline(y=p_before, color=\'r\', linestyle=\'--\', label=\'Initial\')\naxes[2].set_xlabel(\'Time (s)\')\naxes[2].set_ylabel(\'Total Momentum (kg\u22c5m/s)\')\naxes[2].legend()\naxes[2].grid(True)\n\nplt.tight_layout()\nplt.savefig(\'collision_analysis.png\', dpi=150)\nplt.show()\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Verification"}),": Momentum should be conserved. Energy may be lost (inelastic collision).\n",(0,s.jsx)(n.strong,{children:"Analysis"}),": Compare with theoretical predictions for elastic/inelastic collisions."]})}),"\n",(0,s.jsx)(n.h3,{id:"step-4-vary-collision-parameters",children:"Step 4: Vary Collision Parameters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def simulate_collision(e_coef, v1_init, v2_init):\n    """Simulate collision with given restitution coefficient."""\n    # Modify contact parameters\n    xml = f"""\n    <mujoco>\n      <option gravity="0 0 0" timestep="0.0001"/>\n      <default>\n        <geom condim="1" solimp="{e_coef} 0.95 0.001" solref="0.001 1"/>\n      </default>\n      <worldbody>\n        <body name="ball1" pos="-0.5 0 0">\n          <joint type="free"/>\n          <geom type="sphere" size="0.1" mass="1.0"/>\n        </body>\n        <body name="ball2" pos="0.5 0 0">\n          <joint type="free"/>\n          <geom type="sphere" size="0.1" mass="2.0"/>\n        </body>\n      </worldbody>\n    </mujoco>\n    """\n\n    m = mujoco.MjModel.from_xml_string(xml)\n    d = mujoco.MjData(m)\n\n    d.qvel[0] = v1_init\n    d.qvel[6] = v2_init\n\n    # Run until well after collision\n    for _ in range(5000):\n        mujoco.mj_step(m, d)\n\n    return d.qvel[0], d.qvel[6]\n\n# Compare with analytical solution for 1D elastic collision\n# v1\' = ((m1-m2)*v1 + 2*m2*v2) / (m1+m2)\n# v2\' = ((m2-m1)*v2 + 2*m1*v1) / (m1+m2)\n\nm1, m2 = 1.0, 2.0\nv1, v2 = 3.0, -1.0\n\n# Analytical (perfectly elastic)\nv1_elastic = ((m1-m2)*v1 + 2*m2*v2) / (m1+m2)\nv2_elastic = ((m2-m1)*v2 + 2*m1*v1) / (m1+m2)\n\nprint("Analytical Solution (elastic collision):")\nprint(f"  v1\' = {v1_elastic:.3f} m/s")\nprint(f"  v2\' = {v2_elastic:.3f} m/s")\n\n# Simulate with different restitution values\nprint("\\nSimulated Results:")\nfor e in [0.5, 0.7, 0.9, 0.99]:\n    v1_sim, v2_sim = simulate_collision(e, v1, v2)\n    print(f"  e={e}: v1\'={v1_sim:.3f}, v2\'={v2_sim:.3f}")\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Analysis"}),": As restitution approaches 1.0, results should approach elastic collision."]})}),"\n",(0,s.jsx)(n.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Energy analysis showing conservation during flight, loss during contact"}),"\n",(0,s.jsx)(n.li,{children:"Coefficient of restitution measurements"}),"\n",(0,s.jsx)(n.li,{children:"Momentum conservation verification"}),"\n",(0,s.jsx)(n.li,{children:"Comparison with analytical collision predictions"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"rubric",children:"Rubric"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Criterion"}),(0,s.jsx)(n.th,{children:"Points"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Energy Analysis"}),(0,s.jsx)(n.td,{children:"25"}),(0,s.jsx)(n.td,{children:"Correctly tracks and analyzes energy"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Restitution Measurement"}),(0,s.jsx)(n.td,{children:"25"}),(0,s.jsx)(n.td,{children:"Accurately measures coefficient"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Collision Dynamics"}),(0,s.jsx)(n.td,{children:"25"}),(0,s.jsx)(n.td,{children:"Momentum/energy analysis"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Parameter Study"}),(0,s.jsx)(n.td,{children:"15"}),(0,s.jsx)(n.td,{children:"Systematic variation of parameters"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Visualization"}),(0,s.jsx)(n.td,{children:"10"}),(0,s.jsx)(n.td,{children:"Clear, informative plots"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Total: 100 points"})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>l,x:()=>a});var i=t(6540);const s={},o=i.createContext(s);function l(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);