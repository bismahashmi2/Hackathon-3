"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[2537],{5940(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"textbook/modules/sensors-perception/labs/lab-04-01","title":"Reading IMU Data in MuJoCo","description":"Objectives","source":"@site/docs/textbook/modules/04-sensors-perception/labs/lab-04-01.md","sourceDirName":"textbook/modules/04-sensors-perception/labs","slug":"/textbook/modules/sensors-perception/labs/lab-04-01","permalink":"/Hackathon-3/docs/textbook/modules/sensors-perception/labs/lab-04-01","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/04-sensors-perception/labs/lab-04-01.md","tags":[],"version":"current","frontMatter":{"id":"lab-04-01","module_id":"04","title":"Reading IMU Data in MuJoCo","difficulty":"guided","tier":"simulation","duration_minutes":60},"sidebar":"tutorialSidebar","previous":{"title":"Ethics in Sensors and Perception","permalink":"/Hackathon-3/docs/textbook/modules/sensors-perception/ethics"},"next":{"title":"Camera Image Processing for Robotics","permalink":"/Hackathon-3/docs/textbook/modules/sensors-perception/labs/lab-04-02"}}');var a=s(4848),t=s(8453);const l={id:"lab-04-01",module_id:"04",title:"Reading IMU Data in MuJoCo",difficulty:"guided",tier:"simulation",duration_minutes:60},r="Lab 04-01: Reading IMU Data in MuJoCo",o={},d=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Understanding the Sensor Model",id:"step-1-understanding-the-sensor-model",level:3},{value:"Step 2: Reading Sensor Data",id:"step-2-reading-sensor-data",level:3},{value:"Step 3: Collecting Time-Series Data",id:"step-3-collecting-time-series-data",level:3},{value:"Step 4: Visualizing Sensor Data",id:"step-4-visualizing-sensor-data",level:3},{value:"Step 5: Adding Sensor Noise",id:"step-5-adding-sensor-noise",level:3},{value:"Step 6: Simple Low-Pass Filter",id:"step-6-simple-low-pass-filter",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2},{value:"Common Errors",id:"common-errors",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Related Content",id:"related-content",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"lab-04-01-reading-imu-data-in-mujoco",children:"Lab 04-01: Reading IMU Data in MuJoCo"})}),"\n",(0,a.jsx)(n.h2,{id:"objectives",children:"Objectives"}),"\n",(0,a.jsx)(n.p,{children:"By the end of this lab, you will be able to:"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Access accelerometer and gyroscope data from a simulated IMU sensor"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understand the relationship between sensor readings and robot motion"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Visualize IMU data in real-time during simulation"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement basic noise filtering on sensor readings"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Completed Module 01 labs (MuJoCo basics)"}),"\n",(0,a.jsx)(n.li,{children:"Understanding of coordinate frames and transformations"}),"\n",(0,a.jsx)(n.li,{children:"Basic Python programming with NumPy"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"materials",children:"Materials"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Type"}),(0,a.jsx)(n.th,{children:"Name"}),(0,a.jsx)(n.th,{children:"Tier"}),(0,a.jsx)(n.th,{children:"Notes"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"software"}),(0,a.jsx)(n.td,{children:"MuJoCo 3.0+"}),(0,a.jsx)(n.td,{children:"required"}),(0,a.jsx)(n.td,{children:"Physics simulation"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"software"}),(0,a.jsx)(n.td,{children:"Python 3.10+"}),(0,a.jsx)(n.td,{children:"required"}),(0,a.jsx)(n.td,{children:"Programming environment"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"software"}),(0,a.jsx)(n.td,{children:"NumPy, Matplotlib"}),(0,a.jsx)(n.td,{children:"required"}),(0,a.jsx)(n.td,{children:"Data processing and visualization"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"simulation"}),(0,a.jsx)(n.td,{children:"humanoid-sensors.xml"}),(0,a.jsx)(n.td,{children:"required"}),(0,a.jsx)(n.td,{children:"Humanoid model with sensors"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,a.jsx)(n.p,{children:"Inertial Measurement Units (IMUs) are fundamental sensors in robotics, combining:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Accelerometers"}),": Measure linear acceleration (including gravity)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Gyroscopes"}),": Measure angular velocity"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Magnetometers"})," (optional): Measure magnetic field for heading"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In MuJoCo, sensor data is accessed through the ",(0,a.jsx)(n.code,{children:"data.sensordata"})," array, which contains readings from all defined sensors in the order they appear in the model XML."]}),"\n",(0,a.jsx)(n.h2,{id:"instructions",children:"Instructions"}),"\n",(0,a.jsx)(n.h3,{id:"step-1-understanding-the-sensor-model",children:"Step 1: Understanding the Sensor Model"}),"\n",(0,a.jsx)(n.p,{children:"First, examine the sensor definitions in the humanoid model:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import mujoco\nimport numpy as np\n\n# Load the model\nmodel = mujoco.MjModel.from_xml_path("textbook/assets/robot-models/mujoco/humanoid-sensors.xml")\ndata = mujoco.MjData(model)\n\n# List all sensors\nprint("Available sensors:")\nfor i in range(model.nsensor):\n    name = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_SENSOR, i)\n    sensor_type = model.sensor_type[i]\n    dim = model.sensor_dim[i]\n    print(f"  {name}: type={sensor_type}, dim={dim}")\n'})}),"\n",(0,a.jsx)("checkpoint",{children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Expected"}),": You should see sensors including ",(0,a.jsx)(n.code,{children:"torso_accelerometer"})," (dim=3) and ",(0,a.jsx)(n.code,{children:"torso_gyroscope"})," (dim=3)."]})}),"\n",(0,a.jsx)(n.h3,{id:"step-2-reading-sensor-data",children:"Step 2: Reading Sensor Data"}),"\n",(0,a.jsx)(n.p,{children:"Access the IMU readings during simulation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def get_imu_readings(model, data, accel_sensor_id, gyro_sensor_id):\n    """\n    Extract accelerometer and gyroscope readings from sensor data.\n\n    Args:\n        model: MuJoCo model\n        data: MuJoCo data\n        accel_sensor_id: Sensor ID for accelerometer\n        gyro_sensor_id: Sensor ID for gyroscope\n\n    Returns:\n        Tuple of (acceleration [3], angular_velocity [3])\n    """\n    # Get sensor data addresses\n    accel_adr = model.sensor_adr[accel_sensor_id]\n    gyro_adr = model.sensor_adr[gyro_sensor_id]\n\n    # Extract readings (each is 3D)\n    acceleration = data.sensordata[accel_adr:accel_adr+3].copy()\n    angular_velocity = data.sensordata[gyro_adr:gyro_adr+3].copy()\n\n    return acceleration, angular_velocity\n\n# Get sensor IDs\naccel_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_SENSOR, "torso_accelerometer")\ngyro_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_SENSOR, "torso_gyroscope")\n\n# Step simulation and read sensors\nmujoco.mj_step(model, data)\naccel, gyro = get_imu_readings(model, data, accel_id, gyro_id)\nprint(f"Acceleration: {accel}")\nprint(f"Angular velocity: {gyro}")\n'})}),"\n",(0,a.jsx)("checkpoint",{children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Expected"}),": Standing still, accelerometer should read approximately [0, 0, -9.81] (gravity in z-down frame)."]})}),"\n",(0,a.jsx)(n.h3,{id:"step-3-collecting-time-series-data",children:"Step 3: Collecting Time-Series Data"}),"\n",(0,a.jsx)(n.p,{children:"Run a simulation while collecting sensor data:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import matplotlib.pyplot as plt\n\ndef simulate_and_collect(model, data, duration_seconds=5.0):\n    \"\"\"\n    Run simulation and collect IMU data.\n\n    Returns:\n        Dictionary with time, acceleration, and angular velocity arrays\n    \"\"\"\n    dt = model.opt.timestep\n    n_steps = int(duration_seconds / dt)\n\n    # Pre-allocate arrays\n    times = np.zeros(n_steps)\n    accelerations = np.zeros((n_steps, 3))\n    angular_velocities = np.zeros((n_steps, 3))\n\n    # Reset simulation\n    mujoco.mj_resetData(model, data)\n\n    # Apply initial perturbation (push the robot)\n    data.qvel[0] = 0.5  # Forward velocity\n\n    for i in range(n_steps):\n        mujoco.mj_step(model, data)\n\n        times[i] = data.time\n        accel, gyro = get_imu_readings(model, data, accel_id, gyro_id)\n        accelerations[i] = accel\n        angular_velocities[i] = gyro\n\n    return {\n        'time': times,\n        'acceleration': accelerations,\n        'angular_velocity': angular_velocities\n    }\n\n# Collect data\nimu_data = simulate_and_collect(model, data, duration_seconds=3.0)\n"})}),"\n",(0,a.jsx)("checkpoint",{children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Expected"}),": Data collection completes without errors. Arrays should have consistent shapes."]})}),"\n",(0,a.jsx)(n.h3,{id:"step-4-visualizing-sensor-data",children:"Step 4: Visualizing Sensor Data"}),"\n",(0,a.jsx)(n.p,{children:"Create plots to understand the sensor behavior:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def plot_imu_data(imu_data):\n    \"\"\"Plot accelerometer and gyroscope data.\"\"\"\n    fig, axes = plt.subplots(2, 1, figsize=(12, 8), sharex=True)\n\n    # Accelerometer plot\n    axes[0].plot(imu_data['time'], imu_data['acceleration'][:, 0], label='X')\n    axes[0].plot(imu_data['time'], imu_data['acceleration'][:, 1], label='Y')\n    axes[0].plot(imu_data['time'], imu_data['acceleration'][:, 2], label='Z')\n    axes[0].set_ylabel('Acceleration (m/s\xb2)')\n    axes[0].set_title('Accelerometer Readings')\n    axes[0].legend()\n    axes[0].grid(True)\n    axes[0].axhline(y=-9.81, color='k', linestyle='--', alpha=0.3, label='Gravity')\n\n    # Gyroscope plot\n    axes[1].plot(imu_data['time'], imu_data['angular_velocity'][:, 0], label='Roll rate')\n    axes[1].plot(imu_data['time'], imu_data['angular_velocity'][:, 1], label='Pitch rate')\n    axes[1].plot(imu_data['time'], imu_data['angular_velocity'][:, 2], label='Yaw rate')\n    axes[1].set_xlabel('Time (s)')\n    axes[1].set_ylabel('Angular Velocity (rad/s)')\n    axes[1].set_title('Gyroscope Readings')\n    axes[1].legend()\n    axes[1].grid(True)\n\n    plt.tight_layout()\n    plt.savefig('imu_data.png', dpi=150)\n    plt.show()\n\nplot_imu_data(imu_data)\n"})}),"\n",(0,a.jsx)("checkpoint",{children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Expected"}),": Two subplot figure showing acceleration and angular velocity over time. Z-acceleration should hover around -9.81 m/s\xb2 when upright."]})}),"\n",(0,a.jsx)(n.h3,{id:"step-5-adding-sensor-noise",children:"Step 5: Adding Sensor Noise"}),"\n",(0,a.jsx)(n.p,{children:"Real IMU sensors have noise. Implement a simple noise model:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class NoisyIMU:\n    """\n    Wrapper that adds realistic noise to IMU readings.\n\n    Typical noise characteristics:\n    - Accelerometer: ~0.01-0.1 m/s\xb2 standard deviation\n    - Gyroscope: ~0.001-0.01 rad/s standard deviation\n    """\n\n    def __init__(self, model, data, accel_id, gyro_id,\n                 accel_noise_std=0.05, gyro_noise_std=0.005,\n                 accel_bias=None, gyro_bias=None):\n        self.model = model\n        self.data = data\n        self.accel_id = accel_id\n        self.gyro_id = gyro_id\n        self.accel_noise_std = accel_noise_std\n        self.gyro_noise_std = gyro_noise_std\n\n        # Random bias (constant offset)\n        self.accel_bias = accel_bias if accel_bias is not None else np.random.normal(0, 0.1, 3)\n        self.gyro_bias = gyro_bias if gyro_bias is not None else np.random.normal(0, 0.01, 3)\n\n    def read(self):\n        """Get noisy IMU readings."""\n        accel, gyro = get_imu_readings(self.model, self.data, self.accel_id, self.gyro_id)\n\n        # Add Gaussian noise\n        accel_noisy = accel + np.random.normal(0, self.accel_noise_std, 3) + self.accel_bias\n        gyro_noisy = gyro + np.random.normal(0, self.gyro_noise_std, 3) + self.gyro_bias\n\n        return accel_noisy, gyro_noisy\n\n# Create noisy IMU\nnoisy_imu = NoisyIMU(model, data, accel_id, gyro_id)\n\n# Compare clean vs noisy readings\nmujoco.mj_step(model, data)\nclean_accel, clean_gyro = get_imu_readings(model, data, accel_id, gyro_id)\nnoisy_accel, noisy_gyro = noisy_imu.read()\n\nprint(f"Clean acceleration: {clean_accel}")\nprint(f"Noisy acceleration: {noisy_accel}")\nprint(f"Difference: {noisy_accel - clean_accel}")\n'})}),"\n",(0,a.jsx)("checkpoint",{children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Expected"}),": Noisy readings should differ from clean readings by small amounts (typically < 0.2 m/s\xb2 for acceleration)."]})}),"\n",(0,a.jsx)(n.h3,{id:"step-6-simple-low-pass-filter",children:"Step 6: Simple Low-Pass Filter"}),"\n",(0,a.jsx)(n.p,{children:"Implement basic noise filtering:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class LowPassFilter:\n    \"\"\"\n    Simple exponential moving average filter.\n\n    y[n] = alpha * x[n] + (1 - alpha) * y[n-1]\n    \"\"\"\n\n    def __init__(self, alpha=0.1, initial_value=None):\n        \"\"\"\n        Args:\n            alpha: Filter coefficient (0-1). Lower = more smoothing.\n            initial_value: Initial filter state\n        \"\"\"\n        self.alpha = alpha\n        self.value = initial_value\n\n    def update(self, measurement):\n        \"\"\"Update filter with new measurement.\"\"\"\n        if self.value is None:\n            self.value = measurement.copy()\n        else:\n            self.value = self.alpha * measurement + (1 - self.alpha) * self.value\n        return self.value.copy()\n\n# Test filtering\naccel_filter = LowPassFilter(alpha=0.1)\ngyro_filter = LowPassFilter(alpha=0.1)\n\n# Collect filtered data\nn_samples = 500\nraw_data = np.zeros((n_samples, 3))\nfiltered_data = np.zeros((n_samples, 3))\n\nmujoco.mj_resetData(model, data)\nfor i in range(n_samples):\n    mujoco.mj_step(model, data)\n    noisy_accel, _ = noisy_imu.read()\n    raw_data[i] = noisy_accel\n    filtered_data[i] = accel_filter.update(noisy_accel)\n\n# Plot comparison\nplt.figure(figsize=(12, 4))\nplt.plot(raw_data[:, 2], alpha=0.5, label='Raw Z-acceleration')\nplt.plot(filtered_data[:, 2], label='Filtered Z-acceleration')\nplt.axhline(y=-9.81, color='k', linestyle='--', alpha=0.3, label='True gravity')\nplt.xlabel('Sample')\nplt.ylabel('Acceleration (m/s\xb2)')\nplt.title('Low-Pass Filtering of Noisy IMU Data')\nplt.legend()\nplt.grid(True)\nplt.savefig('filtered_imu.png', dpi=150)\nplt.show()\n"})}),"\n",(0,a.jsx)("checkpoint",{children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Expected"}),": Filtered signal should be smoother than raw signal, tracking close to -9.81 m/s\xb2 for Z-axis."]})}),"\n",(0,a.jsx)(n.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,a.jsx)(n.p,{children:"After completing this lab, you should have:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Code artifacts"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"imu_reader.py"}),": Functions for reading IMU data from MuJoCo"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"noisy_imu.py"}),": Noise model wrapper class"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"filters.py"}),": Low-pass filter implementation"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Visual outputs"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"imu_data.png"}),": Time-series plot of accelerometer and gyroscope data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"filtered_imu.png"}),": Comparison of raw vs filtered sensor data"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Understanding"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"How MuJoCo organizes sensor data"}),"\n",(0,a.jsx)(n.li,{children:"The structure of IMU measurements"}),"\n",(0,a.jsx)(n.li,{children:"Basic noise modeling and filtering techniques"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"rubric",children:"Rubric"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Criterion"}),(0,a.jsx)(n.th,{children:"Points"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Sensor access"}),(0,a.jsx)(n.td,{children:"20"}),(0,a.jsx)(n.td,{children:"Correctly reads accelerometer and gyroscope data"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Data collection"}),(0,a.jsx)(n.td,{children:"20"}),(0,a.jsx)(n.td,{children:"Properly collects time-series data during simulation"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Visualization"}),(0,a.jsx)(n.td,{children:"20"}),(0,a.jsx)(n.td,{children:"Creates clear, labeled plots of sensor data"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Noise model"}),(0,a.jsx)(n.td,{children:"20"}),(0,a.jsx)(n.td,{children:"Implements realistic noise with bias and variance"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Filtering"}),(0,a.jsx)(n.td,{children:"20"}),(0,a.jsx)(n.td,{children:"Low-pass filter reduces noise while preserving signal"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Total"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"100"})}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"common-errors",children:"Common Errors"}),"\n",(0,a.jsxs)("troubleshooting",{children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Error"}),": Sensor ID not found\n",(0,a.jsx)(n.strong,{children:"Solution"}),": Check sensor names in your XML model file. Use ",(0,a.jsx)(n.code,{children:"mujoco.mj_id2name()"})," to list available sensors."]}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Error"}),": Array index out of bounds when reading sensor data\n",(0,a.jsx)(n.strong,{children:"Solution"}),": Verify ",(0,a.jsx)(n.code,{children:"sensor_adr"})," and ",(0,a.jsx)(n.code,{children:"sensor_dim"})," match your sensor configuration."]}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Error"}),": Accelerometer shows [0, 0, 0] when robot is stationary\n",(0,a.jsx)(n.strong,{children:"Solution"}),": Ensure the model has gravity enabled and the sensor is properly attached to a body."]})]}),"\n",(0,a.jsx)(n.h2,{id:"extensions",children:"Extensions"}),"\n",(0,a.jsx)(n.p,{children:"For advanced students:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Complementary Filter"}),": Combine accelerometer and gyroscope data to estimate orientation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Allan Variance"}),": Characterize sensor noise using Allan variance analysis"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multiple IMUs"}),": Read from multiple IMU sensors placed at different body locations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Real-time Visualization"}),": Create a live-updating plot during simulation"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"related-content",children:"Related Content"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Theory"}),": Module 04 theory.md, Section 4.1 (Inertial Measurement Units)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Next Lab"}),": Lab 04-02 (Camera Image Processing)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Case Study"}),": See ANYmal inspection case study for real-world IMU usage"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453(e,n,s){s.d(n,{R:()=>l,x:()=>r});var i=s(6540);const a={},t=i.createContext(a);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);