"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[3145],{317(n,e,i){i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"textbook/modules/motion-planning/labs/lab-06-02","title":"A* Path Planning with Heuristics","description":"Objectives","source":"@site/docs/textbook/modules/06-motion-planning/labs/lab-06-02.md","sourceDirName":"textbook/modules/06-motion-planning/labs","slug":"/textbook/modules/motion-planning/labs/lab-06-02","permalink":"/Hackathon-3/docs/textbook/modules/motion-planning/labs/lab-06-02","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/06-motion-planning/labs/lab-06-02.md","tags":[],"version":"current","frontMatter":{"id":"lab-06-02","module_id":"06","title":"A* Path Planning with Heuristics","difficulty":"intermediate","tier":"simulation","duration_minutes":90},"sidebar":"tutorialSidebar","previous":{"title":"RRT Path Planning","permalink":"/Hackathon-3/docs/textbook/modules/motion-planning/labs/lab-06-01"},"next":{"title":"Trajectory Optimization","permalink":"/Hackathon-3/docs/textbook/modules/motion-planning/labs/lab-06-03"}}');var s=i(4848),r=i(8453);const o={id:"lab-06-02",module_id:"06",title:"A* Path Planning with Heuristics",difficulty:"intermediate",tier:"simulation",duration_minutes:90},l="Lab 06-02: A* Path Planning with Heuristics",a={},d=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Materials",id:"materials",level:2},{value:"Background",id:"background",level:2},{value:"A* Algorithm",id:"a-algorithm",level:3},{value:"Heuristics for Grid Planning",id:"heuristics-for-grid-planning",level:3},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Set Up the Grid Environment",id:"step-1-set-up-the-grid-environment",level:3},{value:"Step 2: Implement Heuristic Functions",id:"step-2-implement-heuristic-functions",level:3},{value:"Step 3: Implement A* Algorithm",id:"step-3-implement-a-algorithm",level:3},{value:"Step 4: Compare Heuristics",id:"step-4-compare-heuristics",level:3},{value:"Step 5: Visualize Heuristic Comparison",id:"step-5-visualize-heuristic-comparison",level:3},{value:"Step 6: Apply to Configuration Space",id:"step-6-apply-to-configuration-space",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2},{value:"Common Errors",id:"common-errors",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Related Content",id:"related-content",level:2}];function c(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"lab-06-02-a-path-planning-with-heuristics",children:"Lab 06-02: A* Path Planning with Heuristics"})}),"\n",(0,s.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this lab, you will be able to:"}),"\n",(0,s.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Implement the A* search algorithm for grid-based planning"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Design and compare different heuristic functions"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Understand admissibility and consistency of heuristics"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Apply A* to robot configuration space planning"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Completed Lab 06-01 (RRT Path Planning)"}),"\n",(0,s.jsx)(e.li,{children:"Understanding of graph search algorithms"}),"\n",(0,s.jsx)(e.li,{children:"Basic data structures (priority queues)"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"materials",children:"Materials"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Type"}),(0,s.jsx)(e.th,{children:"Name"}),(0,s.jsx)(e.th,{children:"Tier"}),(0,s.jsx)(e.th,{children:"Notes"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"software"}),(0,s.jsx)(e.td,{children:"Python 3.10+"}),(0,s.jsx)(e.td,{children:"required"}),(0,s.jsx)(e.td,{children:"Programming environment"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"software"}),(0,s.jsx)(e.td,{children:"NumPy, Matplotlib, heapq"}),(0,s.jsx)(e.td,{children:"required"}),(0,s.jsx)(e.td,{children:"Computation and visualization"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"simulation"}),(0,s.jsx)(e.td,{children:"Grid world environments"}),(0,s.jsx)(e.td,{children:"required"}),(0,s.jsx)(e.td,{children:"2D planning scenarios"})]})]})]}),"\n",(0,s.jsx)(e.h2,{id:"background",children:"Background"}),"\n",(0,s.jsx)(e.h3,{id:"a-algorithm",children:"A* Algorithm"}),"\n",(0,s.jsx)(e.p,{children:"A* is an optimal graph search algorithm that uses:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"g(n)"}),": Cost from start to node n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"h(n)"}),": Heuristic estimate from n to goal"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"f(n) = g(n) + h(n)"}),": Total estimated cost"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"A* expands nodes in order of lowest f(n), guaranteeing optimality when h(n) is admissible (never overestimates)."}),"\n",(0,s.jsx)(e.h3,{id:"heuristics-for-grid-planning",children:"Heuristics for Grid Planning"}),"\n",(0,s.jsx)(e.p,{children:"Common heuristics:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Manhattan distance"}),": |x\u2081-x\u2082| + |y\u2081-y\u2082| (4-connected grid)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Euclidean distance"}),": \u221a((x\u2081-x\u2082)\xb2 + (y\u2081-y\u2082)\xb2)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Diagonal distance"}),": max(|\u0394x|, |\u0394y|) + (\u221a2-1)\xb7min(|\u0394x|, |\u0394y|)"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"instructions",children:"Instructions"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-set-up-the-grid-environment",children:"Step 1: Set Up the Grid Environment"}),"\n",(0,s.jsx)(e.p,{children:"Create a 2D occupancy grid with obstacles:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import numpy as np\nimport matplotlib.pyplot as plt\nimport heapq\nfrom collections import defaultdict\n\nclass GridWorld:\n    """2D grid environment for path planning."""\n\n    def __init__(self, width, height, obstacle_ratio=0.2):\n        """\n        Create grid world with random obstacles.\n\n        Args:\n            width, height: Grid dimensions\n            obstacle_ratio: Fraction of cells that are obstacles\n        """\n        self.width = width\n        self.height = height\n\n        # Create grid (0 = free, 1 = obstacle)\n        self.grid = np.zeros((height, width), dtype=int)\n\n        # Add random obstacles\n        n_obstacles = int(width * height * obstacle_ratio)\n        obstacle_indices = np.random.choice(width * height, n_obstacles, replace=False)\n        for idx in obstacle_indices:\n            y, x = divmod(idx, width)\n            self.grid[y, x] = 1\n\n    def add_rectangular_obstacle(self, x1, y1, x2, y2):\n        """Add rectangular obstacle."""\n        self.grid[y1:y2, x1:x2] = 1\n\n    def is_valid(self, x, y):\n        """Check if position is valid (in bounds and free)."""\n```python\n```python\n        return (0 <= x < self.width and\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'                0 <= y < self.height and\n                self.grid[y, x] == 0)\n\n    def get_neighbors(self, x, y, connectivity=8):\n        """\n        Get valid neighboring cells.\n\n        Args:\n            connectivity: 4 (cardinal) or 8 (with diagonals)\n        """\n```python\n```python\n        if connectivity == 4:\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"            directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        else:\n            directions = [(0, 1), (1, 0), (0, -1), (-1, 0),\n                         (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n        neighbors = []\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if self.is_valid(nx, ny):\n                # Cost: 1 for cardinal, sqrt(2) for diagonal\n                cost = np.sqrt(dx*dx + dy*dy)\n                neighbors.append((nx, ny, cost))\n        return neighbors\n\n    def visualize(self, path=None, start=None, goal=None, explored=None):\n        \"\"\"Visualize grid with optional path.\"\"\"\n        fig, ax = plt.subplots(figsize=(10, 10))\n\n        # Show grid\n        ax.imshow(self.grid, cmap='binary', origin='lower')\n\n        # Show explored cells\n        if explored:\n            for (x, y) in explored:\n                ax.plot(x, y, 'c.', markersize=3, alpha=0.3)\n\n        # Show path\n        if path:\n            path_x = [p[0] for p in path]\n            path_y = [p[1] for p in path]\n            ax.plot(path_x, path_y, 'b-', linewidth=2, label='Path')\n\n        # Show start and goal\n        if start:\n            ax.plot(start[0], start[1], 'go', markersize=15, label='Start')\n        if goal:\n            ax.plot(goal[0], goal[1], 'r*', markersize=15, label='Goal')\n\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.legend()\n        ax.set_title(f'Grid World ({self.width}x{self.height})')\n\n        return fig, ax\n\n# Create environment\nnp.random.seed(42)\nworld = GridWorld(50, 50, obstacle_ratio=0.0)\n\n# Add structured obstacles\nworld.add_rectangular_obstacle(10, 10, 15, 40)\nworld.add_rectangular_obstacle(25, 5, 30, 35)\nworld.add_rectangular_obstacle(35, 20, 45, 25)\n\n# Define start and goal\nstart = (5, 5)\ngoal = (45, 45)\n\n# Ensure start and goal are free\nworld.grid[start[1], start[0]] = 0\nworld.grid[goal[1], goal[0]] = 0\n\nworld.visualize(start=start, goal=goal)\nplt.savefig('grid_world.png', dpi=150)\nplt.show()\n"})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": Grid visualization showing obstacles, start (green), and goal (red)."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-2-implement-heuristic-functions",children:"Step 2: Implement Heuristic Functions"}),"\n",(0,s.jsx)(e.p,{children:"Create multiple heuristics for comparison:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def manhattan_distance(p1, p2):\n    """Manhattan (L1) distance - admissible for 4-connected grid."""\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef euclidean_distance(p1, p2):\n    """Euclidean (L2) distance - admissible for any grid."""\n    return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef diagonal_distance(p1, p2):\n    """Octile distance - admissible for 8-connected grid."""\n    dx = abs(p1[0] - p2[0])\n    dy = abs(p1[1] - p2[1])\n    return max(dx, dy) + (np.sqrt(2) - 1) * min(dx, dy)\n\ndef chebyshev_distance(p1, p2):\n    """Chebyshev (L\u221e) distance."""\n    return max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1]))\n\ndef zero_heuristic(p1, p2):\n    """Zero heuristic - turns A* into Dijkstra\'s algorithm."""\n    return 0\n\n# Test heuristics\ntest_start = (0, 0)\ntest_goal = (10, 10)\n\nprint("Heuristic comparison for (0,0) to (10,10):")\nprint(f"  Manhattan: {manhattan_distance(test_start, test_goal):.2f}")\nprint(f"  Euclidean: {euclidean_distance(test_start, test_goal):.2f}")\nprint(f"  Diagonal:  {diagonal_distance(test_start, test_goal):.2f}")\nprint(f"  Chebyshev: {chebyshev_distance(test_start, test_goal):.2f}")\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": Different heuristic values - Euclidean \u2248 14.14, Manhattan = 20, Diagonal \u2248 14.14."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-3-implement-a-algorithm",children:"Step 3: Implement A* Algorithm"}),"\n",(0,s.jsx)(e.p,{children:"Build the core A* search:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class AStarPlanner:\n    """A* path planning algorithm."""\n\n    def __init__(self, world, heuristic=euclidean_distance, connectivity=8):\n        """\n        Initialize A* planner.\n\n        Args:\n            world: GridWorld instance\n            heuristic: Heuristic function h(current, goal)\n            connectivity: 4 or 8 connected grid\n        """\n        self.world = world\n        self.heuristic = heuristic\n        self.connectivity = connectivity\n\n        # Statistics\n        self.nodes_expanded = 0\n        self.nodes_generated = 0\n\n    def plan(self, start, goal):\n        """\n        Find optimal path from start to goal.\n\n        Args:\n            start: (x, y) start position\n            goal: (x, y) goal position\n\n        Returns:\n            path: List of (x, y) positions, or None if no path\n            explored: Set of explored positions\n        """\n        self.nodes_expanded = 0\n        self.nodes_generated = 0\n\n        # Priority queue: (f_score, counter, x, y)\n        # Counter breaks ties for same f_score\n        counter = 0\n        open_set = [(self.heuristic(start, goal), counter, start[0], start[1])]\n\n        # Track visited nodes and their costs\n        g_score = {start: 0}\n        came_from = {}\n\n        # For visualization\n        explored = set()\n\n        while open_set:\n            # Get node with lowest f_score\n            f, _, x, y = heapq.heappop(open_set)\n            current = (x, y)\n\n            # Skip if we\'ve found a better path to this node\n            if current in explored:\n                continue\n\n            explored.add(current)\n            self.nodes_expanded += 1\n\n            # Goal check\n```python\n```python\n            if current == goal:\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"                return self._reconstruct_path(came_from, current), explored\n\n            # Expand neighbors\n            for nx, ny, cost in self.world.get_neighbors(x, y, self.connectivity):\n                neighbor = (nx, ny)\n                self.nodes_generated += 1\n\n                # Calculate tentative g_score\n                tentative_g = g_score[current] + cost\n\n                # If this path is better than any previous\n```python\n```python\n                if neighbor not in g_score or tentative_g < g_score[neighbor]:\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'                    g_score[neighbor] = tentative_g\n                    f_score = tentative_g + self.heuristic(neighbor, goal)\n                    came_from[neighbor] = current\n\n                    counter += 1\n                    heapq.heappush(open_set, (f_score, counter, nx, ny))\n\n        # No path found\n        return None, explored\n\n    def _reconstruct_path(self, came_from, current):\n        """Reconstruct path from came_from dictionary."""\n        path = [current]\n        while current in came_from:\n            current = came_from[current]\n            path.append(current)\n        return path[::-1]\n\n# Test A* with Euclidean heuristic\nplanner = AStarPlanner(world, heuristic=euclidean_distance, connectivity=8)\npath, explored = planner.plan(start, goal)\n\nif path:\n    print(f"Path found!")\n    print(f"  Path length: {len(path)} nodes")\n    print(f"  Nodes expanded: {planner.nodes_expanded}")\n    print(f"  Nodes generated: {planner.nodes_generated}")\n\n    # Calculate path cost\n    path_cost = 0\n    for i in range(len(path) - 1):\n        dx = path[i+1][0] - path[i][0]\n        dy = path[i+1][1] - path[i][1]\n        path_cost += np.sqrt(dx*dx + dy*dy)\n    print(f"  Path cost: {path_cost:.2f}")\nelse:\n    print("No path found!")\n\n# Visualize\nworld.visualize(path=path, start=start, goal=goal, explored=explored)\nplt.title(f\'A* with Euclidean Heuristic (expanded: {planner.nodes_expanded})\')\nplt.savefig(\'astar_euclidean.png\', dpi=150)\nplt.show()\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": Path found with visualization showing explored nodes (cyan) and final path (blue)."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-4-compare-heuristics",children:"Step 4: Compare Heuristics"}),"\n",(0,s.jsx)(e.p,{children:"Evaluate different heuristics on the same problem:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def compare_heuristics(world, start, goal):\n    \"\"\"Compare different heuristics on same problem.\"\"\"\n    heuristics = {\n        'Zero (Dijkstra)': zero_heuristic,\n        'Manhattan': manhattan_distance,\n        'Euclidean': euclidean_distance,\n        'Diagonal': diagonal_distance,\n        'Chebyshev': chebyshev_distance\n    }\n\n    results = {}\n\n    for name, h in heuristics.items():\n        planner = AStarPlanner(world, heuristic=h, connectivity=8)\n        path, explored = planner.plan(start, goal)\n\n        if path:\n            # Calculate path cost\n            path_cost = 0\n            for i in range(len(path) - 1):\n                dx = path[i+1][0] - path[i][0]\n                dy = path[i+1][1] - path[i][1]\n                path_cost += np.sqrt(dx*dx + dy*dy)\n\n            results[name] = {\n                'path_length': len(path),\n                'path_cost': path_cost,\n                'nodes_expanded': planner.nodes_expanded,\n                'nodes_generated': planner.nodes_generated,\n                'explored': explored\n            }\n        else:\n            results[name] = None\n\n    return results\n\n# Run comparison\nresults = compare_heuristics(world, start, goal)\n\n# Print comparison table\nprint(\"\\nHeuristic Comparison:\")\nprint(\"-\" * 70)\nprint(f\"{'Heuristic':<20} {'Path Cost':<12} {'Expanded':<12} {'Generated':<12}\")\nprint(\"-\" * 70)\nfor name, r in results.items():\n    if r:\n        print(f\"{name:<20} {r['path_cost']:<12.2f} {r['nodes_expanded']:<12} {r['nodes_generated']:<12}\")\nprint(\"-\" * 70)\n\n# Verify all paths have same cost (optimality)\ncosts = [r['path_cost'] for r in results.values() if r]\n```python\n```python\nif len(set([round(c, 2) for c in costs])) == 1:\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'    print(f"\\n\u2713 All heuristics found optimal path (cost = {costs[0]:.2f})")\nelse:\n    print(f"\\n\u2717 Path costs differ: {costs}")\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": All admissible heuristics find same-cost path; better heuristics expand fewer nodes."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-5-visualize-heuristic-comparison",children:"Step 5: Visualize Heuristic Comparison"}),"\n",(0,s.jsx)(e.p,{children:"Create side-by-side comparison:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def visualize_heuristic_comparison(world, start, goal, results):\n    \"\"\"Visualize explored areas for different heuristics.\"\"\"\n    fig, axes = plt.subplots(2, 3, figsize=(15, 10))\n    axes = axes.flatten()\n\n    heuristic_names = list(results.keys())\n\n    for idx, name in enumerate(heuristic_names):\n        ax = axes[idx]\n        r = results[name]\n\n        if r is None:\n            ax.set_title(f'{name}: No path')\n            continue\n\n        # Show grid\n        ax.imshow(world.grid, cmap='binary', origin='lower', alpha=0.5)\n\n        # Show explored cells\n        explored_x = [p[0] for p in r['explored']]\n        explored_y = [p[1] for p in r['explored']]\n        ax.scatter(explored_x, explored_y, c='cyan', s=5, alpha=0.5)\n\n        # Show path would go here (skipping for clarity)\n\n        # Start and goal\n        ax.plot(start[0], start[1], 'go', markersize=10)\n        ax.plot(goal[0], goal[1], 'r*', markersize=10)\n\n        ax.set_title(f'{name}\\nExpanded: {r[\"nodes_expanded\"]}')\n        ax.set_xlim(-1, world.width)\n        ax.set_ylim(-1, world.height)\n\n    # Hide unused subplot\n```python\n```python\n    if len(heuristic_names) < 6:\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"        axes[-1].axis('off')\n\n    plt.tight_layout()\n    plt.savefig('heuristic_comparison.png', dpi=150)\n    plt.show()\n\nvisualize_heuristic_comparison(world, start, goal, results)\n"})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": Six panels showing different exploration patterns; Dijkstra explores most, informed heuristics explore less."]})}),"\n",(0,s.jsx)(e.h3,{id:"step-6-apply-to-configuration-space",children:"Step 6: Apply to Configuration Space"}),"\n",(0,s.jsx)(e.p,{children:"Extend A* to robot joint space planning:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class ConfigSpaceAstar:\n    """A* planner in robot configuration space."""\n\n    def __init__(self, joint_limits, resolution=0.1, collision_checker=None):\n        """\n        Initialize C-space A* planner.\n\n        Args:\n            joint_limits: [(min, max), ...] for each joint\n            resolution: Grid resolution in radians\n            collision_checker: Function(q) -> bool (True if collision)\n        """\n        self.joint_limits = np.array(joint_limits)\n        self.resolution = resolution\n        self.collision_checker = collision_checker\n        self.n_joints = len(joint_limits)\n\n        # Compute grid dimensions\n        self.grid_dims = []\n        for (lo, hi) in joint_limits:\n            self.grid_dims.append(int((hi - lo) / resolution) + 1)\n\n    def config_to_grid(self, q):\n        """Convert continuous config to grid indices."""\n        indices = []\n        for i, qi in enumerate(q):\n            idx = int((qi - self.joint_limits[i, 0]) / self.resolution)\n            idx = np.clip(idx, 0, self.grid_dims[i] - 1)\n            indices.append(idx)\n        return tuple(indices)\n\n    def grid_to_config(self, indices):\n        """Convert grid indices to continuous config."""\n        q = []\n        for i, idx in enumerate(indices):\n            qi = self.joint_limits[i, 0] + idx * self.resolution\n            q.append(qi)\n        return np.array(q)\n\n    def get_neighbors(self, indices):\n        """Get neighboring grid cells."""\n        neighbors = []\n        for dim in range(self.n_joints):\n            for delta in [-1, 1]:\n                new_indices = list(indices)\n                new_indices[dim] += delta\n\n                # Check bounds\n```python\n```python\n                if 0 <= new_indices[dim] < self.grid_dims[dim]:\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'                    new_indices = tuple(new_indices)\n\n                    # Check collision\n                    q = self.grid_to_config(new_indices)\n                    if self.collision_checker is None or not self.collision_checker(q):\n                        neighbors.append((new_indices, self.resolution))\n\n        return neighbors\n\n    def heuristic(self, idx1, idx2):\n        """Euclidean distance in grid space."""\n        return np.sqrt(sum((i1 - i2)**2 for i1, i2 in zip(idx1, idx2))) * self.resolution\n\n    def plan(self, q_start, q_goal):\n        """Plan path from q_start to q_goal."""\n        start_idx = self.config_to_grid(q_start)\n        goal_idx = self.config_to_grid(q_goal)\n\n        # A* search\n        counter = 0\n        open_set = [(self.heuristic(start_idx, goal_idx), counter, start_idx)]\n\n        g_score = {start_idx: 0}\n        came_from = {}\n        explored = set()\n\n        while open_set:\n            f, _, current = heapq.heappop(open_set)\n\n            if current in explored:\n                continue\n            explored.add(current)\n\n```python\n```python\n            if current == goal_idx:\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"                # Reconstruct path\n                path_indices = [current]\n                while current in came_from:\n                    current = came_from[current]\n                    path_indices.append(current)\n                path_indices.reverse()\n\n                # Convert to configurations\n                path = [self.grid_to_config(idx) for idx in path_indices]\n                return path, explored\n\n            for neighbor, cost in self.get_neighbors(current):\n                tentative_g = g_score[current] + cost\n\n```python\n```python\n                if neighbor not in g_score or tentative_g < g_score[neighbor]:\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'                    g_score[neighbor] = tentative_g\n                    f_score = tentative_g + self.heuristic(neighbor, goal_idx)\n                    came_from[neighbor] = current\n                    counter += 1\n                    heapq.heappush(open_set, (f_score, counter, neighbor))\n\n        return None, explored\n\n# Example: Plan for 2-DOF arm\ndef simple_collision_check(q):\n    """Simple collision checker for demo."""\n    # Obstacle in C-space\n    obstacle_center = np.array([1.0, 0.5])\n    obstacle_radius = 0.3\n```python\n```python\n    return np.linalg.norm(q - obstacle_center) < obstacle_radius\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'\n# Create planner\njoint_limits = [(-np.pi, np.pi), (-np.pi, np.pi)]\ncspace_planner = ConfigSpaceAstar(joint_limits, resolution=0.1,\n                                   collision_checker=simple_collision_check)\n\n# Plan\nq_start = np.array([0.0, 0.0])\nq_goal = np.array([1.5, 1.0])\n\npath, explored = cspace_planner.plan(q_start, q_goal)\n\nif path:\n    print(f"C-space path found with {len(path)} waypoints")\n    print(f"Explored {len(explored)} grid cells")\nelse:\n    print("No path found in C-space")\n'})}),"\n",(0,s.jsx)("checkpoint",{children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected"}),": Path found in 2D configuration space, avoiding the circular obstacle region."]})}),"\n",(0,s.jsx)(e.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,s.jsx)(e.p,{children:"After completing this lab, you should have:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Code artifacts"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"astar.py"}),": A* algorithm implementation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"heuristics.py"}),": Collection of heuristic functions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"cspace_astar.py"}),": Configuration space planner"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Visual outputs"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"grid_world.png"}),": Environment visualization"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"astar_euclidean.png"}),": A* search with explored nodes"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"heuristic_comparison.png"}),": Side-by-side heuristic comparison"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Understanding"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"A* optimality conditions"}),"\n",(0,s.jsx)(e.li,{children:"Trade-offs between heuristic informativeness and computation"}),"\n",(0,s.jsx)(e.li,{children:"Grid-based vs. sampling-based planning"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"rubric",children:"Rubric"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Criterion"}),(0,s.jsx)(e.th,{children:"Points"}),(0,s.jsx)(e.th,{children:"Description"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Grid Environment"}),(0,s.jsx)(e.td,{children:"15"}),(0,s.jsx)(e.td,{children:"Correct obstacle representation and neighbor generation"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Heuristic Functions"}),(0,s.jsx)(e.td,{children:"20"}),(0,s.jsx)(e.td,{children:"Multiple correct, admissible heuristics"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"A* Implementation"}),(0,s.jsx)(e.td,{children:"30"}),(0,s.jsx)(e.td,{children:"Optimal path finding with proper data structures"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Heuristic Comparison"}),(0,s.jsx)(e.td,{children:"20"}),(0,s.jsx)(e.td,{children:"Fair comparison with performance analysis"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"C-Space Extension"}),(0,s.jsx)(e.td,{children:"15"}),(0,s.jsx)(e.td,{children:"Working configuration space planner"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Total"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"100"})}),(0,s.jsx)(e.td,{})]})]})]}),"\n",(0,s.jsx)(e.h2,{id:"common-errors",children:"Common Errors"}),"\n",(0,s.jsxs)("troubleshooting",{children:[(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Error"}),": A* returns suboptimal path\n",(0,s.jsx)(e.strong,{children:"Solution"}),": Check heuristic admissibility. Ensure h(n) never overestimates true cost."]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Error"}),": A* is very slow\n",(0,s.jsx)(e.strong,{children:"Solution"}),": Use more informed heuristic. Check priority queue implementation efficiency."]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Error"}),": Different heuristics give different path costs\n",(0,s.jsx)(e.strong,{children:"Solution"}),": One or more heuristics may be inadmissible or implementation has bugs."]})]}),"\n",(0,s.jsx)(e.h2,{id:"extensions",children:"Extensions"}),"\n",(0,s.jsx)(e.p,{children:"For advanced students:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Weighted A"}),"*: Implement A* with w*h(n) for faster but suboptimal search"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Anytime A"}),"*: Return best solution found so far, improve over time"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Multi-goal planning"}),": Find paths to multiple goals efficiently"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsxs)(e.em,{children:[(0,s.jsx)(e.em,{children:"D"})," Lite"]}),"*: Implement incremental replanning for changing environments"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"related-content",children:"Related Content"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Theory"}),": Module 06 theory.md, Section 6.3 (Graph Search)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Previous Lab"}),": Lab 06-01 (RRT Path Planning)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Next Lab"}),": Lab 06-03 (Trajectory Optimization)"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453(n,e,i){i.d(e,{R:()=>o,x:()=>l});var t=i(6540);const s={},r=t.createContext(s);function o(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);