"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[6976],{8453(e,n,t){t.d(n,{R:()=>s,x:()=>l});var a=t(6540);const i={},o=a.createContext(i);function s(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:n},e.children)}},9718(e,n,t){t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"textbook/modules/rigid-body-dynamics/labs/lab-02-01","title":"Computing Rigid Body Forces","description":"Objectives","source":"@site/docs/textbook/modules/02-rigid-body-dynamics/labs/lab-02-01.md","sourceDirName":"textbook/modules/02-rigid-body-dynamics/labs","slug":"/textbook/modules/rigid-body-dynamics/labs/lab-02-01","permalink":"/Hackathon-3/docs/textbook/modules/rigid-body-dynamics/labs/lab-02-01","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/textbook/modules/02-rigid-body-dynamics/labs/lab-02-01.md","tags":[],"version":"current","frontMatter":{"id":"lab-02-01","module_id":"02","title":"Computing Rigid Body Forces","difficulty":"guided","tier":"simulation","duration_minutes":60,"submission_format":"notebook","auto_gradable":true},"sidebar":"tutorialSidebar","previous":{"title":"Ethics: Safety Margins and Physical Harm Prevention","permalink":"/Hackathon-3/docs/textbook/modules/rigid-body-dynamics/ethics"},"next":{"title":"Simulating Free Fall and Impact","permalink":"/Hackathon-3/docs/textbook/modules/rigid-body-dynamics/labs/lab-02-02"}}');var i=t(4848),o=t(8453);const s={id:"lab-02-01",module_id:"02",title:"Computing Rigid Body Forces",difficulty:"guided",tier:"simulation",duration_minutes:60,submission_format:"notebook",auto_gradable:!0},l="Lab 02-01: Computing Rigid Body Forces",r={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Materials",id:"materials",level:2},{value:"Instructions",id:"instructions",level:2},{value:"Step 1: Create a Simple Rigid Body",id:"step-1-create-a-simple-rigid-body",level:3},{value:"Step 2: Analyze Free Fall",id:"step-2-analyze-free-fall",level:3},{value:"Step 3: Analyze Contact Forces",id:"step-3-analyze-contact-forces",level:3},{value:"Step 4: Apply External Forces",id:"step-4-apply-external-forces",level:3},{value:"Step 5: Rotational Dynamics",id:"step-5-rotational-dynamics",level:3},{value:"Expected Outcomes",id:"expected-outcomes",level:2},{value:"Rubric",id:"rubric",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"lab-02-01-computing-rigid-body-forces",children:"Lab 02-01: Computing Rigid Body Forces"})}),"\n",(0,i.jsx)(n.h2,{id:"objectives",children:"Objectives"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Calculate forces and moments on rigid bodies"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understand the relationship between forces and acceleration"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Verify Newton's second law in simulation"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Analyze contact forces in MuJoCo"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"materials",children:"Materials"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"Version"}),(0,i.jsx)(n.th,{children:"Tier"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"software"}),(0,i.jsx)(n.td,{children:"Python"}),(0,i.jsx)(n.td,{children:"3.10+"}),(0,i.jsx)(n.td,{children:"required"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"software"}),(0,i.jsx)(n.td,{children:"MuJoCo"}),(0,i.jsx)(n.td,{children:"3.0+"}),(0,i.jsx)(n.td,{children:"required"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"software"}),(0,i.jsx)(n.td,{children:"NumPy"}),(0,i.jsx)(n.td,{children:"1.24+"}),(0,i.jsx)(n.td,{children:"required"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"instructions",children:"Instructions"}),"\n",(0,i.jsx)(n.h3,{id:"step-1-create-a-simple-rigid-body",children:"Step 1: Create a Simple Rigid Body"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import mujoco\nimport numpy as np\n\n# Create a simple box model\nbox_xml = """\n<mujoco>\n  <option gravity="0 0 -9.81" timestep="0.001"/>\n\n  <worldbody>\n    <light diffuse="1 1 1" pos="0 0 3"/>\n    <geom type="plane" size="5 5 0.1" rgba="0.8 0.8 0.8 1"/>\n\n    <body name="box" pos="0 0 2">\n      <joint type="free"/>\n      <geom type="box" size="0.2 0.2 0.2" mass="1.0" rgba="0.2 0.6 0.8 1"/>\n    </body>\n  </worldbody>\n</mujoco>\n"""\n\nmodel = mujoco.MjModel.from_xml_string(box_xml)\ndata = mujoco.MjData(model)\n\nprint(f"Box mass: {model.body_mass[1]:.2f} kg")\nprint(f"Gravity: {model.opt.gravity}")\nprint(f"Expected weight: {model.body_mass[1] * abs(model.opt.gravity[2]):.2f} N")\n'})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Verification"}),": Box mass should be 1.0 kg, weight should be 9.81 N."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-2-analyze-free-fall",children:"Step 2: Analyze Free Fall"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Reset and let the box fall\nmujoco.mj_resetData(model, data)\n\n# Record trajectory during free fall\ntimes = []\nheights = []\nvelocities = []\naccelerations = []\n\nprev_vel = 0\ndt = model.opt.timestep\n\nfor i in range(500):  # 0.5 seconds\n    mujoco.mj_step(model, data)\n\n    times.append(data.time)\n    heights.append(data.qpos[2])  # z position\n    vel = data.qvel[2]  # z velocity\n    velocities.append(vel)\n\n    # Compute acceleration from velocity change\n```python\n```python\n    if i > 0:\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"        acc = (vel - prev_vel) / dt\n        accelerations.append(acc)\n    prev_vel = vel\n\n# Verify Newton's second law: a = g during free fall\nprint(\"\\nFree Fall Analysis:\")\nprint(f\"Expected acceleration: {model.opt.gravity[2]:.2f} m/s\xb2\")\nprint(f\"Measured acceleration: {np.mean(accelerations):.2f} m/s\xb2 (before contact)\")\n\n# Plot results\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(3, 1, figsize=(10, 10))\n\naxes[0].plot(times, heights)\naxes[0].set_ylabel('Height (m)')\naxes[0].set_title('Position vs Time')\naxes[0].grid(True)\n\naxes[1].plot(times, velocities)\naxes[1].set_ylabel('Velocity (m/s)')\naxes[1].set_title('Velocity vs Time')\naxes[1].grid(True)\n\naxes[2].plot(times[1:], accelerations)\naxes[2].axhline(y=-9.81, color='r', linestyle='--', label='g')\naxes[2].set_xlabel('Time (s)')\naxes[2].set_ylabel('Acceleration (m/s\xb2)')\naxes[2].set_title('Acceleration vs Time')\naxes[2].legend()\naxes[2].grid(True)\n\nplt.tight_layout()\nplt.savefig('free_fall_analysis.png', dpi=150)\nplt.show()\n"})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": Acceleration should be approximately -9.81 m/s\xb2 until contact.\n",(0,i.jsx)(n.strong,{children:"Analysis"}),": Note how acceleration changes suddenly at ground contact."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-3-analyze-contact-forces",children:"Step 3: Analyze Contact Forces"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# MuJoCo computes contact forces automatically\n# Let\'s examine them\n\nmujoco.mj_resetData(model, data)\n\n# Run until steady state (box resting on ground)\nfor _ in range(2000):\n    mujoco.mj_step(model, data)\n\n# Access contact information\nprint(f"\\nNumber of contacts: {data.ncon}")\n\nfor i in range(data.ncon):\n    contact = data.contact[i]\n    print(f"\\nContact {i}:")\n    print(f"  Position: {contact.pos}")\n    print(f"  Normal: {contact.frame[:3]}")\n    print(f"  Distance: {contact.dist:.6f}")\n\n    # Get contact force\n    force = np.zeros(6)\n    mujoco.mj_contactForce(model, data, i, force)\n    print(f"  Normal force: {force[0]:.2f} N")\n    print(f"  Friction force: [{force[1]:.2f}, {force[2]:.2f}] N")\n\n# Verify: normal force should equal weight\ntotal_normal = 0\nfor i in range(data.ncon):\n    force = np.zeros(6)\n    mujoco.mj_contactForce(model, data, i, force)\n    total_normal += force[0]\n\nprint(f"\\nTotal normal force: {total_normal:.2f} N")\nprint(f"Box weight: {model.body_mass[1] * 9.81:.2f} N")\n'})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Verification"}),": Total normal force should approximately equal the box weight (9.81 N).\n",(0,i.jsx)(n.strong,{children:"Understanding"}),": This demonstrates Newton's third law (equal and opposite forces)."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-4-apply-external-forces",children:"Step 4: Apply External Forces"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Apply an external force to the box\nmujoco.mj_resetData(model, data)\n\n# Lift box slightly above ground\ndata.qpos[2] = 0.5\n\n# Apply a horizontal force\nexternal_force = np.array([5.0, 0, 0, 0, 0, 0])  # 5N in x direction\n\n# Record trajectory\ntimes = []\nx_positions = []\nx_velocities = []\n\nfor i in range(1000):\n    # Apply force to body\n    data.xfrc_applied[1] = external_force\n\n    mujoco.mj_step(model, data)\n\n    times.append(data.time)\n    x_positions.append(data.qpos[0])  # x position\n    x_velocities.append(data.qvel[0])  # x velocity\n\n# Analyze motion\n# F = ma => a = F/m = 5/1 = 5 m/s\xb2\nexpected_acc = 5.0 / model.body_mass[1]\n\n# Fit velocity to get acceleration\nfrom numpy.polynomial import polynomial as P\ncoeffs = np.polyfit(times, x_velocities, 1)\nmeasured_acc = coeffs[0]\n\nprint(f\"\\nForce Application Analysis:\")\nprint(f\"Applied force: {external_force[0]:.1f} N\")\nprint(f\"Expected acceleration: {expected_acc:.2f} m/s\xb2\")\nprint(f\"Measured acceleration: {measured_acc:.2f} m/s\xb2\")\n\n# Plot\nfig, axes = plt.subplots(2, 1, figsize=(10, 6))\n\naxes[0].plot(times, x_positions)\naxes[0].set_ylabel('X Position (m)')\naxes[0].set_title('Position Under Constant Force')\naxes[0].grid(True)\n\naxes[1].plot(times, x_velocities, label='Measured')\naxes[1].plot(times, [expected_acc * t for t in times], '--', label='Expected (F=ma)')\naxes[1].set_xlabel('Time (s)')\naxes[1].set_ylabel('X Velocity (m/s)')\naxes[1].legend()\naxes[1].grid(True)\n\nplt.tight_layout()\nplt.savefig('force_application.png', dpi=150)\nplt.show()\n"})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected"}),": Measured acceleration should match F/m = 5 m/s\xb2.\n",(0,i.jsx)(n.strong,{children:"Note"}),": Slight deviations occur due to numerical integration and any friction."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-5-rotational-dynamics",children:"Step 5: Rotational Dynamics"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Create a box and apply torque\nmujoco.mj_resetData(model, data)\ndata.qpos[2] = 1.0  # Raise box\n\n# Apply torque about z-axis\ntorque = np.array([0, 0, 0, 0, 0, 2.0])  # 2 Nm about z\n\n# Record rotation\ntimes = []\nangles = []\nangular_velocities = []\n\nfor i in range(500):\n    data.xfrc_applied[1] = torque\n    mujoco.mj_step(model, data)\n\n    times.append(data.time)\n\n    # Get rotation from quaternion\n    quat = data.qpos[3:7]\n    # Convert to axis-angle (simplified: just track z rotation)\n    # For small rotations: angle \u2248 2 * quat[3] for z-axis\n    angles.append(2 * np.arcsin(quat[3]))\n    angular_velocities.append(data.qvel[5])  # z angular velocity\n\n# Compute inertia (for a uniform box)\n# I = (1/12) * m * (a\xb2 + b\xb2) for rotation about z\n# where a, b are the x, y dimensions\nbox_size = 0.2  # half-size\nmass = model.body_mass[1]\nI_zz = (1/12) * mass * (2 * (2*box_size)**2)\nprint(f"\\nRotational Dynamics:")\nprint(f"Computed moment of inertia (z): {I_zz:.4f} kg\u22c5m\xb2")\n\n# Expected angular acceleration: alpha = tau / I\nexpected_alpha = torque[5] / I_zz\nprint(f"Applied torque: {torque[5]:.1f} Nm")\nprint(f"Expected angular acceleration: {expected_alpha:.2f} rad/s\xb2")\n\n# Measure from simulation\nalpha_measured = np.gradient(angular_velocities, times).mean()\nprint(f"Measured angular acceleration: {alpha_measured:.2f} rad/s\xb2")\n'})}),"\n",(0,i.jsx)("checkpoint",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Verification"}),": Angular acceleration should match \u03c4/I.\n",(0,i.jsx)(n.strong,{children:"Analysis"}),": Any discrepancy may be due to the actual inertia tensor vs. simplified calculation."]})}),"\n",(0,i.jsx)(n.h2,{id:"expected-outcomes",children:"Expected Outcomes"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Verified Newton's second law in free fall"}),"\n",(0,i.jsx)(n.li,{children:"Contact force analysis matching body weight"}),"\n",(0,i.jsx)(n.li,{children:"External force response matching F=ma"}),"\n",(0,i.jsx)(n.li,{children:"Rotational dynamics matching \u03c4=I\u03b1"}),"\n",(0,i.jsxs)(n.li,{children:["Saved plots: ",(0,i.jsx)(n.code,{children:"free_fall_analysis.png"}),", ",(0,i.jsx)(n.code,{children:"force_application.png"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"rubric",children:"Rubric"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Criterion"}),(0,i.jsx)(n.th,{children:"Points"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Free Fall Analysis"}),(0,i.jsx)(n.td,{children:"25"}),(0,i.jsx)(n.td,{children:"Correctly analyzes motion and verifies g"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Contact Forces"}),(0,i.jsx)(n.td,{children:"25"}),(0,i.jsx)(n.td,{children:"Properly extracts and interprets contact data"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Linear Dynamics"}),(0,i.jsx)(n.td,{children:"25"}),(0,i.jsx)(n.td,{children:"Verifies F=ma with external forces"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Rotational Dynamics"}),(0,i.jsx)(n.td,{children:"15"}),(0,i.jsx)(n.td,{children:"Analyzes torque and angular acceleration"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Documentation"}),(0,i.jsx)(n.td,{children:"10"}),(0,i.jsx)(n.td,{children:"Clear explanations and analysis"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Total: 100 points"})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);